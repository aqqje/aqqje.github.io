<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[favorite]]></title>
    <url>%2F2018%2F07%2F28%2Ffavorite%2F</url>
    <content type="text"><![CDATA[收藏夹Typora 的使用手册]]></content>
      <tags>
        <tag>favorite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 问题锦集]]></title>
    <url>%2F2018%2F06%2F06%2FAndroid-%E9%97%AE%E9%A2%98%E9%94%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Android 问题锦集 android studio新建项目时出现Error:Execution failed for task ‘:app:preDebugAndroidTestBuild’.1.在app下的build.gradle文件中的dependences {}中添加如下代码： androidTestCompile(‘com.android.support:support-annotations:26.1.0’) { force = true} 1234567891011121314dependencies &#123; androidTestCompile(&apos;com.android.support:support-annotations:26.1.0&apos;) &#123; force = true &#125; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation&quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot; implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;&#125; 参考 android studio 出现 “Unsupported method: BaseConfig.getApplicationIdSuffix()”找到项目下的 gradle – &gt; build.gradle 修改如下 1234567891011121314buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // 原先错误原因请删除或注释掉 //classpath 'com.android.tools.build:gradle:1.0.0' // 修改如下: classpath 'com.android.tools.build:gradle:2.3.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 参考 Android studio 出现 “Error:Failed to open zip file. Gradle’s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)”]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win7 应用程序图标显示异常]]></title>
    <url>%2F2018%2F05%2F31%2Fwin7-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[描述：有时不知道自己做了什么，突然有一两个应用图标显示总是不正常，让人十分不开心！ 如何解决win键 + R –&gt; cmd –&gt; 输入以下内容： taskkill /im explorer.exe /fcd /d %userprofile%\appdata\localdel iconcache.db /astart explorer.exeexit 成功]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 完全卸载]]></title>
    <url>%2F2018%2F05%2F30%2FMySQL-%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[MySQL 完全卸载 note 卸载程序卸载所有的 MySQL 组件程序 删除 MySQL 安装目录C:\Program Files\MySQLC:\ProgramData\MySQLC:\Users\zhenghaishu\AppData\Roaming\MySQLC:\Users\zhenghaishu\AppData\Local\Temp\MySQL WorkbenchC:\Users\zhenghaishu\AppData\Roaming\Oracle\MySQL Notifier 删除注册表 进入注册表 使用 winq键 + r 输入 regedit 命令 打开注册表 删除注册表 HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/Eventlog/Application/MySQLHKEY_LOCAL_MACHINE/SYSTEM/ControlSet002/Services/Eventlog/Application/MySQLHKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Application/MySQL Win7完全卸载MySQL的步骤]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybaties learn]]></title>
    <url>%2F2018%2F05%2F29%2FMybaties-learn%2F</url>
    <content type="text"><![CDATA[Mybaties learn note mybaties-HelloWord 加入必要 jar 包 log4j.jar： 日志包 与 log4j.xml 文件共同使用 mybatis-3.4.1.jar：mybaties 必要包 mysql-connector-java-5.1.45.jar：mysql 数据库连接包 2.创建 mybaties 全局配置文件 mybaties-config.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///mybaties"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 3.编写 Employee bean 4.创建 EmployyeMapper.xml 文件并注册在 mybaties 全局配置文件中 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace:命令空间,指定为接口的全类名 id: 唯一标识符 resultType:返回值类型 #&#123;id&#125;: 从传递过来的参数中取出id值--&gt;EmployyeMapper.xml：&lt;mapper namespace="com.aqqje.mybaties.mapper"&gt; &lt;select id="selectEmployee" resultType="com.aqqje.mybaties.beans.Employee"&gt; &lt;!-- 若数据库的字段名与 bean 的属性不一致时请使用别名 --&gt; select id, last_name lastName, email, gender from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;mybaties-config.xml： &lt;!-- 注册 EmployyeMapper对应的 sql 映射 --&gt; &lt;mappers&gt; &lt;mapper resource="conf/EmployeeMapper.xml"/&gt; &lt;/mappers&gt; 5.编写测试类 MybatiesTest a. Mybaties 框架主要是围绕 SqlSessionFactory 这个类进行工作的, 创建 SqlSessionFactory 对象 b. 获取 sqlSession 实例 c. 使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查 d. 一个sqlSession就是代表和数据库的一次会话，用完关闭 1234567891011121314151617public SqlSessionFactory getSqlSessionFactory() throws Exception &#123; String resource = "conf/mybaties-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); return sqlSessionFactory; &#125; @Test public void testSelectOne() throws Exception &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); try &#123; Employee employee = session.selectOne("com.aqqje.mybaties.mapper.selectEmployee", 1); System.out.println(employee); &#125; finally &#123; session.close(); &#125; &#125; mybaties-HelloWord基础之上实现接口式编程 新建一个接口 EmployeeMapper 抽象 getEmpById(Integer id) 方法 EmployeeMapper.xml 文件中绑定 EmployeeMapper 接口 和 方法 使用 sqlSession.getMapper(Class var1) 方法获取 EmployyeMapper 对象 调用 getEmpById(Integer id) 123456789101112131415EmployeeMapper.xml:&lt;mapper namespace="com.aqqje.mybaties.dao.EmployeeMapper"&gt; &lt;select id="getEmpById" resultType="com.aqqje.mybaties.beans.Employee"&gt;select id, last_name lastName, email, gender from tbl_employee where id = #&#123;id&#125;&lt;/select&gt;&lt;/mapper&gt;MybatiesTest.java: //获取接口的实现类对象 //会为接口自动的创建一个代理对象，代理对象去执行增删改查方法 EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); Employee employee = employeeMapper.getEmpById(1); System.out.println(employee); properties标签 mybatis可以使用properties来引入外部properties配置文件的内容； resource：引入类路径下的资源 url：引入网络路径或者磁盘路径下的资源 settings 标签 设置 描述 有效值 默认 mapUnderscoreToCamelCase 可以所数据库中以 last_name 命令方式转化为 lastName 的驼峰形式 false, true false typeAliases(类型别名)别名处理器：可以为我们的java类型起别名,别名不区分大小写 1.typeAlias:为某个java类型起别名 type:指定类型,默认别名为类名小写：employee alias:指定新的别名 2.package:为某个包下的所有类批量起别名 name：指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写），） 批量起别名的情况下，使用@Alias注解为某个类型指定新的别名 mybaties 中对于常见Java类型有许多内置类型别名 它们都是大小写不敏感的，注意由于重载名称而对基元的特殊处理。 8大基础类型, 在类型前加 “_”: alias -&gt; _byte, _long, int, …… 引用类, 类型转小写： alias -&gt; string , byte, date, ….. typeHandlers 类型处理器 Mybaties 3.4以前的版本需要我们手动注册这些处理, 以后的版本都是自动注册的 123&lt;typeHandlers&gt; &lt;typeHandler handler="org.apache.ibatis.type.IntegerTypeHandler"/&gt; &lt;/typeHandlers&gt; plugins(插件) Execotor ParamterHandler ResultSetHandler StatementHandler environments：环境们，mybatis可以配置多种环境 ,default指定使用某种环境。可以达到快速切换环境。environment：配置一个具体的环境信息；必须有两个标签；id代表当前环境的唯一标识 transactionManager：事务管理器； type：事务管理器的类型;JDBC(JdbcTransactionFactory)|MANAGED(ManagedTransactionFactory) 自定义事务管理器：实现TransactionFactory接口.type指定为全类名 dataSource：数据源; type:数据源类型;UNPOOLED(UnpooledDataSourceFactory) |POOLED(PooledDataSourceFactory) |JNDI(JndiDataSourceFactory) 自定义数据源：实现DataSourceFactory接口，type是全类名 databaseIdProvider 支持多数据库厂商的 type=”DB_VENDOR”：VendorDatabaseIdProvider 作用就是得到数据库厂商的标识(驱动getDatabaseProductName())，mybatis就能根据数据库厂商标识来执行不同的sql; MySQL，Oracle，SQL Server,xxxx 使用： mybaties-config 切换要配置环境 &amp;&amp; sql映射文件中添加 databaseId=”mysql” 标识使用数据库类型 1234567891011121314151617mybaties-config.xml:&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;!-- 为不同的数据库厂商起别名 --&gt; &lt;property name="MySQL" value="mysql"/&gt; &lt;property name="Oracle" value="oracle"/&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;/databaseIdProvider&gt; EmployeeMapper.xml: &lt;select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; mappers mapper:注册一个sql映射 注册配置文件 resource：引用类路径下的sql映射文件 mybatis/mapper/EmployeeMapper.xml url：引用网路路径或者磁盘路径下的sql映射文件 file:///var/mappers/AuthorMapper.xml 注册接口 class：引用（注册）接口， 1、有sql映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下； 2、没有sql映射文件，所有的sql都是利用注解写在接口上; 推荐： 比较重要的，复杂的Dao接口我们来写sql映射文件 不重要，简单的Dao接口为了开发快速可以使用注解； 批量注册： 简单的 CRUD 1、mybatis允许增删改直接定义以下类型返回值 Integer、Long、Boolean、void 2、我们需要手动提交数据 sqlSessionFactory.openSession();===》手动提交 sqlSessionFactory.openSession(true);===》自动提交 3.mapper.xml文件中 parameterType 可以省略 123456789101112&lt;select id="getEmpById" resultType="com.aqqje.mybaties.beans.Employee"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertEmp" parameterType="com.aqqje.mybaties.beans.Employee"&gt; insert into tbl_employee(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; &lt;update id="updateEmpById" &gt; update tbl_employee set last_name = #&#123;lastName&#125;, gender = #&#123;gender&#125;, email = #&#123;email&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="deletEmpById"&gt; delete from tbl_employee where id = #&#123;id&#125; &lt;/delete&gt; 参数处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143单个参数：mybatis不会做特殊处理， #&#123;参数名/任意名&#125;：取出参数值。 多个参数：mybatis会做特殊处理。 多个参数会被封装成 一个map， key：param1...paramN,或者参数的索引也可以 value：传入的参数值 #&#123;&#125;就是从map中获取指定的key的值； 异常： org.apache.ibatis.binding.BindingException: Parameter &apos;id&apos; not found. Available parameters are [1, 0, param1, param2] 操作： 方法：public Employee getEmpByIdAndLastName(Integer id,String lastName); 取值：#&#123;id&#125;,#&#123;lastName&#125;【命名参数】：明确指定封装参数时map的key；@Param(&quot;id&quot;) 多个参数会被封装成 一个map， key：使用@Param注解指定的值 value：参数值 #&#123;指定的key&#125;取出对应的参数值POJO：如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo； #&#123;属性名&#125;：取出传入的pojo的属性值 Map：如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map #&#123;key&#125;：取出map中对应的值TO：如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象Page&#123; int index; int size;&#125;========================思考================================ public Employee getEmp(@Param(&quot;id&quot;)Integer id,String lastName); 取值：id==&gt;#&#123;id/param1&#125; lastName==&gt;#&#123;param2&#125;public Employee getEmp(Integer id,@Param(&quot;e&quot;)Employee emp); 取值：id==&gt;#&#123;param1&#125; lastName===&gt;#&#123;param2.lastName/e.lastName&#125;##特别注意：如果是Collection（List、Set）类型或者是数组， 也会特殊处理。也是把传入的list或者数组封装在map中。 key：Collection（collection）,如果是List还可以使用这个key(list) 数组(array)public Employee getEmpById(List&lt;Integer&gt; ids); 取值：取出第一个id的值： #&#123;list[0]&#125; ========================结合源码，mybatis怎么处理参数==========================总结：参数多时会封装map，为了不混乱，我们可以使用@Param来指定封装时使用的key；#&#123;key&#125;就可以取出map中的值；(@Param(&quot;id&quot;)Integer id,@Param(&quot;lastName&quot;)String lastName);ParamNameResolver解析参数封装map的；//1、names：&#123;0=id, 1=lastName&#125;；构造器的时候就确定好了 确定流程： 1.获取每个标了param注解的参数的@Param的值：id，lastName； 赋值给name; 2.每次解析一个参数给map中保存信息：（key：参数索引，value：name的值） name的值： 标注了param注解：注解的值 没有标注： 1.全局配置：useActualParamName（jdk1.8）：name=参数名 2.name=map.size()；相当于当前元素的索引 &#123;0=id, 1=lastName,2=2&#125; args【1，&quot;Tom&quot;,&apos;hello&apos;】:public Object getNamedParams(Object[] args) &#123; final int paramCount = names.size(); //1、参数为null直接返回 if (args == null || paramCount == 0) &#123; return null; //2、如果只有一个元素，并且没有Param注解；args[0]：单个参数直接返回 &#125; else if (!hasParamAnnotation &amp;&amp; paramCount == 1) &#123; return args[names.firstKey()]; //3、多个元素或者有Param标注 &#125; else &#123; final Map&lt;String, Object&gt; param = new ParamMap&lt;Object&gt;(); int i = 0; //4、遍历names集合；&#123;0=id, 1=lastName,2=2&#125; for (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123; //names集合的value作为key; names集合的key又作为取值的参考args[0]:args【1，&quot;Tom&quot;】: //eg:&#123;id=args[0]:1,lastName=args[1]:Tom,2=args[2]&#125; param.put(entry.getValue(), args[entry.getKey()]); // add generic param names (param1, param2, ...)param //额外的将每一个参数也保存到map中，使用新的key：param1...paramN //效果：有Param注解可以#&#123;指定的key&#125;，或者#&#123;param1&#125; final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1); // ensure not to overwrite parameter named with @Param if (!names.containsValue(genericParamName)) &#123; param.put(genericParamName, args[entry.getKey()]); &#125; i++; &#125; return param; &#125; &#125;&#125;===========================参数值的获取======================================#&#123;&#125;：可以获取map中的值或者pojo对象属性的值；$&#123;&#125;：可以获取map中的值或者pojo对象属性的值；select * from tbl_employee where id=$&#123;id&#125; and last_name=#&#123;lastName&#125;Preparing: select * from tbl_employee where id=2 and last_name=? 区别： #&#123;&#125;:是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 $&#123;&#125;:取出的值直接拼装在sql语句中；会有安全问题； 大多情况下，我们去参数的值都应该去使用#&#123;&#125;； 原生jdbc不支持占位符的地方我们就可以使用$&#123;&#125;进行取值 比如分表、排序。。。；按照年份分表拆分 select * from $&#123;year&#125;_salary where xxx; select * from tbl_employee order by $&#123;f_name&#125; $&#123;order&#125;#&#123;&#125;:更丰富的用法： 规定参数的一些规则： javaType、 jdbcType、 mode（存储过程）、 numericScale、 resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）； jdbcType通常需要在某种特定的条件下被设置： 在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）； JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理; 由于全局配置中：jdbcTypeForNull=OTHER；oracle不支持；两种办法 1、#&#123;email,jdbcType=OTHER&#125;; 2、jdbcTypeForNull=NULL &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;/&gt; 获取自增主键的值：mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGenreatedKeys()； useGeneratedKeys=&quot;true&quot;；使用自增主键获取主键值策略 keyProperty；指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给javaBean的哪个属性 123&lt;insert id="insertEmp" parameterType="com.aqqje.mybaties.beans.Employee" useGeneratedKeys="true" keyProperty="id"&gt; insert into tbl_employee(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; 获取非自增主键的值：Oracle不支持自增；Oracle使用序列来模拟自增； 每次插入的数据的主键是从序列中拿到的值；如何获取到这个值； keyProperty:查出的主键值封装给javaBean的哪个属性 order=&quot;BEFORE&quot;:当前sql在插入sql之前运行 AFTER：当前sql在插入sql之后运行 resultType:查出的数据的返回值类型 BEFORE运行顺序： 先运行selectKey查询id的sql；查出id值封装给javaBean的id属性 在运行插入的sql；就可以取出id属性对应的值 AFTER运行顺序： 先运行插入的sql（从序列中取出新值作为id）； 再运行selectKey查询id的sql； 123456789101112131415&lt;insert id="addEmp" databaseId="oracle"&gt; &lt;selectKey keyProperty="id" order="BEFORE" resultType="Integer"&gt; &lt;!-- BEFORE--&gt; select EMPLOYEES_SEQ.nextval from dual &lt;!-- AFTER： select EMPLOYEES_SEQ.currval from dual --&gt; &lt;/selectKey&gt; &lt;!-- BEFORE:--&gt; insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) values(#&#123;id&#125;,#&#123;lastName&#125;,#&#123;email&lt;!-- ,jdbcType=NULL --&gt;&#125;) &lt;!-- AFTER： insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) values(employees_seq.nextval,#&#123;lastName&#125;,#&#123;email&#125;) --&gt;&lt;/insert&gt; resultMap:自定义结果集映射规则1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!--自定义某个javaBean的封装规则type：自定义规则的Java类型id:唯一id方便引用 --&gt;&lt;resultMap id="myMap" type="com.aqqje.mybaties.beans.Employee"&gt; &lt;!--指定主键列的封装规则 id定义主键会底层有优化； column：指定哪一列 property：指定对应的javaBean属性 --&gt; &lt;id column="id" property="id"/&gt; &lt;!-- 定义普通列封装规则 --&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;!-- 其他不指定的列会自动封装：我们只要写resultMap就把全部的映射规则都写上。 --&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;/resultMap&gt;&lt;!-- 联合查询： 1.支持级联属性封装对象 2.使用 association--&gt;&lt;resultMap id="mydifMap" type="com.aqqje.mybaties.beans.Employee"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;!--&lt;result column="did" property="department.id"/&gt; &lt;result column="name" property="department.name"/&gt;--&gt; &lt;association property="department" javaType="com.aqqje.mybaties.beans.Department"&gt; &lt;id column="did" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;/association&gt;&lt;!-- 使用association进行分步查询： 1、先按照员工id查询员工信息 2、根据查询员工信息中的d_id值去部门表查出部门信息 3、部门设置到员工中；--&gt;&lt;resultMap id="mydifMap" type="com.aqqje.mybaties.beans.Employee"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;!-- association定义关联对象的封装规则 select:表明当前属性是调用select指定的方法查出的结果 column:指定将哪一列的值传给这个方法 流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性 --&gt; &lt;association property="department" select="com.aqqje.mybaties.dao.DepartmentMapper.getDeptById" column="did"/&gt; &lt;/resultMap&gt; 分步延迟加载设置12345&lt;!--显示的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题 --&gt; &lt;!-- 开启加载 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 关闭全加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; collection标签定义关联的集合类型12345678910111213141516171819202122232425262728293031323334353637&lt;!--嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则 --&gt;&lt;resultMap id="deptListMap" type="com.aqqje.mybaties.beans.Department"&gt; &lt;id column="deptid" property="id"/&gt; &lt;result column="deptname" property="name"/&gt; &lt;!-- collection定义关联集合类型的属性的封装规则 ofType:指定集合里面元素的类型 --&gt; &lt;collection property="employeeList" ofType="com.aqqje.mybaties.beans.Employee"&gt; &lt;!-- 定义这个集合中元素的封装规则 --&gt; &lt;id column="empid" property="id"/&gt; &lt;result column="empname" property="lastName"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="getDeptByIdPlus" resultMap="deptListMap"&gt; SELECT d.id deptid, d.id deptname, e.id empid, e.last_name empname, e.email, e.gender FROM tbl_dept d LEFT JOIN tbl_employee e ON e.dept_id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 扩展：多列的值传递过去： 将多列的值封装map传递； column="&#123;key1=column1,key2=column2&#125;" fetchType="lazy"：表示使用延迟加载； - lazy：延迟 - eager：立即 --&gt; &lt;collection property="emps" select="com.atguigu.mybatis.dao.EmployeeMapperPlus.getEmpsByDeptId" column="&#123;deptId=id&#125;" fetchType="lazy"&gt;&lt;/collection&gt; 鉴别器mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为 1234567891011121314151617181920212223242526272829303132&lt;!--封装Employee： 如果查出的是女生：就把部门信息查询出来，否则不查询； 如果是男生，把last_name这一列的值赋值给email; --&gt; &lt;resultMap id="mydifMap" type="com.aqqje.mybaties.beans.Employee"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;!-- column：指定判定的列名 javaType：列值对应的java类型 --&gt; &lt;discriminator column="gender" javaType="string" &gt; &lt;!--女生 resultType:指定封装的结果类型；不能缺少。/resultMap--&gt; &lt;case value="0" resultType="com.aqqje.mybaties.beans.Employee"&gt; &lt;association property="department" select="com.aqqje.mybaties.dao.DepartmentMapper.getDeptById" column="did"/&gt; &lt;/case&gt; &lt;!--男生 ;如果是男生，把last_name这一列的值赋值给email; --&gt; &lt;case value="1" resultType="com.aqqje.mybaties.beans.Employee"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;result column="last_name" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;association property="department" select="com.aqqje.mybaties.dao.DepartmentMapper.getDeptById" column="did"/&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; mybaties 动态sqL• if:判断• choose (when, otherwise):分支选择；带了break的swtich-case 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个• trim 字符串截取(where(封装查询条件), set(封装修改条件))• foreach 遍历集合 if:判断 1234567891011121314151617181920212223242526272829303132&lt;!-- 查询员工，要求，携带了哪个字段查询条件就带上这个字段的值 --&gt;&lt;select id="getEmpList" resultMap="mydifMap"&gt; SELECT * FROM tbl_employee &lt;where&gt; &lt;!-- test：判断表达式（OGNL） OGNL参照PPT或者官方文档。 c:if test 从参数中取值进行判断 遇见特殊符号应该去写转义字符： &amp;&amp;： --&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test="lastName !=null and lastName!=''"&gt; and last_name=#&#123;lastName&#125; &lt;/if&gt; &lt;if test="email!=null and email.trim()!=''"&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;!-- ognl会进行字符串与数字的转换判断 "0"==0 --&gt; &lt;if test="gender == 0 or gender ==1"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 查询的时候如果某些条件没带可能sql拼装会有问题 1、给where后面加上1=1，以后的条件都and xxx. 2、mybatis使用where标签来将所有的查询条件包括在内。mybatis就会将where标签中拼装的sql，多出来的and或者or去掉 where只会去掉第一个多出来的and或者or。--&gt; trim 12345678910111213141516171819202122232425262728&lt;!-- 后面多出的and或者or where标签不能解决 prefix="":前缀：trim标签体中是整个字符串拼串 后的结果。 prefix给拼串后的整个字符串加一个前缀 prefixOverrides="": 前缀覆盖： 去掉整个字符串前面多余的字符 suffix="":后缀 suffix给拼串后的整个字符串加一个后缀 suffixOverrides="" 后缀覆盖：去掉整个字符串后面多余的字符 --&gt;&lt;select id="getEmpList" resultMap="mydifMap"&gt; SELECT * FROM tbl_employee &lt;trim prefix="where" suffixOverrides="and"&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test="lastName !=null and lastName!=''"&gt; and last_name=#&#123;lastName&#125; &lt;/if&gt; &lt;if test="email!=null and email.trim()!=''"&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;if test="gender == 0 or gender ==1"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; choose 1234567891011121314151617181920&lt;select id="getEmpList" resultMap="mydifMap"&gt; select * from tbl_employee &lt;where&gt; &lt;!-- 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个 --&gt; &lt;choose&gt; &lt;when test="id!=null"&gt; id=#&#123;id&#125; &lt;/when&gt; &lt;when test="lastName!=null"&gt; last_name like #&#123;lastName&#125; &lt;/when&gt; &lt;when test="email!=null"&gt; email = #&#123;email&#125; &lt;/when&gt; &lt;otherwise&gt; gender = 0 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; Set标签的使用 12345678910111213141516171819&lt;update id="updateEmpSet" &gt; update tbl_employee &lt;set&gt; &lt;if test="lastName !=null and = lastName != ''"&gt; last_name=#&#123;lastName&#125;, &lt;/if&gt; &lt;if test="email!=null and email.trim()!=''"&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test="gender == 0 or gender ==1"&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/set&gt; &lt;where&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;/where&gt; &lt;/update&gt; foreach 12345678910111213141516171819&lt;!-- collection：指定要遍历的集合： list类型的参数会特殊处理封装在map中，map的key就叫list item：将当前遍历出的元素赋值给指定的变量 separator:每个元素之间的分隔符 open：遍历出所有结果拼接一个开始的字符 close:遍历出所有结果拼接一个结束的字符 index:索引。遍历list的时候是index就是索引，item就是当前值 遍历map的时候index表示的就是map的key，item就是map的值 #&#123;变量名&#125;就能取出变量的值也就是当前遍历出的元素--&gt;&lt;select id="getEmpForEach" resultMap="mydifMap"&gt; select id, last_name, email, gender, dept_id did from tbl_employee where id in &lt;foreach collection="ids" separator="," item="emp_id" open="(" close=")"&gt; #&#123;emp_id&#125; &lt;/foreach&gt; &lt;/select&gt; 批量新增 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!-- 批量保存 --&gt; &lt;!--public void addEmps(@Param("emps")List&lt;Employee&gt; emps); --&gt; &lt;!--MySQL下批量保存：可以foreach遍历 mysql支持values(),(),()语法--&gt;&lt;!--&lt;insert id="insertList"&gt; INSERT INTOtbl_employee (last_name, gender, email, dept_id)VALUES&lt;foreach collection="emps" item="emps" separator=","&gt; (#&#123;emps.lastName&#125; ,#&#123;emps.gender&#125;, #&#123;emps.email&#125;, #&#123;emps.department.id&#125;) &lt;/foreach&gt; &lt;/insert&gt;--&gt; &lt;insert id="insertList"&gt; &lt;foreach collection="emps" item="emps" separator=";"&gt; INSERT INTO tbl_employee (last_name, gender, email, dept_id) VALUES (#&#123;emps.lastName&#125; ,#&#123;emps.gender&#125;, #&#123;emps.email&#125;, #&#123;emps.department.id&#125;) &lt;/foreach&gt; &lt;/insert&gt;&lt;!-- 这种方式需要数据库连接属性allowMultiQueries=true； 这种分号分隔多个sql可以用于其他的批量操作（删除，修改） --&gt; &lt;!-- &lt;insert id="addEmps"&gt; &lt;foreach collection="emps" item="emp" separator=";"&gt; insert into tbl_employee(last_name,email,gender,d_id) values(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt; &lt;/insert&gt; --&gt; &lt;!-- Oracle数据库批量保存： Oracle不支持values(),(),() Oracle支持的批量方式 1、多个insert放在begin - end里面 begin insert into employees(employee_id,last_name,email) values(employees_seq.nextval,'test_001','test_001@atguigu.com'); insert into employees(employee_id,last_name,email) values(employees_seq.nextval,'test_002','test_002@atguigu.com'); end; 2、利用中间表： insert into employees(employee_id,last_name,email) select employees_seq.nextval,lastName,email from( select 'test_a_01' lastName,'test_a_e01' email from dual union select 'test_a_02' lastName,'test_a_e02' email from dual union select 'test_a_03' lastName,'test_a_e03' email from dual ) --&gt; &lt;insert id="addEmps" databaseId="oracle"&gt; &lt;!-- oracle第一种批量方式 --&gt; &lt;!-- &lt;foreach collection="emps" item="emp" open="begin" close="end;"&gt; insert into employees(employee_id,last_name,email) values(employees_seq.nextval,#&#123;emp.lastName&#125;,#&#123;emp.email&#125;); &lt;/foreach&gt; --&gt; &lt;!-- oracle第二种批量方式 --&gt; insert into employees( &lt;!-- 引用外部定义的sql --&gt; &lt;include refid="insertColumn"&gt; &lt;property name="testColomn" value="abc"/&gt; &lt;/include&gt; ) &lt;foreach collection="emps" item="emp" separator="union" open="select employees_seq.nextval,lastName,email from(" close=")"&gt; select #&#123;emp.lastName&#125; lastName,#&#123;emp.email&#125; email from dual &lt;/foreach&gt; &lt;/insert&gt; _parameter || _databaseId || bind12345678910111213141516171819202122232425262728&lt;!-- 两个内置参数： 不只是方法传递过来的参数可以被用来判断，取值。。。 mybatis默认还有两个内置参数： _parameter:代表整个参数 单个参数：_parameter就是这个参数 多个参数：参数会被封装为一个map；_parameter就是代表这个map _databaseId:如果配置了databaseIdProvider标签。 _databaseId就是代表当前数据库的别名oracle--&gt;select id="getEmpdatabaseId" resultMap="mydifMap"&gt; &lt;!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值 --&gt; &lt;!-- &lt;bind name="_lastName" value="'%'+lastName+'%'"/&gt; --&gt; &lt;if test="_databaseId == 'mysql'"&gt; select id, last_name, email, gender, dept_id did from tbl_employee &lt;if test="_parameter!=null"&gt; where id = #&#123;_parameter.id&#125; &lt;!-- where last_name = #&#123;_lastName&#125; -&gt; &lt;/if&gt; &lt;/if&gt; &lt;if test="_databaseId == 'oracle'"&gt; select id, last_name, email, gender, dept_id did from tbl_employee &lt;if test="_parameter!=null"&gt; where id = #&#123;_parameter.id&#125; &lt;/if&gt; &lt;/if&gt; &lt;/select&gt; sql 标签 12345678910111213141516171819202122抽取可重用的sql片段。方便后面引用 1、sql抽取：经常将要查询的列名，或者插入用的列名抽取出来方便引用 2、include来引用已经抽取的sql： 3、include还可以自定义一些property，sql标签内部就能使用自定义的属性 include-property：取值的正确方式$&#123;prop&#125;, #&#123;不能使用这种方式&#125; &lt;sql id="selectColumn"&gt; &lt;if test="_databaseId == 'mysql'"&gt; id, last_name, email, gender,$&#123;dept_id&#125; &lt;/if&gt; &lt;/sql&gt; &lt;select id="getEmpdatabaseId" resultMap="mydifMap"&gt; &lt;if test="_databaseId == 'mysql'"&gt; select dept_id did &lt;include refid="selectColumn"&gt; &lt;property name="dept_id" value="did"/&gt; &lt;/include&gt; from tbl_employee &lt;/if&gt; &lt;/select&gt; mybaties 缓存机制 两级缓存： 一级缓存：（本地缓存）：sqlSession级别的缓存。一级缓存是一直开启的；SqlSession级别的一个Map 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库； 一级缓存失效情况（没有使用到当前一级缓存的情况，效果就是，还需要再向数据库发出查询）： 1、sqlSession不同。 2、sqlSession相同，查询条件不同.(当前一级缓存中还没有这个数据) 3、sqlSession相同，两次查询之间执行了增删改操作(这次增删改可能对当前数据有影响) 4、sqlSession相同，手动清除了一级缓存（缓存清空） 二级缓存：（全局缓存）：基于namespace级别的缓存：一个namespace对应一个二级缓存： 工作机制： 1、一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中； 2、如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容； 3、sqlSession===EmployeeMapper==&gt;Employee DepartmentMapper===&gt;Department 不同namespace查出的数据会放在自己对应的缓存中（map） 效果：数据会从二级缓存中获取 查出的数据都会被默认先放在一级缓存中。 只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中 使用： 1）、开启全局二级缓存配置： 2）、去mapper.xml中配置使用二级缓存： 3）、我们的POJO需要实现序列化接口 和缓存有关的设置/属性： 1）、cacheEnabled=true：false：关闭缓存（二级缓存关闭）(一级缓存一直可用的) 2）、每个select标签都有useCache=”true”： false：不使用缓存（一级缓存依然使用，二级缓存不使用） 3）、【每个增删改标签的：flushCache=”true”：（一级二级都会清除）】 增删改执行完成后就会清楚缓存； 测试：flushCache=”true”：一级缓存就清空了；二级也会被清除； 查询标签：flushCache=”false”： 如果flushCache=true;每次查询之后都会清空缓存；缓存是没有被使用的； 4）、sqlSession.clearCache();只是清楚当前session的一级缓存； 5）、localCacheScope：本地缓存作用域：（一级缓存SESSION）；当前会话的所有数据保存在会话缓存中； STATEMENT：可以禁用一级缓存； 第三方缓存整合： 1）、导入第三方缓存包即可； mybatis-ehcache-1.0.3.jar, slf4j-api-1.6.1.jar, slf4j-log4j12-1.6.2.jar 2）、导入与第三方缓存整合的适配包；官方有； 3）、mapper.xml中使用自定义缓存 &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt; 1234567891011121314151617181920&lt;!-- &lt;cache eviction="FIFO" flushInterval="60000" readOnly="false" size="1024"&gt;&lt;/cache&gt; --&gt;&lt;!-- eviction:缓存的回收策略： • LRU – 最近最少使用的：移除最长时间不被使用的对象。 • FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 • SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 • WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 • 默认的是 LRU。flushInterval：缓存刷新间隔 缓存多长时间清空一次，默认不清空，设置一个毫秒值readOnly:是否只读： true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快 false：非只读：mybatis觉得获取的数据可能会被修改。 mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢size：缓存存放多少元素；type=""：指定自定义缓存的全类名； 实现Cache接口即可；--&gt; ssm 整合：web 配置： 1.spring mvc 2.spring IoC 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;MyBatis_06_ssm&lt;/display-name&gt; &lt;!--Spring配置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- SpringMVC配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; springmvc 配置： 1. 扫描控制器 2. 视图解析器 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!--SpringMVC只是控制网站跳转逻辑 --&gt; &lt;!-- 只扫描控制器 --&gt; &lt;context:component-scan base-package="com.atguigu.mybatis" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; mybaties 配置： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;setting name="jdbcTypeForNull" value="NULL"/&gt; &lt;!--显式的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings&gt; &lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MySQL" value="mysql"/&gt; &lt;property name="Oracle" value="oracle"/&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;/databaseIdProvider&gt; &lt;/configuration&gt; spring 配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- Spring希望管理所有的业务逻辑组件，等。。。 --&gt; &lt;context:component-scan base-package="com.atguigu.mybatis"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- 引入数据库的配置文件 --&gt; &lt;context:property-placeholder location="classpath:dbconfig.properties" /&gt; &lt;!-- Spring用来控制业务逻辑。数据源、事务控制、aop --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring事务管理 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启基于注解的事务 --&gt; &lt;tx:annotation-driven transaction-manager="dataSourceTransactionManager"/&gt; &lt;!-- 整合mybatis 目的：1、spring管理所有组件。mapper的实现类。 service==&gt;Dao @Autowired:自动注入mapper； 2、spring用来管理事务，spring声明式事务 --&gt; &lt;!--创建出SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- configLocation指定全局配置文件的位置 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!--mapperLocations: 指定mapper文件的位置--&gt; &lt;property name="mapperLocations" value="classpath:mybatis/mapper/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置一个可以进行批量执行的sqlSession --&gt; &lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactoryBean"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="executorType" value="BATCH"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 扫描所有的mapper接口的实现，让这些mapper能够自动注入； base-package：指定mapper接口的包名 --&gt; &lt;mybatis-spring:scan base-package="com.atguigu.mybatis.dao"/&gt; &lt;!-- &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.atguigu.mybatis.dao"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;/beans&gt; dbconfig.properties: 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=truejdbc.username=rootjdbc.password=123456 测试 mybaties 逆向工程jar包: mybatis-generator-core-1.3.2.jar 编写 mbg 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime="MyBatis3Simple":生成简单版的CRUD MyBatis3:豪华版 --&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;!-- --&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator：指定javaBean的生成策略 targetPackage="test.model"：目标包名 targetProject="\MBGTestProject\src"：目标工程 --&gt; &lt;javaModelGenerator targetPackage="com.aqqje.mybatis.bean" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator：sql映射生成策略： --&gt; &lt;sqlMapGenerator targetPackage="com.aqqje.mybatis.dao" targetProject=".\conf"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.aqqje.mybatis.dao" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表：根据表要创建javaBean --&gt; &lt;table tableName="tbl_dept" domainObjectName="Department"&gt;&lt;/table&gt; &lt;table tableName="tbl_employee" domainObjectName="Employee"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;``` - 测试：```javapackage com.aqqje.mybatis.test;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import com.aqqje.mybatis.bean.Employee;import com.aqqje.mybatis.bean.EmployeeExample;import com.aqqje.mybatis.bean.EmployeeExample.Criteria;import com.aqqje.mybatis.dao.EmployeeMapper;/*import com.aqqje.mybatis.bean.Employee;import com.aqqje.mybatis.dao.EmployeeMapper;*/public class MyBatisTest &#123; public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = "mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testMbg() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("mbg.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; @Test public void testMyBatis3Simple() throws IOException&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try&#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); List&lt;Employee&gt; list = mapper.selectByExample(null); for (Employee employee : list) &#123; System.out.println(employee.getId()); &#125; &#125;finally&#123; openSession.close(); &#125; &#125; @Test public void testMyBatis3() throws IOException&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try&#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); //xxxExample就是封装查询条件的 //1、查询所有 //List&lt;Employee&gt; emps = mapper.selectByExample(null); //2、查询员工名字中有e字母的，和员工性别是1的 //封装员工查询条件的example EmployeeExample example = new EmployeeExample(); //创建一个Criteria，这个Criteria就是拼装查询条件 //select id, last_name, email, gender, d_id from tbl_employee //WHERE ( last_name like ? and gender = ? ) or email like "%e%" Criteria criteria = example.createCriteria(); criteria.andLastNameLike("%e%"); criteria.andGenderEqualTo("1"); Criteria criteria2 = example.createCriteria(); criteria2.andEmailLike("%e%"); example.or(criteria2); List&lt;Employee&gt; list = mapper.selectByExample(example); for (Employee employee : list) &#123; System.out.println(employee.getId()); &#125; &#125;finally&#123; openSession.close(); &#125; &#125;&#125; pageHepler官网详解：pageHepler pageHepler]]></content>
      <tags>
        <tag>mybaties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[ABCCC_VPN]]></title>
    <url>%2F2018%2F05%2F28%2FABCCC-VPN%2F</url>
    <content type="text"><![CDATA[新的一个VPN工具！ 网址：www.abccc.me 流程注册—下载包—配置设置！]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc]]></title>
    <url>%2F2018%2F05%2F12%2Fspringmvc%2F</url>
    <content type="text"><![CDATA[spring MVC 学习笔记 HelloWorld 配置 web.xml 配置 DispatcherServlet:DispatcherServlet 默认加载 /WEBINF/.xml 的 Spring 配置文件,启动 WEB 层的 Spring 容器 可以通过 contextConfigLocation 初始化参数自定义配置文件的位置和名称 123456789101112131415161718&lt;!--2、springmvc的前端控制器，拦截所有请求 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 使用默认值时可以省略不写 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation 固定参数 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcherServlet-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 创建 Spring MVC 配置文件 dispatcherServlet-servlet.xml 配置自动扫描的包 配置视图解析器12345678 &lt;!--SpringMVC的配置文件，包含网站跳转逻辑的控制，配置 --&gt;&lt;context:component-scan base-package="com.aqqje"&gt;&lt;!--配置视图解析器，方便页面返回 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt; 创建请求处理器类 123456789@Controllerpublic class HelloWord&#123; @RequestMapping("/hellowSpringMVC") public String helloworld()&#123; System.out.println("helloworld..."); return "success"; &#125;&#125; 创建 index.jsp –&gt; HelloWord @RequestMapping 映射请求 注解位置： 1.类定义处：提供初步的请求映射信息。相对于 WEB 应用的根目录 2.方法处：提供进一步的细分映射信息。相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录 @RequestMapping 参数 value:请求 URL –&gt; 注解位置 method:请求方法 PUT GET DELETE POST params:请求参数– param1: 表示请求必须包含名为 param1 的请求参数– !param1: 表示请求不能包含名为 param1 的请求参数– param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1– {“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2的两个请求参数，且 param1 参数的值必须为 value1 heads:请求头的映射条件[支持同 params 参数的简单表达式] 1234567@RequestMapping(value = "testParamsAndHeaders", params = &#123; "username", "age!=10" &#125;, headers = &#123; "Accept-Language=en-US,zh;q=0.8" &#125;) public String testParamsAndHeaders() &#123; System.out.println("testParamsAndHeaders"); return SUCCESS; &#125; Ant 风格资源地址支持 3 种匹配符– ?：匹配文件名中的一个字符– *：匹配文件名中的任意字符– ： 匹配多层路径 Ant 风格的 URL – /user/*/createUser: 匹配/user/aaa/createUser、/user/bbb/createUser 等 URL– /user/**/createUser: 匹配/user/createUser、/user/aaa/bbb/createUser 等 URL– /user/createUser??: 匹配/user/createUseraa、/user/createUserbb 等 URL @PathVariable 映射 URL 绑定的占位符 @PathVariable 可以来映射 URL 中的占位符到目标方法的参数中. 12345@RequestMapping("/testPathVariable/&#123;id&#125;")public String testPathVariable(@PathVariable("id") Integer id) &#123; System.out.println("testPathVariable: " + id); return SUCCESS;&#125; REST (Representational State Transfer)表现层状态转化 具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 1234/order/1 HTTP GET ：得到 id = 1 的 order /order/1 HTTP DELETE：删除 id = 1的 order /order/1 HTTP PUT：更新id = 1的 order /order HTTP POST：新增 order 使用 REST 与 HiddenHttpMethodFilter 过滤器共同使用 1234567891011121314151617&lt;!-- 4、使用Rest风格的URI，将页面普通的post请求转为指定的delete或者put请求 --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;HttpPutFormContentFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HttpPutFormContentFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HttpPutFormContentFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; @RequestParam 绑定请求参数值 使用 @RequestParam 可以把请求参数传递给请求方法– value：参数名– required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常 12345678@RequestMapping(value = "/testRequestParam")public String testRequestParam( @RequestParam(value = "username") String un, @RequestParam(value = "age", required = false, defaultValue = "0") int age) &#123; System.out.println("testRequestParam, username: " + un + ", age: " + age); return SUCCESS;&#125; @RequestHeader 绑定请求报头的属性值123456@RequestMapping("/testRequestHeader")public String testRequestHeader( @RequestHeader(value = "Accept-Language") String al) &#123; System.out.println("testRequestHeader, Accept-Language: " + al); return SUCCESS;&#125; @CookieValue 绑定请求中的 Cookie 值12345@RequestMapping("/testCookieValue")public String testCookieValue(@CookieValue("JSESSIONID") String sessionId) &#123; System.out.println("testCookieValue: sessionId: " + sessionId); return SUCCESS;&#125; POJO 对象绑定请求参数值 Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如：dept.deptId、dept.address.tel 等 123456789101112131415161718192021222324252627282930/** * 1. 有 @ModelAttribute 标记的方法, 会在每个目标方法执行之前被 SpringMVC 调用! * 2. @ModelAttribute 注解也可以来修饰目标方法 POJO 类型的入参, 其 value 属性值有如下的作用: * 1). SpringMVC 会使用 value 属性值在 implicitModel 中查找对应的对象, 若存在则会直接传入到目标方法的入参中. * 2). SpringMVC 会一 value 为 key, POJO 类型的对象为 value, 存入到 request 中. */@ModelAttributepublic void getUser(@RequestParam(value="id",required=false) Integer id, Map&lt;String, Object&gt; map)&#123; System.out.println("modelAttribute method"); if(id != null)&#123; //模拟从数据库中获取对象 User user = new User(1, "Tom", "123456", "tom@atguigu.com", 12); System.out.println("从数据库中获取一个对象: " + user); map.put("user", user); &#125;&#125;/** 运行流程: * 1. 执行 @ModelAttribute 注解修饰的方法: 从数据库中取出对象, 把对象放入到了 Map 中. 键为: user * 2. SpringMVC 从 Map 中取出 User 对象, 并把表单的请求参数赋给该 User 对象的对应属性. * 3. SpringMVC 把上述对象传入目标方法的参数. * * 注意: 在 @ModelAttribute 修饰的方法中, 放入到 Map 时的键需要和目标方法入参类型的第一个字母小写的字符串一致! */@RequestMapping("/testModelAttribute")public String testModelAttribute(@ModelAttribute("user") User user)&#123; return SUCCESS;&#125; ModelAndView 既包含视图信息，也包含模型数据信息。 添加模型数据:– MoelAndView addObject(String attributeName, ObjectattributeValue)– ModelAndView addAllObject(Map&lt;String, ?&gt; modelMap) 设置视图:– void setView(View view)– void setViewName(String viewName) Map 及 Model12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@ModelAttribute("user")public User getUser()&#123; User user = new User(); user.setAge(10); return user;&#125;email: $&#123;requestScope.user.email&#125;@RequestMapping("/handle")public String handle(Map&lt;String, Object&gt; map)&#123; map.put("time", new Date()); User user = (User)map.get("user") user.setEmail("aqqje@123.com"); return "success";&#125;time: $&#123;requestScope.time&#125;## @SessionAttributes- @SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外(实际上使用的是 value 属性值),还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中(实际上使用的是 types 属性值) - 注意: 该注解只能放在类的上面. 而不能修饰放方法. - 避免@SessionAttributes引发的异常```java@SessionAttributes("user")@Controllerpublic class UserController&#123; // 该 方法会往隐含模型中添加一个名为 user 的模型属性 @ModelAttribute("user") public User getUser()&#123; User user = new User(); return user; &#125;&#125;## 希望直接响应通过 SpringMVC 渲染的页面，可以使用 mvc:viewcontroller 标签实现```xml &lt;!-- 配置直接转发的页面 --&gt; &lt;!-- 可以直接相应转发的页面, 而无需再经过 Handler 的方法. --&gt; &lt;mvc:view-controller path="/success" view-name="success"/&gt; 配置国际化资源文件123456789i18n.username=Usernamei18n.password=Password&lt;!-- 配置国际化资源文件 --&gt; &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt; &lt;property name="basename" value="i18n"&gt;&lt;/property&gt; &lt;/bean&gt; 重定向 forward: 或 redirect:– redirect:success.jsp：会完成一个到 success.jsp 的重定向的操作– forward:success.jsp：会完成一个到 success.jsp 的转发操作 处理静态资源可以在 SpringMVC 的配置文件中配置 mvc:default-servlethandler/ 的方式解决静态资源的问题 12345678方法一： &lt;!-- 配置静态资源的请求映射关系 --&gt; &lt;mvc:resources location="/resources/" mapping="/resources/**"&gt;&lt;/mvc:resources&gt;方法二：&lt;!-- 将springmvc不能处理的请求交给tomcat --&gt;&lt;mvc:default-servlet-handler/&gt; 处理 JSON 1加入 jar 包 jackson-annotation-x.x.x.jar jackson-core-x.x.x.jar jackson-databind-2.2.2.jar 2编写目标方法，使其返回 JSON 对应的对象或集合 3在方法上添加 @ResponseBody 注解 字符集编码的过滤器(必须放在所有过渡器之前) 1234567891011121314151617&lt;!-- 字符集编码的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 文件上传 配置 MultipartResolver 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788Controller: //执行新增动作 @RequestMapping(value="/code", method=RequestMethod.POST) public ModelAndView add(@RequestParam("codefile") MultipartFile codefile, @RequestParam("intro") String intro, HttpServletRequest request, HttpSession session)&#123; ModelAndView mv = new ModelAndView(); User loginUser = (User)session.getAttribute("loginUser"); String path = request.getServletContext().getRealPath("/") + "resources\\codefile\\"; CodeService codeService = new CodeService(); Map&lt;String, Object&gt; result = codeService.addCode(codefile, path, loginUser, intro); Boolean isSuccess = (Boolean)result.get("isSuccess"); String message = (String)result.get("message"); if(isSuccess)&#123; mv.setViewName("redirect:/codes"); &#125;else&#123; mv.setViewName("bizzerror"); mv.addObject("message", message); &#125; return mv; &#125; service: public Map&lt;String, Object&gt; addCode(MultipartFile codefile, String path, User loginUser, String intro) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); //文件上传和新增代码的业务逻辑 //将文件存到服务器的指定位置 //1. 路径存在性 //2. 文件名重复的问题 try &#123; if(codefile.getSize() &gt; 0)&#123; String filename = generateFilename(codefile.getOriginalFilename()); if(filename.endsWith(".zip") || filename.endsWith(".rar"))&#123; File file = new File(path, filename); if(!file.getParentFile().exists())&#123; file.getParentFile().mkdir(); &#125; //将上传的文件保存在服务器上的指定目录 codefile.transferTo(file); //向数据库插入一条新的Code数据 //(id=null, codename="codefile.getname()", // filepath="文件存放好之后的位置", // intro=输入的intro // owner="当前登录用户", // addTime="当前系统时间") Code code = new Code(); code.setCodename(codefile.getOriginalFilename()); code.setFilepath("resources/codefile/" + filename ); code.setIntro(intro); code.setOwner(loginUser); code.setAddTime(new Timestamp(System.currentTimeMillis())); CodeDao codeDao = new CodeDao(); codeDao.add(code); result.put("isSuccess", true); result.put("message", "上传成功！"); &#125;else&#123; //类型错误，报错 result.put("isSuccess", false); result.put("message", "必须上传.zip或者.rar文件"); &#125; &#125;else&#123; //空文件，报错 result.put("isSuccess", false); result.put("message", "文件不可为空"); &#125; return result; &#125; catch (Exception e) &#123; e.printStackTrace(); result.put("isSuccess", false); result.put("message", "上传失败"); return result; &#125; &#125; 拦截器 自定义的拦截器必须实现HandlerInterceptor接口 – preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。 如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true； 如果程序员决定不需要再调用其他的组件去处理请求，则返回false。 – postHandle()：这个方法在业务处理器处理完请求后， 但是DispatcherServlet 向客户端返回响应前被调用， 在该方法中对用户请求request进行处理。 – afterCompletion()：这个方法在 DispatcherServlet 完全处理完请求后被调用， 可以在该方法中进行一些资源清理的操作。 springmvc 配置文件中配置自定义的拦截器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950java:/** * 登录检查拦截器 * @author Administrator * */public class LoginInterceptor extends HandlerInterceptorAdapter&#123; public static List&lt;String&gt; URLS = null; static&#123; URLS = new ArrayList&lt;String&gt;(); URLS.add("/codes"); URLS.add("/admin"); URLS.add("/code"); &#125; /** * 执行请求之前进行拦截 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String url = request.getServletPath(); String method = request.getMethod(); if(method.equalsIgnoreCase("GET") &amp;&amp; URLS.contains(url))&#123; if(request.getSession().getAttribute("loginUser") == null)&#123; //未登录状态 //重定向到未登录错误页面 response.sendRedirect("not_login"); return false; &#125;else&#123; //已登录 return true; &#125; &#125;else&#123; return true; &#125; &#125; &#125;xml: &lt;!-- 配置拦截列表 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 配置单个拦截器 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/*"/&gt; &lt;bean id="loginInterceptor" class="com.javaee.scms.interceptors.LoginInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; 异常处理 Spring MVC 通过 HandlerExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常。 -SpringMVC 提供的 HandlerExceptionResolver 的实现类 12345678910111213141516171819202122232425262728293031 public class ExceptionHandler implements HandlerExceptionResolver&#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception) &#123; ModelAndView mv = new ModelAndView(); if(exception instanceof SystemException)&#123; StringBuilder message = new StringBuilder(); message.append("&lt;p&gt;" + exception.getCause().getMessage() + "&lt;/p&gt;"); message.append("&lt;p&gt;请您与管理员联系，您也可以返回&lt;a href='" + request.getContextPath() + "/home'&gt;首页&lt;/a&gt;&lt;/p&gt;"); mv.addObject("message", message.toString()); mv.setViewName("syserror"); &#125;if(exception instanceof BizzException)&#123; StringBuilder message = new StringBuilder(); message.append("&lt;p&gt;" + exception.getMessage() + "&lt;/p&gt;"); message.append("&lt;p&gt;请您与管理员联系，您也可以返回&lt;a href='" + request.getContextPath() + "/home'&gt;首页&lt;/a&gt;&lt;/p&gt;"); mv.addObject("message", message.toString()); mv.setViewName("bizzerror"); &#125;else&#123; StringBuilder message = new StringBuilder(); message.append("&lt;p&gt;发生了未知的异常&lt;/p&gt;"); message.append("&lt;p&gt;请您与管理员联系，您也可以返回&lt;a href='" + request.getContextPath() + "/home'&gt;首页&lt;/a&gt;&lt;/p&gt;"); mv.addObject("message", message.toString()); mv.setViewName("syserror"); &#125; return mv; &#125;&#125;]]></content>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring learn]]></title>
    <url>%2F2018%2F05%2F07%2Fspring-learn%2F</url>
    <content type="text"><![CDATA[Spring Learn Note Spring 是什么简单描述： Spring 是一个开源框架.= Spring 为简化企业级应用开发而生. 使用 Spring 可以使简单的 JavaBean 实现以前只有 EJB 才能实现的功能. Spring 是一个 IOC(DI) 和 AOP 容器框架. 具体描述 Spring: 轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API 依赖注入(DI — dependency injection、IOC)= 面向切面编程(AOP — aspect oriented programming)= 容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期= 框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC） Spring HelloWord 创建 javaBean 类 123456789101112public class HelloWord &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public void hello() &#123; System.out.println("Hello:" + name); &#125;&#125; 新建 Spring IoC 容器 applicationContext.xml,并配置相应的 Bean 123&lt;bean id="helloWord" class="aqqje.com.beans.HelloWord"&gt; &lt;property name="name" value="aqqje" /&gt;&lt;/bean&gt; 编写测试类 1234567891011// 创建 spring IoC 的容器对象ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");// 从容器中获取 bean// 利用 id 定位容器中的 bean 推荐使用HelloWord hw = (HelloWord)context.getBean("helloWord");// 调用 hello()// 利用 id 定位容器中的 bean 推荐使用//HelloWord hw = (HelloWord)context.getBean("helloWord");// 利用 类型返回容器中的 bean 要求：容器只一个该类型的 bean//HelloWord hw = (HelloWord)context.getBean(HelloWord.class);hw.hello(); Spring IoC 容器 Bean 的配置 id : Bean 的名字 在 IOC 容器中必须是唯一的 若 id 没有指定，Spring 自动将权限定性类名作为 Bean 的名字 id 可以指定多个名字，名字之间可用逗号、分号、或空格分隔 class: Bean 本身的类名 1.必须为全类名 ref: 指向引用 Bean 的名字 1.可以引用外部的 Bean 2.可以创建内部 Bean 3.内部创建的 Bean 只能内部使用, 不能其他外部 Bean 引用 123456789101112&lt;property name="persion"&gt; &amp;lt;!&amp;ndash; 内部Bean, 注意：不能被外部 Bean 引用, 只能在内部使用 &amp;ndash;&amp;gt; &lt;bean class="aqqje.com.beans.Persion"&gt; &lt;constructor-arg value="aqqje" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;男&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="double"&gt; &lt;value&gt;20000.0&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/property&gt; : 构造器注入 1. value 属性为 bean 的构造器的实参值，为值的内容字符形式 2. 定位(index=&quot;0&quot; 或 type=&quot;aqqje.com.beans.Persion&quot; 两者可以混用) ,即指定 value 的类型 字面值：可用字符串表示的值 1.可以使用 &lt;value&gt; 元素标签 或 value 属性进行注入 2.基本数据类型及其封装类, Stirng 等类型都可以采取字面值注入的方式 3.若字面值包含特殊字符，可以使用&lt;![CDATA[]]&gt;把字面值包裹 123456789101112131415&lt;bean id="persion2" class="aqqje.com.beans.Persion"&gt; &lt;constructor-arg value="aqqje" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;男&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="double"&gt; &lt;value&gt;500.0&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;``` - &lt;null/&gt; : 可以使用专用的 &lt;null/&gt; 元素标签为 Bean 的字符串或其它对象类型的属性注入null 值```xml&lt;property name="persion"&gt;&lt;null/&gt;&lt;/property&gt; 级联：spring 支持级联属性: 级联属性赋值 注意：属性需要先初始化，才能级联属性赋值, 否则将抛出异常 1&lt;property name="persion.name" value="love" /&gt; 集合属性 ：List &amp;&amp; Set || Map 1.使用 list 节点为 List 类型属性赋值 123456789&lt;property name="persion"&gt; &lt;!-- Set 类型类似 List --&gt; &lt;list&gt; &lt;ref bean="persion1"/&gt; &lt;ref bean="persion2"/&gt; &lt;/list&gt;&lt;/property&gt; 2.使用 map 节点及 map中的 entry 节点配置 Map 属性的成员变量 123456&lt;property name="persion"&gt; &lt;map&gt; &lt;entry key="aa" value-ref="persion1" /&gt; &lt;entry key="bb" value-ref="persion2" /&gt; &lt;/map&gt;&lt;/property&gt; properties 属性: 1234user=rootpassword=rootdriverClass=com.mysql.jdbc.DriverjdbcUrl=jdbc:mysql:///scms 1234567891011&lt;bean id="dataSource" class="aqqje.com.beans.contollers.DataSource"&gt; &lt;property name="properties"&gt; &lt;!-- 使用 props 和 prop 配置 properties 文件 --&gt; &lt;props&gt; &lt;prop key="driverClass"&gt;com.jdbc.mysql.Driver&lt;/prop&gt; &lt;prop key="jdbcUrl"&gt;jdbc.mysql:///test&lt;/prop&gt; &lt;prop key="user"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 配置单例集合 Bean : util命名空间 以便多个 Bean 引用 : 注意：需要导入 util jar包 123456&lt;util:list id="persions"&gt; &lt;ref bean="persion1" /&gt; &lt;ref bean="persion2" /&gt;&lt;/util:list&gt;&lt;!-- 引用单例集合 Bean --&gt;&lt;property name="persion" ref="persions"/&gt; p 命名空间：可以使用 p 命名空间对 Bean 的属性进行赋值 注意：需要导入 p jar包 ;特点：比较传统的方式更简洁 1&lt;bean id="god5" class="aqqje.com.beans.contollers.God" p:name="Aellen" p:leg="5" p:persion-ref="persions" /&gt; spring Bean 之间的关系 继承：1.1)Bean(子Bean) 可以使用 parent 属性来继承父类的 Bean(父Bean) 1.2)Bean(子Bean) 可以覆盖 Bean(父Bean) 的属性 抽象：2.1)Bean(父Bean) 可以使用 abstract 属性来定义该 Bean 为抽象Bean, 2.2)若一个 Bean 没有指定 Class 属性, 则该 Bean 必须是一个抽象 Bean 2.3)抽象 Bean 的 class 属性可以省略, 如省略 Bean(子Bean) 则必须指定 class 属性,如不省略，Bean(子Bean)则可以省略不指定 2.4)注意：抽象 Bean 不可以被 IoC 容器所实例化 3.依赖：1.1)使用 depends-on 属性指定该 Bean 需要 依赖的 Bean , 被依赖的 Bean 必须要存在(不分先后), 否则将抛出异常 1.2)单单指定 depens-on 属性是不行的, 必须与 p: ref 共同使用 1.3)如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称 1.4)前置依赖的 Bean 会在本 Bean 实例化之前创建好 123456&lt;bean id="adress" class="aqqje.com.relation.Adress" p:city="HuNan" p:street="HengYang" abstract="true"/&gt;&lt;!-- &lt;bean id="adress1" class="aqqje.com.relation.Adress" p:city="HuNan" p:street="XiangTang"/&gt;--&gt;&lt;bean id="adress1" p:city="HuNan" p:street="XiangTang" parent="adress"/&gt;&lt;bean id="persion" class="aqqje.com.relation.Persion" p:name="aqqje" p:car-ref="car" depends-on="car" /&gt;&lt;bean id="car" class="aqqje.com.relation.Car" p:brank="China" p:pirce="6100000" /&gt; spring Bean 作用域: 使用 scope 属性里设置 Bean 的作用域 singleton(单例): 默认值, 在 IoC 容器创建时该 Bean 就被实例化了, 整个 IoC 容器范围内都能共享该 Bean , 生命周期与 IoC 一样长. prototype(原型): 在 IoC 容器创建时该 Bean 不会被实例化, 一到需要使用时调用 getBean() 方法就会实例化一个该 Bean 的对象. request(请求): 每次 Http 请求都会实例化一个 Bean 对象, 该作用仅使用于 WebApplicationContext 环境 session(会议): 同一个 Http session 共享一个 bean , 不同的 Http session 使用不同的 bean, 该作用仅使用于 WebApplicationContext 环境 1&lt;bean id="car" class="aqqje.com.relation.Car" p:brank="Chian" p:pirce="61000.0" scope="prototype" /&gt; Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于 EL：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL SpEL 为 bean 的属性进行动态赋值提供了便利 通过 SpEL 可以实现： 通过 bean 的 id 对 bean 进行引用 调用方法以及引用对象中的属性 计算表达式的值 正则表达式的匹配 字面量的表示： 整数：&lt;property name=&quot;count&quot; value=&quot;#{5}&quot;/&gt; 小数：&lt;property name=&quot;frequency&quot; value=&quot;#{89.7}&quot;/&gt; 科学计数法：&lt;property name=&quot;capacity&quot; value=&quot;#{1e4}&quot;/&gt; String可以使用单引号或者双引号作为字符串的定界符号：&lt;property name=“name” value=&quot;#{&apos;Chuck&apos;}&quot;/&gt; 或 &lt;property name=&apos;name&apos; value=&apos;#{&quot;Chuck&quot;}&apos;/&gt; Boolean：&lt;property name=&quot;enabled&quot; value=&quot;#{false}&quot;/&gt; 引用其他对象 &amp;&amp; 引用其他对象的属性 &amp;&amp; 调用其他方法,还可以链式操作 $$ 支持运算符 &amp;lt;!&amp;ndash; 通过 value 属性和 SpEL 之间的应用关系 &amp;ndash;&amp;gt; &lt;bean id=&quot;persion&quot; class=&quot;aqqje.com.spel.Persion&quot; p:name=&quot;#{car.brank}&quot; p:car=&quot;#{car}&quot; p:adress=&quot;#{adress.city}&quot; p:wage=&quot;#{car.pirce &gt; 3000 ? &apos;金领&apos; : &apos;白领&apos;}&quot; /&gt; 支持运算符： 算数运算符：+, -, *, /, %, ^： 加号还可以用作字符串连接： 比较运算符： &lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge 逻辑运算符号： and, or, not, | if-else 运算符：?: (ternary), ?: (Elvis) if-else 的变体 正则表达式：matches 123&lt;bean id="adress" class="aqqje.com.spel.Adress" p:city="#&#123;'HuNan'&#125;" p:street="softSchool" /&gt;&lt;bean id="car" class="aqqje.com.spel.Car" p:brank="#&#123;'Chinal'&#125;" p:pirce="2000" p:tirecCircumference="#&#123;T(java.lang.Math).PI * 25&#125;" /&gt;&lt;bean id="persion" class="aqqje.com.spel.Persion" p:name="#&#123;car.brank&#125;" p:car="#&#123;car&#125;" p:adress="#&#123;adress.city&#125;" p:wage="#&#123;car.pirce &gt; 3000 ? '金领' : '白领'&#125;" /&gt; IoC 容器中 Bean 的周期： 作用： Spring IOC 容器可以管理 Bean 的生命周期, Spring 允许在 Bean 生命周期的特定点执行定制的任务. 初始 &amp;&amp; 销毁 在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法. Bean 的周期过程： 1.通过构造器或工厂方法创建 Bean 实例 2.为 Bean 的属性设置值和对其他 Bean 的引用 3.调用 Bean 的初始化方法 4.Bean 可以使用了 5.当容器关闭时, 调用 Bean 的销毁方法 Bean 后置处理器： 作用： 1.在调用初始化方法前后对 Bean 进行额外的处理. 2.Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性. 实现: 1.自定义 Bean 后置处理器并实现 BeanPostProcessor 接口 2.初始化方法被调用前后，重写 postProcessAfterInitialixation(...) &amp;&amp; postProcessBeforeInitialixation(...)方法 3.在 spring IoC 容器中配置Bean 后置处理器 添加 Bean 后置处理器中 Bean 的周期过程： 1.通过构造器或工厂方法创建 Bean 实例 2.为 Bean 的属性设置值和对其他 Bean 的引用 3.*将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法* 4.调用 Bean 的初始化方法 5.*将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法* 6.Bean 可以使用了 7.当容器关闭时, 调用 Bean 的销毁方法 12345678// car initpublic void init() &#123; System.out.println("Car init..");&#125;// car destroypublic void destroy() &#123; System.out.println("Car destroy....");&#125; 12345678910111213141516// Bean 后置处理器public class MyPostProcessor implements BeanPostProcessor &#123;@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessBeforeInitialization:" + bean + "," + beanName); return bean;&#125;@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessBeforeInitialization:" + bean + "," + beanName); Car car = new Car(); car.setName("aqqje"); return car;&#125; 1234567891011&lt;bean id="car" class="aqqje.com.lifecycle.Car" p:name="BMWX6" p:price="10000000" init-method="init" destroy-method="destroy"/&gt;&lt;!-- bean : bean 实例本身 beanName: IoC容器配置 的bean 的名字 返回值： 是实际上返回给用户的那个 Bean, 注意：可以在以上两方法中修改返回的 bean, 甚至返回一个新的 bean 配置 bean 的后置处理器： 不需要配置 id , IoC 容器自动识别一个 BeanPostProcessor --&gt;&lt;bean class="aqqje.com.lifecycle.MyPostProcessor" /&gt; 工厂方法创建 Bean 1) 静态工厂方法:直接调用某一个类的静态方法就可以返回一个 bean 实例 12345678910111213public class StaticFactory &#123; private static Map&lt;String, Object&gt; cars = new HashMap&lt;&gt;(); static&#123; cars.put("audi", new Car("adui", 100000)); cars.put("ford", new Car("ford", 400000)); &#125; public static Car getCar(String carName)&#123; return (Car)cars.get(carName); &#125;&#125;` 12345678910&lt;!-- 通过静态工厂方法来配置 bean， 注意不是配置静态工厂实例，而是配置 bean 实例 class 属性：指向静态工厂方法的全类名 factory-method: 指向静态工厂方法的名字 constructor-arg: 如果工厂方法需要传入参数，则使用 constructor-arg 来配置参数 --&gt;&lt;bean id="car" class="aqqje.com.factory.StaticFactory" factory-method="getCar"&gt; &lt;constructor-arg value="ford"/&gt;&lt;/bean&gt; 2) 实例工厂方法: 12345678910111213public class InstaceFactory &#123; private Map&lt;String, Object&gt; cars; public InstaceFactory()&#123; cars = new HashMap&lt;&gt;(); cars.put("audi", new Car("adui", 100000)); cars.put("ford", new Car("ford", 400000)); &#125; public Car getCar(String CarName)&#123; return (Car)cars.get(CarName); &#125;&#125; 1234567891011&lt;!-- factory-bean ：指向实例工厂方法的全类名 factory-method: 指向实例工厂方法的名字 constructor-arg: 如果工厂方法需要传入参数，则使用 constructor-arg 来配置参数 --&gt;&lt;bean id="instaceFactory" class="aqqje.com.factory.InstaceFactory" /&gt;&lt;bean id="car1" factory-bean="instaceFactory" factory-method="getCar"&gt; &lt;constructor-arg value="audi"/&gt;&lt;/bean&gt; 组件装配 context:component-scan 自动注册 AutowiredAnnotationBeanPostProcessor 实例 可以使用 autuwire 属性指定自行装配的方式（不推荐） byName: 根据 bean 的名字和当前 Bean 的 setter 风格的属性名进行自动装配，若有匹配的，则进行自行装配， 若没有就不装配 byType: 根据 bean 的类型和当前 Bean 的 的属性的类型进行自动装配， 注意：byType 使用则该只能是出现 1 次， 若有 2 个及以上的则抛出异常 @Autowired 注解自动装配具有兼容类型的单个 Bean属性 1.构造器, 普通字段(即使是非 public), 一切具有参数的方法都可以应用@Authwired 注解 2.默认情况下, 所有使用 @Authwired 注解的属性都需要被设置. 当 Spring 找不到匹配的 Bean 装配属性时, 会抛出异常, 若某一属性允许不被设置, 可以设置 @Authwired 注解的 required 属性为 false 3.默认情况下, 当 IOC 容器里存在多个类型兼容的 Bean 时, 通过类型的自动装配将无法工作. 此时可以在 @Qualifier 注解里提供 Bean 的名称. Spring 允许对方法的入参标注 @Qualifiter 已指定注入 Bean 的名称 4.@Authwired 注解也可以应用在数组类型的属性上, 此时 Spring 将会把所有匹配的 Bean 进行自动装配. 5.@Authwired 注解也可以应用在集合属性上, 此时 Spring 读取该集合的类型信息, 然后自动装配所有与之兼容的 Bean. 6.@Authwired 注解用在 java.util.Map 上时, 若该 Map 的键值为 String, 那么 Spring 将自动装配与之 Map 值类型兼容的 Bean, 此时 Bean 的名称作为键值 Spring 还支持 @Resource 和 @Inject 注解， 这两个注解和 @Autowired 注解的功用类似 @Resource 注解要求提供一个 Bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称 @Inject 和 @Autowired 注解一样也是按类型匹配注入的 Bean， 但没有 reqired 属性 建议使用 @Autowired 注解 基于注解方式的 aop 加入 jar 包： 与 aop 相关: com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar spring-aspects-4.3.14.RELEASE.jar spring-aop-4.3.14.RELEASE.jar 常用:commons-logging-1.2.jarspring-beans-4.3.14.RELEASE.jarspring-context-4.3.14.RELEASE.jarspring-core-4.3.14.RELEASE.jarspring-expression-4.3.14.RELEASE.jar 在 spring IoC 容器加入 aop 命令空间并加入如下配置: &lt;aop:aspectj-autoproxy /&gt; 把横切关注点的代码抽象到切面的类中 使用 @Component 声明该类是 IoC 容器的一个 Bean 使用 @Aspect 声明该类是一个切面 在切面类声明各种通知： @Before: 前置通知, 在方法执行之前执行 @After: 后置通知, 在方法执行之后执行 [无论是否异常] @AfterRunning: 返回通知, 在方法返回结果之后执行[返回参数 throwing 的值与方法的异常参数名要一致,方法的异常类型可以指定，指定有则执行，无则不执行] @AfterThrowing: 异常通知, 在方法抛出异常之后[异常参数 returning 的值与方法的返回参数名要一致] @Around: 环绕通知, 围绕着方法执行[该相当一个完整的代理过程 与 ProceedingJoinPoint 参数共同使用，并且方法有返回值] 可以在通知方法中声明一个类型为 JoinPoint 的参数，然后就能访问链接细节，如方法名称和参数值 123456789101112131415161718192021@Around(value="declareJointPointExpression()") public Object arounMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getClass().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); Object result = null; try &#123; // 前置通知 System.out.println("The method " + methodName + " with " + args); // 执行方法 result = joinPoint.proceed(); // 返回通知 System.out.println("The method " + methodName + " end " + result); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); // 异常通知 System.out.println("The method " + methodName + " ocrrous thorw " + throwable); &#125; // 后置通知 System.out.println("The method " + methodName + " end " + result); return result; &#125; 最典型的切入点表达式时根据方法的签名来匹配各种方法: execution com.atguigu.spring.ArithmeticCalculator.(..): 匹配 ArithmeticCalculator 中声明的所有方法,第一个 代表任意修饰符及任意返回值. 第二个 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名. execution public ArithmeticCalculator.(..): 匹配 ArithmeticCalculator 接口的所有公有方法. execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法 execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数 execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法. 重用切面关注点表达式: 定义一个方法, 用于声明切入点表达式. 一般地, 该方法中再不需要添入其他的代码. 使用 @Pointcut 来声明切入点表达式. 后面的其他通知直接使用方法名来引用当前的切入点表达式. @Order(int order) 该声明切点类的执行顺序, 参数 order 值越小其执行顺序就越高 基于 IoC 容器配置方式 配置切面 Bean 配置 AOP 配置切面表达式 配置切面及通知 1234567891011121314151617&lt;!-- 配置 Bean --&gt; &lt;bean id="arithmeticCalculator" class="aqqje.com.aspect.xml.ArithmeticCalculatorImpl" /&gt; &lt;!-- 配置切面 Bean --&gt; &lt;bean id="loggingAspect" class="aqqje.com.aspect.xml.LoggingAspect"/&gt; &lt;!-- 配置 AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切点表达式 --&gt; &lt;aop:pointcut id="arithmeticCalculatorPoincut" expression="execution(* aqqje.com.aspect.xml.ArithmeticCalculator.*(..))"/&gt; &lt;!-- 配置通知及切面 --&gt; &lt;aop:aspect ref="loggingAspect" order="1"&gt; &lt;aop:before method="berforeMethod" pointcut-ref="arithmeticCalculatorPoincut"/&gt; &lt;aop:after method="afterMethod" pointcut-ref="arithmeticCalculatorPoincut"/&gt; &lt;aop:after-returning method="afterReturnMethod" pointcut-ref="arithmeticCalculatorPoincut" returning="result"/&gt; &lt;aop:after-throwing method="afterThorwMethod" pointcut-ref="arithmeticCalculatorPoincut" throwing="e"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; spring 事务 声明式事件 配置事务管理器 DataSourceTransactionManager 启用事务管理 transaction-manager 添加事件注解 Transactional 1234567&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;!-- 启用事务管理 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; 事件的传播行为 当一个事务方法被另一个事务方法调用时，必须指定事务应该如何传播 事务的传播行为可以由传播属性指定：spring 定义了 7 种类传播行为 使用 propagation 指定事件的传播行为 Propagation.REQUIRED, 即使用外事务。 REQUIRES_NEW， 即使用内事务，外事务挂起 事务的隔离级别 1.使用 propagation 指定事务的传播行为，即当前事务方法被别处一个事务方法调用时 如何使用事务，默认取值为 REQUIRED， 即使用调用方法的事务 REQUIRES_NEW：事务自己的事务，调用的事务方法的事务被挂起。 使用 isolation 指定事务的隔离级别， 最常用的取值为事务READ_COMMITTED 3.默认情况下 spring 的声明式事务所有的运行时异常进行回滚，也可以通过对应的属性进行设置，通常情况下去默认值即可。 4.使用 readOnly 指定指定事务的是否为只读， 表示这个事务只读取数据但不更新数据 ， 这样可以帮助数据库引擎优化事务， 若真的事一个只读取数据库值的方法， 应设置 readOnly = true 5.使用 timiout 指定强制回滚之前事务可以占用的赶时间 xml形式配置事务 步骤： 1.配置事务管理器 2.配置事务属性 3.配置事务切入点，把事务切入点和事务属性关联起来 12345678910111213141516171819&lt;!-- 配置事务管理器 --&gt;&lt;bean id="tranactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; &lt;!-- 配置事务属性 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="tranactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="purchase" propagation="REQUIRES_NEW"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; &lt;!-- 配置事务切入点，把事务切入点和事务属性关联越来 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id="txPointCut" expression="execution(* aqqje.com.jdbc.txxml.services.BookStockService.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"/&gt;&lt;/aop:config&gt; Spring 如何在 WEB 应用使用? 1) 需要外加的 jar 包: spring-web-xxx.RELEASE.jar spring-webmvc-xxx.RELEASE.jar 2) spring 的配置文件不变 3) 如何创建 IoC 容器? a 非 WEB 应用在 main 方法中直接创建 b 应该在 WEB 应用被服务器加载时就创建 IoC 容器: 在 ServletContextListener#contextInitalized(ServletContextExvent sce) 方法中创建 c 在 WEB 应用的其他组件中如何来访问 IoC 容器? 在 ServletContextListener#contextInitalized(ServletContextExvent sce) 方法中创建后, 可以把其在 ServletContext(即 application 域)的一个属性中 d 实际上, spring 配置文件的名字和位置应该也是可以配置的! 将其配置到时当前 WEB 应用的初始化参数中较为合适 4) 在 WEB 环境下使用 spring 需要在 web.xml 文件中加入如下配置: 12345678910&lt;!-- 配置 Spring 配置文件的名称和位置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 启动 IOC 容器的 ServletContextListener --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;]]></content>
      <tags>
        <tag>java, ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键]]></title>
    <url>%2F2018%2F05%2F03%2FIDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IDEA快捷键 IDEA 中自动生成 get/set 的方式 – alt + insert 操作 快捷键 说明 ctrl + ] 快速跳到代码块的结尾处 ctrl + [ 同上，快速跳到代码块的开始处 ctrl +shift + Enter 将输入的 if, for, 函数等补上 {} 或者 ; 使代码语句完整 shift + Enter 在当前下方开始新行 ctrl + alt + Enter 在当前上方开始新行 ctrl + delete 删除光标所在至单词结尾处的所有字符 ctrl + backSpace 删除光标所在至单词开头的所有字符 ctrl + → 将光标移至前一个单词 ctrl + ← 将光标移至后一个单词 ctrl + ↑ 向下滚动一行 ctrl + ↓ 向上滚动一行 ctrl + w 选中整个单词 ctrl + shift + u 切换大小写 编辑 快捷键 说明 ctrl + shift + j 将选中的行合并成一行 查找 快捷键 说明 ctrl + f 在当前文件中查找 ctrl + r 替换字符串 ctrl + shift + f 在全局文件中查找字符串 ctrl + shift + r 在全局中替换字符串 alt + f7 查找当前变量的作用，并直接对话框显示 ctrl + alt + f7 在文件中查找符号的使得 ctrl + shift + f7 在文件中高亮显示变量的作用 ## 导航 快捷键 说明 Ctrl+N 查找类文件 Ctrl+Shift+N 查找文件 Ctrl+G 定位到文件某一行 Alt+向左箭头 返回至上次光标位置 Alt+向右箭头 返回至后一次光标位置 Ctrl+Shift+Backspace 返回上次编辑位置 Ctrl+Shift+反斜杠 返回后一次编辑位置 Ctrl+Alt+B 定位至选中类或方法的具体实现 Ctrl+Shift+B 直接定位至光标所在变量的类型定义 Ctrl+U 直接定位至当前方法override或者implements的方法定义处 Ctrl+F12 显示当前文件的文件结构 Ctrl+Alt+F12 显示当前文件的路径，并可以方便的将相关父路径打开 Ctrl+H 显示当前类的继承层次 Ctrl+Shift+H 显示当前方法的继承层次 Ctrl+Alt+H 显示当前方法的调用层次 F2 定位至下一个错误处 Shift+F2 定位至前一个错误处 Ctrl+Alt+向上箭头 查找前一个变量共现的地方 Ctrl+Alt+向下箭头 查找下一个变量共现的地方 代码 快捷键 说明 Ctrl+O 重写基类的方法 Ctrl+I 实现基类或接口中的方法 Alt+Insert 产生构造方法、getter/setter等方法 Ctrl+Alt+T 将选中的代码使用if、while、try/catch等包装 Ctrl+Shift+Delete 去除相关的包装代码 完成 快捷键 说明 Alt+/ 自动完成 Alt+Enter 自动提示完成 折叠 快捷键 说明 Ctrl+= 展开代码 Ctrl+- 收缩代码 Ctrl+Alt+= 递归展开代码 Ctrl+Alt+- 递归收缩代码 Ctrl+Shift+= 展开所有代码 Ctrl+Shift+- 收缩所有代码 优化 快捷键 说明 Ctrl+J 插入Live Template SCtrl+Alt+J 使用Live Template包装 Ctrl+/ 使用//进行注释 Ctrl+Shift+/ 使用/**/进行注释 Ctrl+Alt+L 格式化代码 Ctrl+Alt+I 自动缩进行 Ctrl+Alt+O 优化import 重置 快捷键 说明 Shift+F6 重命名 Ctrl+F6 更改函数签名 Ctrl+Shift+F6 更改类型 常用 快捷键 说明 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地 Alt+6 查找TODO Alt+F10 定位到断点 ALT+F1 查找文件所在目录位置 CTRL+E 最近打开的文件 Ctrl+N 查找类 CTRL+ALT+B 找所有的子类 参考：(https://blog.csdn.net/tangcv/article/details/79900556)参考：(https://www.cnblogs.com/LeoBoy/p/5821577.html)]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM_CRUD 整合思路]]></title>
    <url>%2F2018%2F04%2F30%2FSSM-CRUD-%E6%95%B4%E5%90%88%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[SSM_CRUD 整合思路 SSM_CRUD-总览 ssm:SpringMVC+Spring+MyBatis CRUD： Create（创建） Retrieve（查询） Update（更新） Delete（删除） SSM_CRUD-功能点• 1、分页 • 2、数据校验 • jquery前端校验+JSR303后端校验 • 3、 ajax • 4、 Rest风格的URI；使用HTTP协议请求方式的动词，来表示对资 源的操作（GET（查询）， POST（新增）， PUT（修改）， DELETE （删除）） SSM_CRUD-技术点• 基础框架-ssm（SpringMVC+Spring+MyBatis） • 数据库-MySQL • 前端框架-bootstrap快速搭建简洁美观的界面 • 项目的依赖管理-Maven • 分页-pagehelper • 逆向工程-MyBatis Generator SSM_CRUD-环境搭建• 1、创建一个maven工程• 2、引入项目依赖的jar包 • spring • springmvc • mybatis • 数据库连接池，驱动包 • 其他（jstl， servlet-api， junit）• 3、引入bootstrap前端框架• 4、编写ssm整合的关键配置文件 • web.xml， spring,springmvc,mybatis，使用mybatis的逆向工程生成对应的bean以 及mapper• 5、测试mapper SSM_CRUD-查询• 1、访问index.jsp页面• 2、 index.jsp页面发送出查询员工列表请求• 3、 EmployeeController来接受请求，查出员工数据• 4、来到list.jsp页面进行展示• 5、 pageHelper分页插件完成分页查询功能• URI： /emps SSM_CRUD-查询 Ajax• 1、 index.jsp页面直接发送ajax请求进行员工分页数据的查询• 2、服务器将查出的数据，以json字符串的形式返回给浏览器• 3、浏览器收到js字符串。可以使用js对json进行解析，使用js通过 dom增删改改变页面。• 4、返回json。实现客户端的无关性。 SSM_CRUD-新增逻辑• 1、在index.jsp页面点击”新增”• 2、弹出新增对话框• 3、去数据库查询部门列表，显示在对话框中• 4、用户输入数据，并进行校验• jquery前端校验， ajax用户名重复校验，重要数据（后端校验(JSR303)，唯一约束）；• 5、完成保存• URI:• /emp/{id} GET 查询员工• /emp POST 保存员工• /emp/{id} PUT 修改员工• /emp/{id} DELETE 删除员工 SSM_CRUD-修改逻辑• 1、点击编辑• 2、弹出用户修改的模态框（显示用户信息）• 3、点击更新，完成用户修改 SSM_CRUD-删除逻辑• 1、单个删除• URI:/emp/{id} DELETE• 2、批量删除]]></content>
      <tags>
        <tag>java, SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvan安装配置]]></title>
    <url>%2F2018%2F04%2F30%2Fmvan%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[mvan安装配置 参考：https://www.cnblogs.com/eagle6688/p/7838224.html maven : https://maven.apache.org/download.cgi 解压 – &gt; 进入目录 –&gt; C:\java\OpenSource\apache-maven-3.5.3 配置系统变量: 1.新增系统变量 – &gt; 变量名:MAVEN_HOME 变量值：C:\java\OpenSource\apache-maven-3.5.32.编辑path 变量：追加 – &gt; %MAVEN_HOME%\bin\; 测试: 配置Maven本地仓库:选择一个目录用作maven的本地库 – &gt; C:\java\mavelocrepo\maven-repository – &gt;打开D:\Program Files\Apache\maven\conf\settings.xml文件，查找下面这行代码： /path/to/local/repo– &gt; localRepository节点默认是被注释掉的，需要把它移到注释之外，然后将localRepository节点的值改为我们在3.5.3 中创建的目录C:\java\mavelocrepo\maven-repository – &gt; 注意: localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:\Users\用户名.m2。当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。 运行一下DOS命令: mvn help:system 如果前面的配置成功，那么D:\Program Files\Apache\maven-repository会出现一些文件。 配置Eclipse的Maven环境]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《水浒传》人物出场统计]]></title>
    <url>%2F2018%2F04%2F21%2F%E3%80%8A%E6%B0%B4%E6%B5%92%E4%BC%A0%E3%80%8B%E4%BA%BA%E7%89%A9%E5%87%BA%E5%9C%BA%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[运用了 python 的 第三库 jieba 分词库, WordCloud 词云库, pyecharts 数据报表库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#《水浒传》 人物出场统计v2import jiebaimport jsonfrom scipy.misc import imreadimport timeimport matplotlib.pyplot as pltfrom wordcloud import WordCloudfrom pyecharts import Bar# 用于加载本地文本为 listdef locallist(filepath): locattxt = [line.strip() for line in open(filepath, 'r', encoding='utf-8').readlines()] return locattxt# 文本分词def getwords(originfile, selfdect): # originfile = '.\date\水浒传.txt', selfdect= r".\date\jieba.txt" txt = open(originfile, 'r', encoding='utf-8').read(); # 加载自定義字典 jieba.load_userdict(selfdect) # jieba 分詞 words = jieba.lcut(txt, cut_all=False); return words# 去除无关的词并根据词频排序集合def stopwords(stopwords, counts): for word in stopwords: del counts[word] items = list(counts.items()); # 根据词频排序集合 items.sort(key=lambda x: x[1], reverse=True) return items#解析成 json 类型并写文件def getjson(counts): wordjson = json.dumps((sorted(counts.items(), key=lambda x:x[1], reverse=True)), ensure_ascii=False) with open(r'.\date\wordjson.json', 'w+', encoding='utf-8') as f: f.write(wordjson)# 打印def showpirnt(items): for i in range(50): word, count = items[i] print('&#123;0:^4&#125;&#123;1:&lt;10&#125;&#123;2:&gt;5&#125;'.format(i + 1, word, count))# 生成词云def getwordcloud(imagepath, counts): #back_color = imread('F:\MoocPython\week06\image\bg.jpg') # 解析该图片 imagepath = imagepath + str(time.time())[-3:] + '.jpg' # 设置图片保存的路径 wcimage = WordCloud(font_path=r".\font\msyh.ttf", max_words=50, height=600, width=1200, #background_color='white', #mask=back_color ).generate_from_frequencies(counts) plt.imshow(wcimage) plt.axis('off') plt.show() wcimage.to_file(imagepath) # 保存图片# 生成柱形表def changlist(jsondict, savepath='.\date\pycs', title='水浒传人物出场统计(50)'):# dict 数据 -&gt; list(dict.keys()), list(dict.values()) attr = [] value = [] for i in range(30): attr.append(list(jsondict.keys())[i]) for i in range(30): value.append(list(jsondict.values())[i]) attr = ['&#123;&#125;'.format(i) for i in attr] value = ['&#123;&#125;'.format(i) for i in value] bar = Bar(title) bar.add('', attr, value, is_label_show=True, is_datazoom_show=True) bar.render(path=savepath + str(time.time())[-3:] + '.html')if __name__ == '__main__': words = getwords(str('.\date\水浒传.txt'), str(r'.\date\jieba.txt')) # 设置为字典类型 counts = &#123;&#125; for word in words: if len(word) == 1: continue elif word == "宋江道" or word == "宋公明" or word == "宋江便" or word == "宋江见": rword = "宋江" elif word == "智深" or word == "和尚" or word == "提辖": rword = "鲁智深" elif word == "军师": rword == "吴用" elif word == "教头": rword == "林冲" elif word == "黑旋风": rword == "李逵" elif word == "戴宗道": rword == "戴宗" elif word == "柴大官人": rword == "柴进" else: rword = word # 利用字典统计词频 counts[rword] = counts.get(rword, 0) + 1 #print(counts) stopword = locallist(str('.\date\stopwords.txt')) items = stopwords(stopword, counts) showpirnt(items) getwordcloud(str('.\image\wcpic') ,counts) # 获取 json 数据 jsontxt = open('.\date\wordjson.json', 'r', encoding='utf-8').read() txt = dict(json.loads(jsontxt)) changlist(txt)]]></content>
  </entry>
  <entry>
    <title><![CDATA[IDEA 破解]]></title>
    <url>%2F2018%2F04%2F20%2FIDEA-%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[IDEA在激活界面选择：License server内容： http://idea.toocruel.net点击右下角 Activate即可 webstorm在激活界面选择：License server内容： http://idea.wrbugtest.tk/点击右下角 Activate即可 PyChram JetbrainsCrack-2.9-release-enc.jar 使用： JetbrainsCrack-2.9-release-enc.jar 复制到Pychram\bin目录下 Pychram\bin目录下找到以下两个文件 “pycharm.exe.vmoptions”，”pycharm64.exe.vmoptions”, 在两个文件最末处加上 “-javaagent:D:\LearnSoft\pyChram\PyCharm 2018.1.3\bin\JetbrainsCrack-2.9-release-enc.jar” 在激活界面 “Activation code” 输入以下代码，或随便写123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "licenseId":"1454467925669", "licenseeName":"ilanyu", "assigneeName":"", "assigneeEmail":"", "licenseRestriction":"", "checkConcurrentUse":false, "products":[&#123; "code":"II", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"DM", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"AC", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"RS0", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"WS","paidUpTo":"2099-12-31" &#125;,&#123; "code":"DPN", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"RC", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"PS", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"DC", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"RM", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"CL","paidUpTo":"2099-12-31" &#125;,&#123; "code":"PC","paidUpTo":"2099-12-31" &#125;], "hash":"2911276/0", "gracePeriodDays":7, "autoProlongated":false&#125; 原文：原文：]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android基础]]></title>
    <url>%2F2018%2F03%2F26%2Fandroid%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[android开发环境]]></title>
    <url>%2F2018%2F03%2F10%2Fandroid%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[android开发主要有两种开发软件使用一是Eclipse二是Android studio,本文是从这两个方面来搭建环境.Eclipse:jdk + Eclipse + ADT + Android SDKAndroid studio: jdk + Android Studio + Android SDK注意：本文的搭建过程不需要vpn Eclipse手动配置准备 - jdk下载： Download Now jdk的安装以及配置过程在这里就不做过多的讲述了。 - Eclipse下载：Download Now jdk的安装过程在这里也略过了。 - ADT下载：Download Now 在这里点击默认下载：https://dl.google.com/android/ADT-23.0.7.zip 注意：如果需要其他版本：https://dl.google.com/android/ADT-xx.x.x.zip把xx.x.x改为对应的版本 - Android SDK下载：Download Now 配置 配置ADT： 找到已下载好的ADT：进行如图配置 点击确定,等待安装完成即可！ 配置Android SDK： 环境变量： - 新增系统变量：变量名：ANDROID_SDK_HOME变量值：Android SDK的根目录，如下图： - 系统变量Path中增加：%ANDROID_SDK_HOME%\platform-tools 以上两种配置完成在DOS中输入adb就会出现如下图： 设置端口：打开SDK Manager.exe,设置如下图： 端口设置：完成的之后随便选择一个Android版本下载即可 创建项目中的问题：如何可显化界面无法显示，原因是ADT与SDK版本不相匹配, 成功效果图： Eclipse集成开发包Download Now 下载集成开发包,解压即可用！这里不做过多的讲述。 Android studio准备 - jdk下载：Download Now jdk的安装以及配置过程在这里就不做过多的讲述了。 - Android Studio下载：Download Now 这里作者用的是绿色版，解压即可使用。 - Android SDK：同上不做解释。 配置 创建项目中的问题： 问题一：如下图 解决方法： 文件 –&gt; 配置 –&gt; 构建,执行,部署 –&gt; Gradle 如图设置Use local gradle distribution 确定即可 注意：Global home的路径在你的Android Studio 的根目录下。例如:D:\Android-Studio\soruce\android-studio-ide-171.4443003-windows32\android-studio\gradle\gradle-4.1 问题二：如下图： 解决方法： 找到项目 –&gt; app –&gt; build.gradle 修改如下图： 成功效果图：]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2F2018%2F03%2F07%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[java注解，三个基本的注解，自定义的注解，元注解 注解(Annotation)@since 1.5三个基本的注解 @Override:限定重写父类方法，该注释只能用于方法@Deprecated:用于表示某个程序元素（类， 方法等）已过时@SupperssWarnings:抑制编译器警钟警告 自定义的注解使用@interface声明一个注解 123public @interface MyAnnotation&#123; String value() default "hello";&#125; 元注解 @Retention:只能用于修饰一个注解定义，用于指定该注解可以保留多长时间[RetentionPolicy]类型成员变量，使用@Retention必须指定Value;value: RetetionPolicy.SOURCE:编译器直接丢弃这种策略的注释 RetetionPolicy.CLASS:编译器将把注释记录在class文件中，运行java程序时，jvm不会保留注解，这是默认值 RetetionPolicy.RUNTIME:编译器将把注释记录在class文件中，运行java程序时，jvm会保留注解，程序可以通过反射获取该 注释 @Target:用于修饰注解定义，用于指定被修饰的注解能用于修饰那些程序元素，@Target也包含一个名为value的成员变量 @Document：用于指定被该元注解修饰的注解类将javadoc工具提取成文档说明：依赖@Retention(RetentionPolicy.RUNTIME) @Inheried:被该注解修饰的注解将具有继承性，修饰的注解的类的子类将自动具有该注解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建Class的实例]]></title>
    <url>%2F2018%2F03%2F07%2F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAClass%E7%9A%84%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[如何获取Class的实例（4种） 1234567891011121314151617//Class实例四:通过类的加载器ClassLoader cl = new Arithmetic().getClass().getClassLoader();Class clazz3 = cl.loadClass("com.javaee_02.exer1.Arithmetic");Arithmetic ar3 = (Arithmetic)clazz3.newInstance();System.out.println(clazz3.getName());//Class实例三:通过Class的静态方法获取Class clazz2 = Class.forName("com.javaee_02.exer1.Arithmetic");Arithmetic ar2 = (Arithmetic)clazz2.newInstance();//Class实例二:通过运行时类的对象获取Arithmetic ar1 = new Arithmetic();Class clazz1 = ar1.getClass();//Class实例一:调用运行时类本身的.class属性Class&lt;Arithmetic&gt; clazz = Arithmetic.class;Arithmetic ar = (Arithmetic)clazz.newInstance();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORACLEU总结]]></title>
    <url>%2F2018%2F03%2F04%2FORACLEU%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对之前的学习做更深入的巩固，及加深体会，扎实基础！ 使用system用户解锁scott用户12alter user scott account unlock;alter user scott identified by tiger; 创建用户并授权12345create user newUser identified by newPwd;grant connect to newUser;grant create table to newUser;grant create proedure to newUser;grant unlimited tablespace to newUser; 创建表空间123create tablespace emp_tablespacedatafile &apos;c:emp_tablespace.dbf&apos;size 100mb newUser复制scott的emp表12grant select[all] on scott.emp to newUser; --system accountcreate table newEmp as select * from scott.emp; 显示EMP表的行号select rownum from emp;123456## &lt;span&gt;显示emp表每一个雇员的总收入(工资+奖金)&lt;/span&gt;```sqlupdate emp set comm = 0 from emp where comm is null;select ename,(sal+comm) [as] 总收入 from emp; 在列别名上使用双引号。（当你的别名为关键字或别名中有特殊符号时需要加双引号） ‘5’+ 5 结果为 10 ‘5’|| 5 结果为 ‘55’ ASC 表示升序 (可省略) Desc 表示降序(不可省略) 查询emp表雇员姓名和工资，并按工资从小到大(从大到小)排序1select ename, sal from emp order by sal asc(desc) 查询emp表雇员信息，先按部门从小到大排序，再按雇佣时间的先后排序1select * from emp order by deptno, hiredate; 使用DISTINCT消除重复行显示1select distinct job from emp; 部门ACCOUNTING所在的城市为NEW YORK1select '部门' || dname || '所在的城市为' || loc from dept; 显示雇员名称中包含“S”的雇员名称及名称长度1234-- 方法一：select ename, length(ename) from emp where like '%s%';-- 方法二：select ename, length(ename) from emp where instr(ename, 's', 1, 1) &gt; 0; 显示名称以“W”开头的雇员，并将名称转换成以大写开头1select initcap(ename) from emp where substr(ename, 1, 1) = 'W'; 如果不知道表的字段内容是大写还是小写，可以转换后比较1select * from emp where lower[upper](ename) in 'blake'['BLAKE']; 3.3434保留两位小数;1select round(3.3434, 2) from dual 判断用户的角色是否为SYSDBA1select userenv('ISDBA') from dual; 对部门表的部门名称和城市名进行转换123select decode(dname, 'ACCOUNTING', '统计部', 'RESEARCH', '研发部', 'SALES', '销售部', 'OPERATIONS', '其它部门') 部门,decode(loc, 'NEW YORK', '纽约', 'DALLAS', '达拉斯', 'CHICAGO', '芝加哥', 'BOSTON', '波士顿') 城市 from dept; 显示2008年的8月8日为星期几1select to_char('08-08月-2008', 'DY') from dual; 显示从本年1月1日开始到现在经过的天数(当前时间取SYSDATE的值)1select sysdate - to_date('2018-1-1', 'YYYY-MM-DD') from dual; 显示emp表雇员名称和雇员的经理名称123select worker.ename || '雇员的经理:' || manager.ename from emp worker, emp managerwhere worker.mgr = manager.empno 相等连接（内连接）ename,job,sal,comm,emp.deptno,dname123456--方法一：select ename, job, sal, comm, emp.deptno, dnamefrom emp, dept where emp.deptno = dept.deptno;--方法二：select ename, job, sal, comm, emp.deptno, dname from emp inner join dept on emp.deptno = dept.deptno; 求各部门平均工资的最高值1select deptno, max(ave(sal)) from emp group by deptno; 统计各部门的最高工资，排除最高工资小于3000的部门123select deptno, max(sal) from emp group by deptnohaning max(sal) &gt; 3000; 查询雇员表中排在第6～9位置上的雇员12select ename, sal from (select rownum as num, ename, sal from emp where rownum &lt;= 9 )where num &gt;= 6 查询工资低于任何一个“CLERK”的工资的雇员信息123select ename, job, sal from emp where sal &lt; any(select sal from emp where lower(job) = 'clerk')and lower(job) &lt;&gt; 'clerk' 创建从2000起始，增量为1 的序列abc：12create sequence abc increment by 1 start with 2000maxvalue 99999 cycle nocache; 创建按成绩分区的考生表，共分为3个区：1234567891011create table student(id varchar(5),name varchar(30)score number(3))partition by range(成绩)(partition a less than (300) tablespace users,partition b less than (600) tablespace users,partition c less than (maxvalue) tablespace); 创建emp表的经理视图(只读)1234creat or replace view manageras select * from emp where lower(job) = "manager" with read only;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery其他]]></title>
    <url>%2F2018%2F02%2F23%2FjQuery%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[jQuery其他:jQuery - noConflict() 方法 jQuery - noConflict() 方法: noConflict()方法,允许你在同一个页面加载多个jQuery实例，尤其是不同版本的jQuery，以及与其他javaScrip框架并存 noConflict()方法会释放对 $ 标识符的控制,这样其他脚本就可以使用它了 全名替代简写:12345678&lt;script&gt;$.noConflict();jQuery(document).ready(function()&#123; jQuery("button").click(function()&#123; jQuery("p").text("jQuery 仍然在工作!"); &#125;);&#125;);&lt;/script&gt; 创建自己的简写: 12345678&lt;script&gt;var jq=$.noConflict();jq(document).ready(function()&#123; jq("button").click(function()&#123; jq("p").text("jQuery 仍然在工作!"); &#125;);&#125;);&lt;/script&gt; 如果你的 jQuery 代码块使用 $ 简写，并且您不愿意改变这个快捷方式，那么您可以把 $ 符号作为变量传递给 ready 方法。这样就可以在函数内使用 $ 符号了 - 而在函数外，依旧不得不使用 “jQuery”：: 12345678&lt;script&gt;$.noConflict();jQuery(document).ready(function($)&#123; $("button").click(function()&#123; $("p").text("jQuery 仍然在工作!"); &#125;);&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery Ajax]]></title>
    <url>%2F2018%2F02%2F22%2FjQuery-Ajax%2F</url>
    <content type="text"><![CDATA[jQuery Ajax:jQuery - AJAX 简介,jQuery - AJAX load() 方法,jQuery - AJAX get() 和 post() 方法 jQuery - AJAX 简介什么是 AJAX？ AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。 关于 jQuery 与 AJAX jQuery 提供多个与 AJAX 有关的方法。通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中 jQuery - AJAX load() 方法load():从服务器加载数据，并把返回的数据放入被选元素中。 语法: $(selector).load(URL,data,callback); 参数： URL:必需，规定您希望加载的 URL。 data:可选的,规定与请求一同发送的查询字符串键/值对集合。 callback:可选,load() 方法完成后所执行的函数名称,回调函数可以设置不同的参数： responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 demo_test.txt:12&lt;h2&gt;jQuery and AJAX is FUN!!!&lt;/h2&gt;&lt;p id="p1"&gt;This is some text in a paragraph.&lt;/p&gt; 文件 “demo_test.txt” 的内容加载到指定的 元素中：1234567&lt;script&gt;$(document).ready(function()&#123; $(&quot;button&quot;).click(function()&#123; $(&quot;#div1&quot;).load(&quot;/statics/demosource/demo_test.txt&quot;); &#125;);&#125;);&lt;/script&gt; 把 “demo_test.txt” 文件中 id=”p1” 的元素的内容，加载到指定的 元素中：1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").load("/statics/demosource/demo_test.txt #p1"); &#125;);&#125;);&lt;/script&gt; load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示”外部内容加载成功！”，而如果失败，则显示错误消息： 123456789101112 &lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").load("/statics/demosource/demo_test.txt",function(responseTxt,statusTxt,xhr)&#123; if(statusTxt=="success") alert("外部内容加载成功!"); if(statusTxt=="error") alert("Error: "+xhr.status+": "+xhr.statusText); &#125;); &#125;);&#125;);&lt;/script&gt; jQuery - AJAX get() 和 post() 方法 $.get():通过 HTTP GET 请求从服务器上请求数据。 语法： $.get(URL,callback); 参数: URL:必需,规定您希望请求的 URL。 callback:可选,是请求成功后所执行的函数名。 $.get() 方法从服务器上的一个文件中取回数据： demo_test.php: 123&lt;?phpecho "This is some text from an external PHP file.";?&gt; 123456789&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $.get("/statics/demosource/demo_test.php",function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;); &#125;);&#125;);&lt;/script&gt; $.post():通过 HTTP POST 请求从服务器上请求数据。 语法: $.post(URL,data,callback); 参数： URL:必需,规定您希望请求的 URL。 data:可选,规定连同请求发送的数据。 callback:可选,是请求成功后所执行的函数名。 使用 $.post() 连同请求一起发送数据： demo_test_post.php:12 &lt;?php $name = isset($_POST[‘name’]) ? htmlspecialchars($_POST[‘name’]) : ‘’; $city = isset($_POST[‘city’]) ? htmlspecialchars($_POST[‘city’]) : ‘’; echo ‘Dear ‘ . $name; echo ‘Hope you live well in ‘ . $city; ?&gt;1234567891011121314&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $.post("/statics/demosource/demo_test_post.php", &#123; name:"W3Cschool", url:"http://www.w3cschool.cn" &#125;, function(data,status)&#123; alert("数据: " + data + "状态: " + status); &#125;); &#125;);&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery遍历]]></title>
    <url>%2F2018%2F02%2F21%2FjQuer%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[-jQuery 遍历-jQuery 遍历 – 祖先-jQuery 遍历 – 后代--jQuery 遍历 – 同胞(siblings)-jQuery 遍历 – 过滤 jQuery 遍历12345678910 &lt;div&gt; | &lt;ul&gt; |-------------------------------- &lt;li&gt; &lt;li&gt; | | ------------ -------- | | |&lt;span&gt; &lt;span&gt; &lt;b&gt; 图示解析：1234567 &lt;div&gt; 元素是 &lt;ul&gt; 的父元素，同时是其中所有内容的祖先。&lt;ul&gt; 元素是 &lt;li&gt; 元素的父元素，同时是 &lt;div&gt; 的子元素左边的 &lt;li&gt; 元素是 &lt;span&gt; 的父元素，&lt;ul&gt; 的子元素，同时是 &lt;div&gt; 的后代。&lt;span&gt; 元素是 &lt;li&gt; 的子元素，同时是 &lt;ul&gt; 和 &lt;div&gt; 的后代。两个 &lt;li&gt; 元素是同胞（拥有相同的父元素）。右边的 &lt;li&gt; 元素是 &lt;b&gt; 的父元素，&lt;ul&gt; 的子元素，同时是 &lt;div&gt; 的后代。&lt;b&gt; 元素是右边的 &lt;li&gt; 的子元素，同时是 &lt;ul&gt; 和 &lt;div&gt; 的后代。 遍历 DOM:遍历方法中最大的种类是树遍历（tree-traversal）。 jQuery 遍历 – 祖先向上遍历 DOM 树方法: -parent():返回被选元素的直接父元素,该方法只会向上一级对 DOM 树进行遍历-parents():返回被选元素的所有祖先元素，它一路向上直到文档的根元素-parentsUntil():返回介于两个给定元素之间的所有祖先元素。 parent(): 返回所有 元素的所有祖先:12345&lt;script&gt;$(document).ready(function()&#123; $("span").parent().css(&#123;"color":"red","border":"2px solid blue"&#125;);&#125;);&lt;/script&gt; parents(): 返回所有 元素的所有祖先，并且它是 元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("span").parents("ul").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; parentsUntil(): 与 元素之间的所有祖先元素： 12345 &lt;script&gt;$(document).ready(function()&#123; $("span").parents("ul").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; jQuery 遍历 – 后代-children():返回被选元素的所有直接子元素。-find():返回被选元素的后代元素，一路向下直到最后一个后代。 children(): 返回每个 元素的所有直接子元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("div").children().css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; 返回类名为 “1” 的所有 元素，并且它们是 的直接子元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("div").children("p.1").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; find(): 返回属于 后代的所有 元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("div").find("span").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; 返回 的所有后代： 12345&lt;script&gt;$(document).ready(function()&#123; $("div").find("*").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; jQuery 遍历 - 同胞(siblings)-siblings():返回被选元素的所有同胞元素。-next():返回被选元素的下一个同胞元素。-nextAll():返回被选元素的所有跟随的同胞元素。-nextUntil():返回介于两个给定参数之间的所有跟随的同胞元素。-prev()&amp;&amp;prevAll()&amp;&amp;-prevUntil():工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞元素向后遍历，而不是向前）。 siblings(); 返回 的所有同胞元素：[但返回中不包含被选元素] 12345&lt;script&gt;$(document).ready(function()&#123; $("h2").siblings().css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; 返回属于 的同胞元素的所有 元素：[返回中包含被选元素] 12345&lt;script&gt;$(document).ready(function()&#123; $("h2").siblings("h2").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; next(): 返回 的下一个同胞元素：[返回中不包含被选元素]12345&lt;script&gt;$(document).ready(function()&#123; $("h2").next().css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; nextAll(): 返回 的所有跟随的同胞元素：[返回中不包含被选元素]12345&lt;script&gt;$(document).ready(function()&#123; $("h2").nextAll().css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; jQuery 遍历 – 过滤 first():返回被选元素的首个元素。 last():返回被选元素的最后一个元素。 eq():返回被选元素中带有指定索引号的元素,index从0开始 filter():允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 not():返回不匹配标准的所有元素,not() 方法与 filter() 相反 first(): 选取首个 元素内部的第一个 元素：12345&lt;script&gt;$(document).ready(function()&#123; $("div p").first().css("background-color","yellow");&#125;);&lt;/script&gt; last(): 选择最后一个 元素中的最后一个 元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("div p").last().css("background-color","yellow");&#125;);&lt;/script&gt; eq(): 选取第二个 元素（索引号 1）：12345&lt;script&gt;$(document).ready(function()&#123; $("p").eq(0).css("background-color","yellow");&#125;);&lt;/script&gt; filter(): 返回带有类名 “intro” 的所有 元素：实例 12345&lt;script&gt;$(document).ready(function()&#123; $("p").filter(".url").css("background-color","yellow");&#125;);&lt;/script&gt; not(): 返回不带有类名 “intro” 的所有 元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("p").not(".url").css("background-color","yellow");&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery HTML]]></title>
    <url>%2F2018%2F02%2F20%2FjQuery-HTML%2F</url>
    <content type="text"><![CDATA[jQuery HTML：jQuery 捕获,jQuery 设置,jQuery 添加元素,jQuery 删除元素,jQuery CSS 类,jQuery css() 方法,jQuery 尺寸 jQuery 捕获获取内容： text():设置或返回所选元素的文本内容 html():设置或返回所选元素的内容（包括 HTML 标记） val():设置或返回表单字段的值 获取属性： attr():用于获取属性值 text()&amp;&amp;html():123456789101112&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; alert("Text: " + $("#test").text()); //Text:这是段落中的 粗体 文本。 &#125;); $("#btn2").click(function()&#123; alert("HTML: " + $("#test").html()); //Html:这是段落中的&lt;b&gt;粗体&lt;/b&gt;文本。 &#125;);&#125;);&lt;/script&gt; val():1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; alert("Val:" + $("#test").val()); &#125;);&#125;);&lt;/script&gt; attr(): 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; alert("Attr:" + $("#w3s").attr("href")); &#125;);&#125;);&lt;/script&gt; jQuery 设置text()&amp;&amp;html()&amp;&amp;val: 12345678910111213&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("#test1").text("Hello world!"); &#125;); $("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;"); &#125;); $("#btn3").click(function()&#123; $("#test3").val("W3Cschool"); &#125;);&#125;);&lt;/script&gt; text()、html() 以及 val()，同样拥有回调函数。回调函数由两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串 1234567891011121314$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("#test1").text(function(i,origText)&#123; return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; &#125;); &#125;); $("#btn2").click(function()&#123; $("#test2").html(function(i,origText)&#123; return "旧 html: " + origText + " 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: " + i + ")"; &#125;); &#125;);&#125;); attr(): 1234567891011&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; //$("#runoob").attr("href", "http://www.w3cschool.cn/jquery"); $("#runoob").attr(&#123; "href" : "http://www.w3cschool.cn/jquery", "title" : "jQuery 教程" &#125;); &#125;);&#125;);&lt;/script&gt; Query 添加元素 append():在被选元素内部的结尾插入指定内容 prepend():在被选元素内部的开头插入指定内容 after():在被选元素之后插入内容 before():在被选元素之前插入内容 append()&amp;&amp;prepend: 12345678910&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("p").prepend("&lt;b&gt;在开头追加文本&lt;/b&gt;。 "); &#125;); $("#btn2").click(function()&#123; $("ol").prepend("&lt;li&gt;在开头添加列表项&lt;/li&gt;"); &#125;);&#125;);&lt;/script&gt; append()&amp;&amp;prepend添加若干新元素:12345678910&lt;script&gt;function appendText()&#123; var txt1="&lt;p&gt;文本。&lt;/p&gt;"; // 使用 HTML 标签创建文本 var txt2=$("&lt;p&gt;&lt;/p&gt;").text("文本。"); // 使用 jQuery 创建文本 var txt3=document.createElement("p"); txt3.innerHTML="文本。"; // 使用 DOM 创建文本 text with DOM $("body").append(txt1,txt2,txt3); // 追加新元素&#125;&lt;/script&gt; after()&amp;&amp;before(): 1234567891011&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("img").before("&lt;b&gt;之前&lt;/b&gt;"); &#125;); $("#btn2").click(function()&#123; $("img").after("&lt;i&gt;之后&lt;/i&gt;"); &#125;);&#125;);&lt;/script&gt; after()&amp;&amp;before()添加若干新元素: 12345678910111213141516&lt;script&gt;function afterText()&#123;var txt1="&lt;b&gt;I &lt;/b&gt;";var txt2 = $("&lt;i&gt;&lt;/i&gt;").text(" LOVE ");var txt3=document.createElement("big");txt3.innerHTML = "LIULI";$("img").after(txt1,txt2,txt3); &#125;function beforeText()&#123; var text1 = "&lt;b&gt;I &lt;/b&gt;"; var text2 = $("&lt;i&gt;&lt;/i&gt;").text(" LOVE "); var text3 = document.createElement("big"); text3.innerHTML=" LIULI"; $("img").before(text1,text2,text3);&#125;&lt;/script&gt; jQuery 删除元素 remove():删除被选元素（及其子元素） empty():从被选元素中删除子元素 remove(): 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").remove(); &#125;);&#125;);&lt;/script&gt; remove()过滤被删除的元素: 12345678 //class="italic" 的所有 &lt;p&gt; 元素&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("p").remove(".italic"); &#125;);&#125;);&lt;/script&gt; empty():(所有子类删除) 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").empty(); &#125;);&#125;);&lt;/script&gt; jQuery CSS 类 addClass():向被选元素添加一个或多个类 removeClass():从被选元素删除一个或多个类 toggleClass():对被选元素进行添加/删除类的切换操作 addClass():12345678&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important"); &#125;);&#125;);&lt;/script&gt; addClass()规定多个类:1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("div").addClass("important blue"); &#125;);&#125;);&lt;/script&gt; removeClass(): 也可以删除多个class属性1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("h1,h2,p").removeClass("blue"); &#125;);&#125;);&lt;/script&gt; toggleClass()：1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("h1,h2,p").toggleClass("blue"); &#125;);&#125;);&lt;/script&gt; jQuery css() 方法 css():设置或返回样式属性 css():返回 CSS 属性 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; alert("背景颜色 = " + $("p").css("background-color")); &#125;);&#125;);&lt;/script&gt; css():设置 CSS 属性 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("p").css("background-color","yellow"); &#125;);&#125;);&lt;/script&gt; css():设置多个 CSS 属性 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("p").css(&#123;"background-color":"yellow","font-size":"200%"&#125;); &#125;);&#125;);&lt;/script&gt; jQuery 尺寸 width():设置或返回元素的宽度（不包括内边距、边框或外边距） height():设置或返回元素的高度（不包括内边距、边框或外边距） innerWidth():返回元素的宽度（包括内边距） innerHeight():方法返回元素的高度（包括内边距） outerWidth():返回元素的宽度（包括内边距和边框） outerHeight():方法返回元素的高度（包括内边距和边框） width()&amp;&amp;height(): 12345678910&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; var txt=""; txt+="Width of div: " + $("#div1").width() + "&lt;/br&gt;"; txt+="Height of div: " + $("#div1").height(); $("#div1").html(txt); &#125;);&#125;);&lt;/script&gt; innerWidth()&amp;&amp;innerHeight(): 123456789101112&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; var txt=""; txt+="div 宽度: " + $("#div1").width() + "&lt;/br&gt;"; txt+="div 高度: " + $("#div1").height() + "&lt;/br&gt;"; txt+="div 宽度，包含内边距: " + $("#div1").innerWidth() + "&lt;/br&gt;"; txt+="div 高度，包含内边距: " + $("#div1").innerHeight(); $("#div1").html(txt); &#125;);&#125;);&lt;/script&gt; outerHeight()&amp;&amp;outerWidth(): 123456789101112&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; var txt=""; txt+="div 宽度: " + $("#div1").width() + "&lt;/br&gt;"; txt+="div 高度: " + $("#div1").height() + "&lt;/br&gt;"; txt+="div 宽度，包含内边距和边框: " + $("#div1").outerWidth() + "&lt;/br&gt;"; txt+="div 高度，包含内边距和边框: " + $("#div1").outerHeight(); $("#div1").html(txt); &#125;);&#125;);&lt;/script&gt; outerWidth(true) 方法返回元素的宽度（包括内边距、边框和外边距）]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java File类练习]]></title>
    <url>%2F2018%2F02%2F20%2Fjava-File%E7%B1%BB%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[对File类进行了解！ 1234567891011121314151617181920212223242526272829303132333435363738394041package test;import java.io.File;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;public class file &#123; public static void main(String[] args) throws IOException &#123; //初始化 File f1 = new File("h:\\mmjpg"); //判断是不是存在 System.out.println(f1.exists()); //判断是不是文件 System.out.println(f1.isFile()); //判断是不是文件夹 System.out.println(f1.isDirectory()); //获取文件大小(不能用于文件夹) System.out.println(f1.length() + "字节！"); //获取文件最后修改的时间 long l1 = f1.lastModified(); Date d1 = new Date(l1); SimpleDateFormat sdf = new SimpleDateFormat("YYYY-MM-dd HH:mm:ss"); System.out.println(sdf.format(d1)); //获得文件名称(初始化的文件名称"D:\\mmjpg") System.out.println("文件名称" + f1.getName()); //获得文件的上层目录 System.out.println(f1.getParent()); //获得文件的绝对路径 System.out.println(f1.getAbsoluteFile()); //获得标准绝对路径 System.out.println(f1.getCanonicalPath()); //获得分区的总大小 System.out.println(f1.getTotalSpace()); //获得分区未使用大小 System.out.println(f1.getFreeSpace()); //重命名 //File f2 = new File("D:\\mm"); //f1.renameTo(f2); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java复制文件]]></title>
    <url>%2F2018%2F02%2F20%2Fjava%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Download Now 1.字节流:每次只能处理一个字节 2.java中所有字节流都以InPutStream和OutputStream作为祖先类 3.InputStream类 最核心方法read 其次是读取一个字节 无参,其返回值是int类型,里面存放的就是所读到的那个字节的信息 下次再调用read方法时,读取的并 不是刚才所读到的那个字节,而下一个字节 以此类推,直到把数据源中每一个字节都读取完毕 当read所返回值是-1表示读到数据源的末尾 4.OutputStream类 最核心方法write 是向数据源中输出一个字节 参数int类型,其意义就是向数据源输出的信息,真实写入数据源的仅是一个字节 write就去没有所谓的结束,理论上,有多少字节都可以逐一写入数据源中 5.无论是输入流还是输出流,在使用完之后,都要关闭流对象,否则会导致系统资源耗尽 6.调用流对象的close方法实现关闭 读取单个字节复制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package test;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class fileIO &#123; public static void main(String[] args) &#123; //伪初始化 InputStream fis = null; OutputStream fos = null; String inpath = "D:\\test.txt"; String outpath = ("f:\\test.txt"); File f1 = new File(inpath); File f2 = new File(outpath.substring(0, 8)); //判断是不是存在源文件和目标目录 if(!(f1.isFile() == true &amp;&amp; f2.isDirectory() == true)) &#123; System.out.println("复制失败！源文件或目标目录存在"); &#125; else &#123; try &#123; //初始化 fis = new FileInputStream(inpath); fos = new FileOutputStream(outpath); int temp; //开始复制文件 while((temp=fis.read())!=-1) &#123; fos.write(temp); &#125; System.out.println("文件复制成功！"); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); //关闭IO流并处理异常 &#125; finally &#123; if(fis!=null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block； e.printStackTrace(); &#125; if(fos!=null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 读取一组字节复制重载read()读取一组字节 int read(byte[] b) int read(byte[] b, int off, int len)重载write()写入一组字节 int write(byte[] b) int write(byte[] b, int off, int len) 12345int readByteByte[] buff = new Byte[1024]while((readByte=fis.read(buff))!=-1)&#123; fos.write(buff,0,readByte)&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery效果]]></title>
    <url>%2F2018%2F02%2F19%2FjQuery%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[jQuery效果:隐藏和显示[hide(),show(),toggle()],淡入淡出[fadeIn(),fadeOut(),fadeToggle(),fadeTo()],滑动[slideDown(),slideUP(),slideToggle()],动画[animate()],停止动画[stop()] 隐藏和显示[hide(),show(),toggle()]toggle语法：切换hide()与show()【隐藏和显示】 $(selector).toggle(speed, callback) 参数： speed:规定隐藏/显示的速度value:”slow”、”fast” 或毫秒 callback: $(selector)选中的元素的个数为n个，则callback函数会执行n次callback函数名后加括号，会立刻执行函数体，而不是等到显示/隐藏完成后才执行callback既可以是函数名，也可以是匿名函数 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("p").toggle("slow"); &#125;);&#125;);&lt;/script&gt; hide(),show()与toggle大同小异 淡入淡出[fadeIn(),fadeOut(),fadeToggle(),fadeTo()]fadeToggle语法：切换fadeIn()与fadeOut()【淡入淡出】 $(selector).fadeToggle(speed,callback) 参数：同toggle() 123456789&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").fadeToggle(1000); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle("fast"); &#125;);&#125;);&lt;/script&gt; fadeTo()语法：【设不透明度】 $(selector).fadeTo(speed,opacity,callback); 参数： speed:必需参数,规定效果的时长 opacity:必需参数,透明度value[0`1] callback:可选参数,该函数完成后所执行的函数名称 123456789&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").fadeTo("slow",0.15); $("#div2").fadeTo("slow",0.4); $("#div3").fadeTo("slow",0.7); &#125;);&#125;);&lt;/script&gt; 滑动[slideDown(),slideUP(),slideToggle()]toggle语法：切换slideDown()与slideUP()【向下滑动与向上滑动】 $(selector).slideToggle(speed,callback); 参数：同toggle() 1234567&lt;script&gt; $(document).ready(function()&#123; $("#flip").click(function()&#123; $("#panel").slideToggle("slow"); &#125;);&#125;);&lt;/script&gt; 动画[animate()]【使用Camel 标记法书写属性名】语法： $(selector).animate({params},speed,callback); 参数： {params}:必需参数,定义形成动画的 CSS 属性 speed:可选参数,规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒 callback:可选参数,动画完成后所执行的函数名称 1. 元素往右边移动了250px1234567&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("div").animate(&#123;left:'250px'&#125;); &#125;);&#125;);&lt;/script&gt; 2. 元素往右边移动了250px,透明度为0.5,高变150px,宽为150px $(document).ready(function(){ $("button").click(function(){ $("div").animate({ left:'250px', opacity:'0.5', height:'150px', width:'150px' }); }); }); 3.animate()使用相对值 1234567891011&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("div").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;); &#125;);&#125;);&lt;/script&gt; 4.animate() - 使用预定义的值[valu:show,hide,toggle] 123456789&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("div").animate(&#123; height:'toggle' &#125;); &#125;);&#125;);&lt;/script&gt; 5.animate() - 使用队列功能 1234567891011&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; var div=$("div"); div.animate(&#123;height:'300px',opacity:'0.4'&#125;); div.animate(&#123;width:'300px',opacity:'0.8'&#125;); div.animate(&#123;height:'100px',opacity:'0.4'&#125;); div.animate(&#123;width:'100px',opacity:'0.8'&#125;); &#125;);&#125;);&lt;/script&gt; 停止动画[stop()]语法: $(selector).stop(stopAll,goToEnd); 参数: stoppAll:可选参数,规定是否应该清除动画队列,默认是 false goToEnd:可选参数,规定是否立即完成当前动画,默认是 false 12345678910&lt;script&gt; $(document).ready(function()&#123; $("#flip").click(function()&#123; $("#panel").slideDown(5000); &#125;); $("#stop").click(function()&#123; $("#panel").stop(); &#125;);&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pygame小游戏]]></title>
    <url>%2F2018%2F02%2F19%2Fpygame%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[最近了解了pygame库，根据学习内容，完成了这个小游戏，游戏大概是窗口中的文字可以移动，上下左右键可以控制移动的速度，鼠标也可以控制文字，当窗口最小化时，文字不移动，当窗口重新打开亦可以移动，移动时背景色发生相应的变化！不足的时鼠标控制有点问题！ 依赖： pygame第三方库 执行 pip install pygame 即可以安装 ##代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import pygame, sysimport pygame.freetype# 初始化pygame.init()size = width, height = 600, 400#窗口大小speed = [1, 1]#速度GOLD = 255, 251, 0#文字颜色aqqje = [230, 160]#文字范围screen = pygame.display.set_mode(size, pygame.RESIZABLE)f1 = pygame.freetype.Font('C:\Windows\Fonts\simhei.ttf', 36)#设置字体f1rect = f1.render_to(screen, aqqje, r"aqqje'note", fgcolor=GOLD, size = 61)#绘制文字fps = 300flock = pygame.time.Clock()#设置帧率bgcolor = pygame.Color('black')still = Falsedef RGBChannel(a): return 0 if a &lt; 0 else (255 if a &gt; 255 else int(a))while True: for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() #键盘控制 elif event.type == pygame.KEYDOWN: #left速度+1 if event.key == pygame.K_LEFT: speed[0] = speed[0] if speed[0] == 0 else (abs(speed[0]) - 1) * int(speed[0] / abs(speed[0])) #right速度-1 elif event.key == pygame.K_RIGHT: speed[0] = speed[0] + 1 if speed[0] &gt; 0 else speed[0] - 1 #up速度+1 elif event.key == pygame.K_UP: speed[1] = speed[1] + 1 if speed[1] &gt; 0 else speed[1] - 1 #down速度-1 elif event.key == pygame.K_DOWN: speed[1] = speed[1] if speed[1] == 0 else (abs(speed[1]) - 1) * int(speed[1] / abs(speed[1])) #Esc退出 elif event.key == pygame.K_ESCAPE: sys.exit() #改变窗口大小 elif event.type == pygame.VIDEORESIZE: size = width, height = event.w, event.h screen = pygame.display.set_mode(size, pygame.RESIZABLE) #鼠标事件 elif event.type == pygame.MOUSEBUTTONDOWN: if event.button == 1: still = True elif event.type == pygame.MOUSEBUTTONUP: still = False if event.pos == 1: aqqje[0] = event.pos[0] - f1rect.width aqqje[1] = event.pos[1] - f1rect.height elif event.type == pygame.MOUSEMOTION: if event.buttons[0] == 1: aqqje[0] = event.pos[0] - f1rect.width aqqje[1] = event.pos[1] - f1rect.height #保证不出右界 if aqqje[0] &lt; 0 or aqqje[0] + f1rect.width &gt; width: speed[0] = -speed[0] if f1rect.width &gt; width and f1rect.width + aqqje[0] &gt; f1rect.width: speed[0] = -speed[0] #保证不出下界 if aqqje[1] &lt; 0 or aqqje[1] + f1rect.height &gt; height: speed[1] = -speed[1] if f1rect.height &gt; height and f1rect.height + aqqje[1] &gt; f1rect.height: speed[1] = -speed[1] #窗口最小化停止移动 if pygame.display.get_active(): #横向移动 aqqje[0] = aqqje[0] + speed[0] #向下移动 aqqje[1] = aqqje[1] + speed[1] #背景可变 bgcolor.r = RGBChannel(f1rect.width * 255 / width) bgcolor.g = RGBChannel(f1rect.height * 255 / height) bgcolor.b = RGBChannel(min(aqqje[0], aqqje[1] * 255 / max(aqqje[0], aqqje[1], 1))) #刷新 screen.fill(bgcolor) f1rect = f1.render_to(screen, aqqje, r"aqqje'note", fgcolor=GOLD, size=61) pygame.display.update() flock.tick(fps)]]></content>
      <categories>
        <category>-python -pygame</category>
      </categories>
      <tags>
        <tag>-python -pygame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器]]></title>
    <url>%2F2018%2F02%2F18%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[介绍常见的jQuery选择器：元素选择器，id选择器，.class选择器，css选择器 元素选择器jQuery 元素选择器基于元素名选取元素. $(“p”) $(“button”) … #id选择器jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器. $(“#test”) $(“#lui”) .class选择器jQuery 类选择器可以通过指定的 class 查找元素 $(“.test”) $(“.lui”) css选择器jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性 $(“p”).css(“background-color”,”red”); More 语法 描述 $(“*”) 选取所有元素 $(this) 选取当前 HTML 元素 $(“p.intro”) 选取 class 为 intro 的 元素 $(“p:first”) 选取第一个 元素 $(“ul li:first”) 选取第一个 元素的第一个 元素 $(“ul li:first-child”) 选取每个 元素的第一个 元素 $(“[href]”) 选取带有 href 属性的元素 $(“a[target=’_blank’]”) 选取所有 target 属性值等于 “_blank” 的 元素 $(“a[target!=’_blank’]”) 选取所有 target 属性值不等于 “_blank” 的 元素 $(“:button”) 选取所有 type=”button” 的 元素 和 元素 $(“tr:even”) 选取偶数位置的 元素 $(“tr:odd”) 选取奇数位置的 元素 CDN库引用百度： http://libs.baidu.com/jquery/1.10.2/jquery.min.js Download Now 又拍云: http://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js Download Now 新浪: http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js Download Now Google: http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js Download Now Microsoft: http://ajax.htmlnetcdn.com/ajax/jQuery/jquery-1.10.2.min.js Download Now]]></content>
      <categories>
        <category>-jQuery</category>
      </categories>
      <tags>
        <tag>-jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery鼠标事件]]></title>
    <url>%2F2018%2F02%2F18%2FjQuery%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[jQuery常见的鼠标事件：单击click,双击dbclick,进入mouseenter,离开mouseleave,鼠标按键mousedown，鼠标按钮mouseup,光标悬停hover,焦点focus,失焦blur click()click() 方法是当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。 1234567&lt;script&gt; $(document).ready(function()&#123; $("p").click(function()&#123; $(this).hide(); &#125;); &#125;);&lt;/script&gt; dbclick()当双击元素时，会发生 dblclick 事件。dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数： 1234567&lt;script&gt; $(document).ready(function()&#123; $("#p1").dblclick(function()&#123; $(this).hide(); &#125;); &#125;);&lt;/script&gt; mouseenter()当鼠标指针穿过元素时，会发生 mouseenter 事件。mouseenter() 方法触发 mouseenter 事件，或规定当发生 mouseenter 事件时运行的函数： 1234567&lt;script&gt; $(document).ready(function()&#123; $("#p1").mouseenter(function()&#123; alert("You entered p1!"); &#125;); &#125;);&lt;/script&gt; mouseleave()当鼠标指针离开元素时，会发生 mouseleave 事件。mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数 1234567&lt;script&gt; $(document).ready(function()&#123; $("#p1").mouseleave(function()&#123; alert("Bye! You now leave p1!"); &#125;); &#125;);&lt;/script&gt; mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数 1234567&lt;script&gt; $(document).ready(function()&#123; $("#p1").mousedown(function()&#123; alert("Bye! You now leave p1!"); &#125;); &#125;);&lt;/script&gt; mouseup()当在元素上松开鼠标按钮时，会发生 mouseup 事件。mouseup() 方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数 1234567&lt;script&gt;$(document).ready(function()&#123; $("#p1").mouseup(function()&#123; alert("Mouse up over p1!") &#125;);&#125;);&lt;/script&gt; hover()hover()方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 123456789&lt;script&gt; $(document).ready(function()&#123; $("#p1").hover(function()&#123;alert("You entered p1!"); &#125;, function()&#123; alert("Bye! You now leave p1!"); &#125;); &#125;);&lt;/script&gt; focus()&amp;&amp;blur()1.当元素获得焦点时，发生 focus 事件。当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数 2.当元素失去焦点时，发生 blur 事件。blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数 12345678910&lt;script&gt;$(document).ready(function()&#123; $("input").focus(function()&#123; $(this).css("background-color","#cccccc"); &#125;); $("input").blur(function()&#123; $(this).css("background-color","#ffffff"); &#125;);&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>-jQuery</category>
      </categories>
      <tags>
        <tag>-jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐外链接]]></title>
    <url>%2F2018%2F02%2F18%2F%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%A4%96%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[网易云音乐外链接公式:http://music.163.com/song/media/outer/url?id=ID.mp3 歌曲：Superstar网易云url：http://music.163.com/#/song?id=492145159网易云音乐外链接url:http://music.163.com/song/media/outer/url?id=492145159.mp3 参考]]></content>
      <categories>
        <category>[object Object]</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬取全网站所有图片]]></title>
    <url>%2F2018%2F02%2F18%2Fpython%E7%88%AC%E5%8F%96%E5%85%A8%E7%BD%91%E7%AB%99%E6%89%80%E6%9C%89%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[整体思路：1.获取网站最大page是多少?2.再遍历出所有page的url3.再分别对每个page页进行套图的url遍历4.找出每个套图的最大page，5.对套图的每一个图片进行保存 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134# 导入必要的库import requestsfrom bs4 import BeautifulSoupimport osimport sysimport lxmlfrom multiprocessing import Pool, cpu_countimport time# 设置headers头信息header = &#123; # 判断客户端的请求是Ajax请求 'X-Requested-With': 'XMLHttpRequest', # 用户代理 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36', # 反盗链 'Referer': 'http://www.mmjpg.com' &#125;# 保存地址path = 'D:/mmjpg/'home_url = 'http://www.mmjpg.com'home_page = 'http://www.mmjpg.com/home/'# 爬取网站的最大page/也可以从网站直接得到def getMax_page(home_url): try: # 爬取home_url html = requests.get(home_url, headers = header, timeout=30) # 状态码 html.raise_for_status() # 设置编码格式 html.encoding = html.apparent_encoding except: return home_url + " html爬取失败！" # 解析html.text /使用 lxml 解析器 soup = BeautifulSoup(html.text, 'lxml') return soup.find('div', 'page').find('a', 'last')['href'].split('/')[-1]# 获取每套图最大pagedef getMax_pic_page(href): try: html = requests.get(href,headers = header) html.raise_for_status() html.encoding = html.apparent_encoding except: return url + " html爬取失败！" soup = BeautifulSoup(html.text, 'lxml') return int(soup.find('div', class_ = 'page').find_all('a')[-2].text)# 对网站的每页的套图进行一一爬取def craw_pic(max_page): # 遍历全站page for n in range(1, int(max_page) + 1): # 如果page是首页url='http://www.mmjpg.com' if n == 1: url = 'http://www.mmjpg.com' # 否则就是 home_page + str(n) else: url = home_page + str(n) try: html = requests.get(url, headers = header, timeout = 30) html.raise_for_status() html.encoding = html.apparent_encoding except: return url + " html爬取失败！" soup = BeautifulSoup(html.text, 'lxml') # 获得套图的img标签 all_img = soup.find('div', class_='pic').find('ul').find_all('span', class_='title') # 遍历img标签 for a in all_img: # 获得套图标题 title = a.a.get_text() if(title != ''): print('开始爬取：' + title) # win 不能创建带？ 的目录 if(os.path.exists(path + title.strip().replace('?', ''))): print('目录已存在') flag = 1 else: # 创建文件夹 os.makedirs(path + title.strip().replace('?', '')) flag = 0 # 进入目标文件夹 os.chdir(path + title.strip().replace('?', '')) # 得到套图首图url href = a.a['href'] if(flag == 1 and len(os.listdir(path + title.strip().replace('?', '')))): print('已经保存完毕，跳过') continue # 遍历套图的url for num in range(1, getMax_pic_page(href) + 1): pic_page = href + '/' + str(num) try: html = requests.get(pic_page, headers = header, timeout = 30) html.raise_for_status() html.encoding = html.apparent_encoding except: return href + ' html爬取失败！' soup = BeautifulSoup(html.text, 'lxml') pic_url = soup.find('div', class_='content').find('a').img['src'] print('正在爬取：' + pic_url) # 图片的名称 file_name = pic_url.split('/')[-1] imghtml = requests.get(pic_url, headers = header) f = open(file_name, 'wb') # 保存图片 f.write(imghtml.content) # 关闭图片 f.close() print('爬取完成：' + title) if n == max_page: print('全站爬取完成') if __name__ == "__main__": max_page = getMax_page(home_url) craw_pic(max_page) ''' # 多线程 pool = Pool(processes=cpu_count()) try: print("开始爬取") pool.map(craw_pic, max_page) print("爬取结束！") except Exception as e: # 失败后睡眠30s time.sleep(30) print("开始爬取") pool.map(craw_pic, max_page) print("爬取结束！") ''' 参考]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python Craw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java访问文件夹]]></title>
    <url>%2F2018%2F02%2F16%2Fjava-FileClass%2F</url>
    <content type="text"><![CDATA[具体思路：一用File类，获取需要访问的文件，二创建getFile(File file)方法判断是否存在该文件，不存在直接return,存在打印文件名称，三判断参数是否为文件夹，是则打印其大小，四递归调用。优化分层：getFile方法增加div参数，用来定义文件的层级，分层功能写在打印名称之前，优化统计：定义静态全局变量sum。 代码：12345678910111213141516171819202122232425262728293031323334353637383940import java.io.File;public class testFile &#123; static long sum = 0; public void getFile(File file,int div) &#123; //判断是否存在该文件 if(file == null) &#123; return; &#125; //打印层次 for(int i = 0; i &lt; div; i++) &#123; System.out.print("\t"); &#125; //打印名称 System.out.print(file.getName()); //判断参数是否为文件夹 if(!file.isDirectory()) &#123; //是文件就打印文件的大小(字节) System.out.println("\t"+file.length() + "字节"); //计算总文件大小 sum = sum+file.length(); return; &#125; //递归调用 System.out.println(); File[] fils = file.listFiles(); for(int i = 0; i &lt; fils.length; i++) &#123; getFile(fils[i],div + 1); &#125; &#125; public static void main(String[] args) &#123; File file = new File("F:\\python文件"); testFile tf = new testFile(); tf.getFile(file,0); System.out.println("总文件大小："+sum+"字节"); &#125;&#125; 运用结果： 12345678910111213141516171819202122232425python文件 lover-time.html 2307字节 mzitu.html 26922字节 pygame1.py 276字节 python day_01 first.py 3179字节 frest.py 3568字节 second.py 179字节 test.py 1074字节 third.py 266字节 three.py 2684字节 day_02 first.py 1843字节 hdf myfile.txt 11字节 myfile1.txt 0字节 myfile3.txt 7字节 second.py 1446字节 新建文本文档 (2).txt 0字节 新建文本文档.txt 0字节 python网络爬虫与信息提取 china_unwocity.py 7413字节 requstes.py 1618字节总文件大小：52793字节]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习十一]]></title>
    <url>%2F2018%2F01%2F25%2Fpython%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[文件操作 文件操作1.open() 打开或者创建一个文件 格式：open(&apos;文件路径&apos;，&apos;打开模式&apos;) 返回值：文件io对象 打开模式一共N种： w模式： 写模式write 文件不存在时会创建文件，如果文件已存在则清空文件 r模式： 读模式read 文件不存在就报错，存在则准备读取文件 a模式： 追加模式append 文件不存在则新建，文件存在则在文件末尾追加内容 x模式： 抑或模式xor 文件存在则报错，文件不存在则新建文件 b模式： 二进制模式： 辅助模式不能单独使用 +模式： 增强模式plus: 也是辅助模式不能单独使用 123456789101112131415161718192021222324252627282930313233343536373839404142# w模式 每次打开都清空文件内容fp = open(&quot;myfile.txt&quot;,&quot;w&quot;)result = fp.write(&quot;qwwerty&quot;)fp.close()# r模式 只读fp = open(&quot;myfile.txt&quot;,&quot;r&quot;)result = fp.read()fp.close()print(result)&apos;&apos;&apos;结果如下：qwwerty&apos;&apos;&apos;# a模式 原有文件内容上追加新内容fp = open(&quot;myfile.txt&quot;,&quot;a&quot;)result = fp.write(&quot;1234&quot;)fp.close()&apos;&apos;&apos;文件内容如下：qwwerty1234&apos;&apos;&apos;&apos;&apos;&apos;# x模式 抑或模式 文件存在则报错，文件不存在则新建文件 fp = open(&quot;myfile3.txt&quot;,&quot;x&quot;)result = fp.write(&quot;qwwerty&quot;)fp.close()&apos;&apos;&apos;# b模式fp = open(&apos;myfile.txt&apos;,&apos;rb&apos;) #b 二进制模式 binary,辅助使用，不能单个使用result = fp.read()print(result) 2.readline() 读取一行文件 格式：文件io对象.readline() 返回值：一行内容的字符串 格式：文件io对象.readline(字符长度) 返回值：一行内容的字符串 注意：字符长度 &lt; 当前内容，则读取指定长度的字符串，并且一次再读取还是这个一行中获取没有读取内容。 字符长度 &gt;= 当前行内容，直接读取当前行 3.readlines() 将文件中的内容读取到序列当中 格式：文件io对象.readlines() 返回值：列表 格式：文件io对象.readlines(字符长度) 返回值：列表 注意：读取的行数由字符长度决定，如果字符长度读取了N行后，还剩下没有读取，则直接读取下一行进来 4.writelines() 将序列写入文件中 格式：文件io对象.writelines(序列) 返回值：None 5.truncate() 字符串截取操作 格式：文件io对象.truncate(字节长度) 返回值：截取的字节长度 6.tell() 查看当前指针(光标)的位置 7.seek() 调整指针的位置 格式：文件io对象.seek(N) 将指针直接调整到N的位置，从头计算第N个位置 返回值：指针的位置 格式：文件io对象.seek(偏移位置，参考点方式) 返回值：指针的位置 参考点方式： 0 从文件的最开头计算偏移 1 从文件的当前指针位置开始计算偏移 2 从文件末尾开始计算偏移 os模块os 操作系统的简称（对操作系统进行操作） 导入os模块 import os 1.os模块的函数 getcwd() 获取当前工作目录 格式：os.getcwd() 返回值:路径字符串 chdir() 修改当前工作目录 格式：os.chdir() 返回值：None listdir() 获取指定文件夹中的所有文件和文件夹组成的列表 格式：os.listdir(目录路径) 返回值：目录中内容名称的列表 mkdir() 创建一个目录/文件夹 格式：os.mkdir(目录路径) 返回值：None rmdir() 删除一个目录/文件夹(必须空文件) 格式：os.rmdir(目录路径) 返回值：None makedirs() 递归创建目录 格式：os.makedirs(c:/d/c/f)(c:/d,c:d/c 都不存在) 返回值：None removedirs() 递归删除目录 格式：os.removedirs(c:d/c/f)(c:/d/,c:d/c,c:d/c/f 都必须为空) 返回值：None rename() 修改文件和文件夹 格式:os.rename(源文件或文件夹，目标文件或文件夹) 返回值：None stat 获取文件信息 格式：os.rename(文件路径) 返回值：包含文件信息的元组 system() 执行系统命令 格式：os.system(系统命令) 返回值：整型 注意：慎用！ getenv() 获取系统环境变量 格式：os.getenv(环境变量名) 返回值：字符串 putenv() 增加系统环境变量 格式：os.putenv(环境变量名称，值) 返回值：无 exit() 退出当前执行命令，直接关闭当前操作 格式：exit() 返回值：无 os.environ 可以直接获取所有环境变量的信息组成的字典，如果希望更改环境变量，并且可以查询得到，就需要对os.environ进行操作 os.path 代表一个子模块 os.curdir 表示当前目录 os.pardir 表示上一层文件夹的路径 os.name 当前系统的内核名称 win -&gt; nt linux/unix -&gt; posix os.sep 当前系统的路径分割体符号 win -&gt; \ linux/nuin -&gt; / os.extsep 当前系统中文件名和后缀之间的分割符号，所有系统都是 os.linesep os.linesep 当前系统的换行符号 win -&gt; \r\n linux/unix -&gt; \n os函数 abspath() 将一个相对路径转化为绝对路径 格式：os.path.abspath(相对路径) 返回值：绝对路径字符串 basename() 获取路径中的文件夹或者文件名称（只要路径的最后一部分） dirname() 获取路径中的路径部分（出去最后一部分） 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习十]]></title>
    <url>%2F2018%2F01%2F24%2Fpython%E5%AD%A6%E4%B9%A0%E5%8D%81%2F</url>
    <content type="text"><![CDATA[列表推导式 列表专有函数 元组成员检测 元组中的序列函数 元组的推导式 元组的函数 字典创建 字典专有函数 集合专有函数 列表推导式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&quot;&quot;&quot;# 简单的列表推导式list1 = [&apos;小工&apos;,&apos;小明&apos;,&apos;小丽&apos;,&apos;小敏&apos;,&apos;小国&apos;]result = [&apos;@&apos; + i + &apos;@&apos; for i in list1]print(result)&apos;&apos;&apos;结果如下：[&apos;@小工@&apos;, &apos;@小明@&apos;, &apos;@小丽@&apos;, &apos;@小敏@&apos;, &apos;@小国@&apos;]&apos;&apos;&apos;# 带有判断条件的列表推导式list1 = [12,23,4,5,6,74,]result = [i for i in list1 if i % 2 ==0]print(result)&apos;&apos;&apos;结果如下：[12, 4, 6, 74]&apos;&apos;&apos;# 多个列表的推导式list1 = [&apos;小工&apos;,&apos;小明&apos;,&apos;小丽&apos;,&apos;小敏&apos;,&apos;小国&apos;]list2 = [&apos;吃饭&apos;,&apos;读书&apos;,&apos;写作业&apos;,&apos;想人&apos;,&apos;上班&apos;]result = [i + &apos;=&gt;&apos; + j for i in list1 for j in list2 ]print(result)&apos;&apos;&apos;结果如下:[&apos;小工=&gt;吃饭&apos;, &apos;小工=&gt;读书&apos;, &apos;小工=&gt;写作业&apos;, &apos;小工=&gt;想人&apos;, &apos;小工=&gt;上班&apos;,&apos;小明=&gt;吃饭&apos;, &apos;小明=&gt;读书&apos;, &apos;小明=&gt;写作业&apos;, &apos;小明=&gt;想人&apos;, &apos;小明=&gt;上班&apos;,&apos;小丽=&gt;吃饭&apos;, &apos;小丽=&gt;读书&apos;, &apos;小丽=&gt;写作业&apos;, &apos;小丽=&gt;想人&apos;, &apos;小丽=&gt;上班&apos;,&apos;小敏=&gt;吃饭&apos;, &apos;小敏=&gt;读书&apos;, &apos;小敏=&gt;写作业&apos;, &apos;小敏=&gt;想人&apos;, &apos;小敏=&gt;上班&apos;,&apos;小国=&gt;吃饭&apos;, &apos;小国=&gt;读书&apos;, &apos;小国=&gt;写作业&apos;, &apos;小国=&gt;想人&apos;, &apos;小国=&gt;上班&apos;]&apos;&apos;&apos;# 多个列表推导式，带有判断条件1num1 = [2,4,6,8,]num2 = [4,16,36,64]result = [i + y for i in num1 for y in num2 if y == i*i]print(result)&apos;&apos;&apos;结果如下 ：[6, 20, 42, 72]&apos;&apos;&apos;&quot;&quot;&quot;# 多个列表推导式，带有判断条件1list1 = [&apos;小工&apos;,&apos;小明&apos;,&apos;小丽&apos;,&apos;小敏&apos;,&apos;小国&apos;]list2 = [&apos;吃饭&apos;,&apos;读书&apos;,&apos;写作业&apos;,&apos;想人&apos;,&apos;上班&apos;]result = [i + &apos;=&gt;&apos; + j for i in list1 for j in list2 if list1.index(i) == list2.index(j)]print(result)&apos;&apos;&apos;结果如下：[&apos;小工=&gt;吃饭&apos;, &apos;小明=&gt;读书&apos;, &apos;小丽=&gt;写作业&apos;, &apos;小敏=&gt;想人&apos;, &apos;小国=&gt;上班&apos;]&apos;&apos;&apos; 列表专有函数 append() 向列表中的末尾添加新元素 格式：列表.append(值) 返回值：None 注意：新添加的值在列表的末尾，该函数直接操作原有列表 clear() 清空列表中所有元素 格式：列表.clear() 返回值：None copy() 复制列表 格式: 列表.copy() 返回值:新的列表 count() 计算某个元素出现的次数 格式：列表.count(值) 返回值：整数 extend() 将一个列表继承另一个列表 格式：列表.extend(序列) 返回值：None 注意：直接改变原有列表 index() 获取某个在列表中的索引 格式：列表.index(值) 返回值:整数 注意：值不存在与列表时抛出异常错误！ pop() 在列表中移除一个元素 格式：列表.pop([牵引]) 返回值：无 注意：没有指定索引，默认移除最后一个元素 remove() 移除指定的值 格式：列表.remove(值) 返回值：元 注意：如果有索引的清空下推荐使用pop移除，效率比remove高 reverse() 列表反转操作 格式:列表.reverse() 返回值：None sort() 列表排序 格式:列表.sort() 按照从小到大排序(数字) 格式：列表.sort(reverse = True) 按照从大到小排序(数字) 格式：列表.sort(key = 函数) 对值进行指定的函数处理之后再小到大排序 格式：列表.sort(key = 函数,reverse = True) 对值进行指定的函数处理之后再大到小排序 返回值：None 注意：直接改变原有列表 12345678list1 = [&apos;s&apos;,&apos;E&apos;,&apos;A&apos;,&apos;d&apos;]list1.sort(key = str.upper)print(list1)&apos;&apos;&apos;结果如下：[&apos;A&apos;, &apos;d&apos;, &apos;E&apos;, &apos;s&apos;]&apos;&apos;&apos; 元组成员检测格式： 值 in 元组 返回值：布尔值 作用：检测一个值是否在元组当中 格式： 值 not in 元组 返回值：布尔值 作用：检测一个值是否不在元组当中 12345678tuple1 = (&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;,&apos;赵六&apos;)result = &apos;张三&apos; in tuple1# &apos;张三&apos; not in tupel1print(result)&apos;&apos;&apos;结果如下：True&apos;&apos;&apos; 元组中的序列函数 len() 获取元组的长度 max() 获取元组中的最大值 min() 获取元组中的最小值 tuple() 创建空元组或者将其他序列转化为元组类型 元组的推导式方法同列表推导式 元组的函数 index() 获取指定值在元组中的索引值 格式:元组.index(值) 返回值:整数 count() 计算某个值在元组中出现的次数 格式：元组.count(值) 返回值：整数 ## 字典创建 格式： 变量：dict(zip((键，键，键...),(值，值，值...))) 字典专有函数 clear() 清空字典 copy() 复制字典 fromkeys() 使用指定的序列作为创建字典 格式：字典.fromkeys(序列，值) 返回值：字典 get() 根据键获取指定的值 格式：字典.get(键[,默认值]) 返回值：如果键不存在，则使用默认值，如果 没有默认值则返回None items() 将字典的键值转化成类型似元组的形式，方便遍历 格式：字典.items() 返回值：类似元组的类型 keys() 将字典的所有键组成一个序列 格式：字典.keys() 返回值：序列 values() 将字典的所有值组成一个序列 格式：字典.values() 返回值：序列 pop() 移除字典中指定的元素 格式：字典.pop(键[,默认值]) 返回值：被移除的键对应的值 注意：如果键不存在，则报错，如果键不存在，默认值设置，则返回默认值 popitem() 移除字典中的键值对 格式：字典.popitme() 返回值：键值对组成的元组 注意：弹一个原字典就少一个，字典为空就不可以弹，会报错 setdefault() 添加一个元素 格式：字典.setdefault(键，值) 返回值：None 注意：添加是键存在则不进行任何操作，键不存在则添加，添加是不写值，默认None值 update() 格式：字典.update(键 = 值) 返回值：None 集合专有函数 add() 向集合中添加一个元素 格式：集合.add(值) 返回值：None 注意:直接改变原有集合 pop() remove() clear() copy() discard() 删除集合中的某个元素 格式：集合.discard(值) 返回值：None 注意：直接改变原有集合 remove移除非成员值会报错，discard移除非成员不会报错 difference() 差集 difference_update() 差集更新，将差集赋值给第一人集合 intersection() 交集 intersection_upate() 交集更新 union() 并集 update() 并集更新 issuperset() 检测一个集合是不是另一个集合的超集 格式：集合1.issuperset(集合2) 返回值：布尔值 issubset() 检测一个集合是不是另外一个集合的字节 格式：集合1.issubset(集合2) 返回值：布尔值 isdisjoint() 检测2个集合是否相交 格式：集合1.isdisjoint(集合2) 返回值：布尔值 symmetric_difference() 对称差集操作 格式：集合1.symmetric_difference(集合2) 返回值：集合 操作：将集合1和集合2不相交的部分取出组成的新的集合 symmetric_difference_update() 对称差集更新操作 冰冻集合/固定集合 frozenset12345678910111213# 创建空的冰冻集合fset = frozenset()print(type(fset))print(fset)# 创建具有元素的集合fset = frozenset([&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;,&apos;赵六&apos;])print(type(fset))print(fset)# 冰冻集合，不能修改 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习九]]></title>
    <url>%2F2018%2F01%2F23%2Fpython%E5%AD%A6%E4%B9%A0%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[string模块 ascill 数学模块 模块提供的常见值 随机模块 string模块import string ascill_letters 获取所有ascilll码中字母字符的字符串(包含大写和小写) ascill_uppercase 获取所有ascill码中的大写英文字母 ascill_lowercase 获取所有ascill码中的ihpg英文字母 digits 获取所有的10进制数字字符 octdigits 获取所有的8进制数字字符 hexdigits 获取所有16进制数字字符 printable 获取所有可以打印的字符 whitespace 获取所有空白字符 punctuation 获取所有的标点符号 ascii美国标准信息交换代码 定制了128个常用字符，主要是英文，数字，标点符号及键盘中其他按键对应的整数值。 python中与ascill码相关的两个函数： chr() 将ascill编码转化为字符 格式：chr(ascill码) 返回值：字符 ord() 将字符转化为对应的ascii码 格式：ord(字符) 返回值：ascill码 数学模块import math ceil() 向上取整操作 格式：math.ceil(数值) 返回值：整型 floor() 向下取整操作 格式：math.floor(数值) 返回值：整型 round() 四舍五入操作 格式：round(数值) 返回值：整数 注意：该函数不在math模块当中。 pow() 计算一个数值的N次方 格式：math.pow(底数，幂) 返回值：浮点类型 注意：该操作相当于**运算结果为浮点型 sqrt() 开平方 格式：math.sqrt(数值) 返回值：浮点型 fabs() 对一个数值获取其绝对值操作 格式：math.fabs(数值) 返回值：浮点数 abs() 对一个数值获取其绝对值操作 格式：abs(数值) 返回值：可能是整数能浮点数 注意：abs() 它是内建函数，同时返回值根据原类型决定 modf() 将一个浮点拆成整数和小数部分组成的元组 格式：math.modf(数值) 返回值：元组 （小数部分，整数部分） copysign() 将第二个的正负号复制给第一个数 格式：math.copysign(值1，值2) 返回值：值1 符号是值2的正负 fsum() 将一个序列的数值进相加求和 格式：math.fsum(序列) 返回值：浮点数 sum() 将一个序列的数值进行相加求和 格式：sum(序列) 返回值：数值类型 模块提供的常见值pi 圆周率 3.14159265358793 e 自然数 2.718181828459045 随机模块import random random() 获取0-1之间的随机小数包含0不包含1 格式：random.random() 返回值：浮点数 choice() 随机获取列表中的值 格式：random.choice(序列) 返回值：序列中的某个值 shuffle() 随机打乱序列 格式：random.shffle(序列) 返回值：打乱顺序的序列 randrage() 获取指定范围内指定间隔的随机整数 格式：random.ranges(开始值，结束值[,间隔值]) 返回值：整数 uniform() 随机获取指定范围内的所有数值包含小数 格式：random.uniform(开始值，结束值) 返回值：随机返回范围内的所有数值（浮点型） 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习八]]></title>
    <url>%2F2018%2F01%2F22%2Fpython%E5%AD%A6%E4%B9%A0%E5%85%AB%2F</url>
    <content type="text"><![CDATA[中国大学排名定向爬虫 中国大学排名定向爬虫1234567891011121314151617181920212223242526272829303132333435#CrawUnivRankingA.pyimport requestsfrom bs4 import BeautifulSoupimport bs4 def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot;def fillUnivList(ulist, html): soup = BeautifulSoup(html, &quot;html.parser&quot;) for tr in soup.find(&apos;tbody&apos;).children: if isinstance(tr, bs4.element.Tag): tds = tr(&apos;td&apos;) ulist.append([tds[0].string, tds[1].string, tds[3].string]) def printUnivList(ulist, num): tplt = &quot;&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;&quot; print(tplt.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;,chr(12288))) for i in range(num): u=ulist[i] print(tplt.format(u[0],u[1],u[2],chr(12288))) def main(): uinfo = [] url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos; html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 20) # 20 univsmain() 结果如下： 12345678910111213141516171819202122======== RESTART: F:\python文件\MOCC_python网络爬虫与信息提取\china_unwocity.py ======== 排名 学校名称 总分 1 清华大学 95.9 2 北京大学 82.6 3 浙江大学 80 4 上海交通大学 78.7 5 复旦大学 70.9 6 南京大学 66.1 7 中国科学技术大学 65.5 8 哈尔滨工业大学 63.5 9 华中科技大学 62.9 10 中山大学 62.1 11 东南大学 61.4 12 天津大学 60.8 13 同济大学 59.8 14 北京航空航天大学 59.6 15 四川大学 59.4 16 武汉大学 59.1 17 西安交通大学 58.9 18 南开大学 58.3 19 大连理工大学 56.9 20 山东大学 56.3 中国大学排名定向爬虫 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习七]]></title>
    <url>%2F2018%2F01%2F22%2Fpython%E5%AD%A6%E4%B9%A0%E4%B8%83%2F</url>
    <content type="text"><![CDATA[requests库 beautiful soup库 基于bs4库的HTML内容的遍历方法 简写形式 find的扩展方法 requests库1.安装requests库 打开cmd -&gt; pip install requests 2.操作实例 12345678910# 引入requests库import requests# 设置爬取的网页r = requests.get(&quot;http://www.baidu.com&quot;)# 打印爬取状态码print(r.status_code)# 设置编码格式 r.encoding = &quot;utf-8&quot;# 打印爬取网页的html代码print(r.text) 3.requests库的七个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应HTTP的HEAD requests.post() 向HTML页面提交POST请求的方法，对应HTTP的POST requests.put() 向HTML页面提交PUT请求的方法，对应HTTP的PUT requests.patch() 向HTML页面提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应于HTTP的DELETE 4.get方法 格式： r = requests.get(url,params = None,**kwargs) | | | | Response Requset url:拟获取页面的url链接 params:url中额外参数，字典或字节流格式，可选 **kwargs:12个控制访问的参数 5.Response对象的属性 属性 说明 r.status_code HTTP请求的返回状态，200表示连接成功，404表示失败 r.text HTTP响应内容的字符串形式，即，url对应的页面内容 r.encoding 从HTTP headr 中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式(备选编码方式) r.content HTTP响应内容的二进制形式 r.encoding：如果header中不存在charset，则认为编码为ISO-8859-1 r.apparent_encoding:根据页面内容分析出的编码方式 6.理解Resquests库的异常 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败，拒绝连接等 requests.HTTPError HTTP错误异常 requests.URLRequird URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 r.raise_for_status() : 如果不是200，产生异常requests.HTTPerror 1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status()#如果状态不是200，引发HTTPError异常 r.encoding = r.apparent_encoding return r.text except: return &quot;产生异常&quot;if __name__ == &quot;__main__&quot;: url = &quot;//www.baidu.com&quot; print(getHTMLText(url)) beautiful soup库beautiful soup库是解析，遍历，维护“标签树”的功能库， 1.安装pip install beautifulsoup4 2.测试 1234567891011import requestsr = requests.get(&quot;http://python123.io/ws/demo.html&quot;)print(r.status_code)print(r.text)dome = r.textfrom bs4 import BeautifulSoupsoup = BeautifulSoup(dome , &quot;html.parser&quot;) # html.parser 解析器print(soup.prettify()) 3.Beautiful soup库解析器 解析器 使用方法 条件 bs4的HTML解析器 BeautifulSoup(mk,”html.parser”) 安装bs4库 lxml的html解析器 BeautifulSoup(mk,”lxml”) pip install lxml lxml的XML解析器 BeautifulSoup(mk,”html.parser”) pip install lxml html5lib的解析器 BeautifulSoup(mk,”html5lib”) pip install html5lib 4.Beautiful Soup类的基本元素 基本元素 说明 Tag 标签，最基本的信息组织单元分别用&lt;&gt;和&lt;/&gt;标明开头和结尾 Name 标签的名字,…的名字是’p’,格式：.name Attributes 标签的属性，字典形式组织，格式：.attrs NavigableString 标签内非属性字符串，&lt;&gt;…&lt;/&gt;中字符串，格式：.string comment 标签内字符串的注释部分，一种特殊的Comment类型 基于bs4库的HTML内容的遍历方法1.标签树的下行遍历 属性 说明 .contents 子节点的列表，将所有儿子节点存入列表 .children 子节点的迭代类型，与.contents类似，用于循环遍历儿子节点 .descendants 子孙节点的迭代类型，包含所有子孙节点，用于循环遍历 # 遍历儿子/子孙节点 for child in soup.body.children: print(child) 2.标签树的上行遍历 属性 说明 .parent 节点的父亲标签 .parents 节点先辈标签的迭代类型，用于循环遍历先辈节点 3.标签树的平行遍历 属性 说明 .next_sibling 返回按照HTML文本顺序的下一个平行标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签 4.&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs) 返回一个列表类型，存储查找的结果 name:对标签名称的检索字符串 attrs:对标签属性值的检索字符串，可标注属性检索 recursive:是否对子孙全部检索，默认True string:&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串 **kwargs: 简写形式(..) &lt;==&gt; .find_all(…)soup(..) &lt;==&gt; soup.find_all(..) find的扩展方法 方法 说明 &lt;&gt;.find() 搜索且只返回一个结果，字符串类型，同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索.，字符串类型，同.find_all()参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果，字符串类型，同.find_all()参数 &lt;&gt;.find_next_silbings() 在后续平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_next_silbing() 在后续平行节点中返回一个结果，返回字符串类型，同.find_all()参数 &lt;&gt;.find_preious_siblings() 在前序平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_preious_sibling() 在前序平行节点中返回一个结果，返回字符串类型，同.find_all()参数 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习六]]></title>
    <url>%2F2018%2F01%2F17%2Fpython%E5%AD%A6%E4%B9%A0%E5%85%AD%2F</url>
    <content type="text"><![CDATA[nonlocal lambda表达式 递归函数 字符串操作 字符串函数 format 字符格式化操作 nonlocalnonlocal关键字的意义，不是局部变量，当然它也不是全局变量，通常用于内部函数中使用外部函数的局部变量。 注意： 1.如果内部函数想使用全局变量，那么应该使用global声明变量(函数最外层的全局变量) 2.如果内部函数使用的是外部函数的局部变量，那么应该使用nonlocal声明 123456789101112131415# 声明一个外部函数def outer(): # 声明一个变量(肯定不是全局变量) x = 5 # 声明一个内部函数 def inner(): nonlocal x # 声明x不是局部变量 x += 9 print(x) # 调用函数 inner()# 调用outerouter() lambda表达式lambda表达式是一种简洁的函数，该表达不是正常的函数结构，而是属于表达式的类型。 基本格式： lambda 参数，参数...：函数功能代码 带分支格式： lambda 参数，参数...:值1 if 条件表达式 else 值2 调用函数格式： lambda 参数，参数..:其他函数(...) lambda表达式的优缺点： 优点： 1.书写简单不需要def关键字 2.不需要起函数名(匿名函数) 3.看起来高大上 缺点： 1.lambda表达式功能受限，无法使用循环和多项分支复杂的操作，不适合lambda表达式 123456789101112# 声明一个lamdba表达式1mylamb = lambda x,y:x+y#相当于一个函数#def func(x,y):# return x+yresult = mylamb(3,5)print(result) 123456# 声明一个lamdba表达式2mylamb = lambda name = &apos;a&apos;:&apos;aqqje&apos; if name == &apos;a&apos; else &apos;yjgmy&apos;result = mylamb()print(result) 1234567# 声明一个lamdba表达式调用函数mylamb = lambda x:type(x)result = mylamb(10)print(result) 递归函数在函数内调用当前函数本身的函数就是递归函数 12345678910111213141516# 递归函数def digui(num): print(num) # 判断条件，不改变num if num &gt; 0: digui(num - 1) else: print(&apos;===============&apos;) print(num) digui(3) 结果如下:1234567893210===============012+ 字符串操作+ 字符串连接操作 * 字符复制操作 [] 字符串索引操作，通过索引访问指定位置的字符，索引从0开始 [::] 字符串取片操作 完整格式： [开始索引:结束索引:间隔值] [:结束索引] 从开头到指定位置之前截取 [开始索引:] 从指定位置截取到最后 [开始索引:结束索引] 从开始索引截取到结束索引之前(不包含结束位置) [:] 截取整个字符串 r&apos;字符串&apos; 元字符串，所有字符串的转义字符不会转义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# + 字符串连接操作str1 = &apos;你好，&apos;str2 = &apos;旧时光&apos;result = str1 + str2print(result)# 你好，旧时光# * 字符复制操作strone = &apos;★★★★★★★★\n&apos;strten = strone * 10print(strten)&apos;&apos;&apos;★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★&apos;&apos;&apos;# 字符串索引操作str1 = &apos;QWERTYUIOPASDFGHJKLZXCVBNM&apos;print(str1[23])# B# 字符串取片操作 字符串[开始索引:结束索引:间隔值]str1 = str1 = &apos;QWERTYUIOPASDFGHJKLZXCVBNM&apos;# 从开头到指定位置之前截取print(str1[:6])QWERTY# 从指定位置截取到最后print(str1[21:])# CVBNMprint(str1[-5:])# CVBNM# 从开始索引截取到结束索引之前(不包含结束位置)print(str1[7:12])# IOPAS# 截取整个字符串print(str1[:])# QWERTYUIOPASDFGHJKLZXCVBNM# 按照指定间隔数截取字符串print(str1[:25:2])# QETUOADGJLXVN 字符串函数1.capitalize() 字符串首字母大写 格式：字符串.capitalize() 返回值：新字符串 2.title() 将每个单词首字母大写 格式：字符串.title() 返回值：新字符串 3.upper() 将所有字母大写 格式：字符串.upper() 返回值：新字符串 4.lower() 将所有字母小写 格式：字符串.lower() 返回值：新字符串 5.swapcase() 大小写互换 格式：字符串.swapcase() 返回值：新字符串 6.len() 计算字符串的长度 格式：len(字符串) 返回值：整型 7.count() 计算指定字符串出现的次数 格式:字符串.count(查找字符串[,开始索引[,结束索引]]) 返回值：整型 8.find() 查找指定字符串第一次出现的位置 格式：字符串.find(查找字符串[,开始索引[,结束索引]]) 返回值：整型 找不到返回 -1 9.index() 查找指定字符串第一次出现的位置 格式：字符串.index(查找字符串[,开始索引[,结束索引]]) 返回值：整型 找不到抛出错误！ 10.startwith() 检测字符串是否以指定的字符串开头 格式：字符串.startwith(查找字符串) 返回值：布尔值 11.endswith() 检测字符串是否以指定的字符串结尾 格式：字符串.endswith(查找字符串) 返回值：布尔值 12.isupper() 检测一个字符串中的英文是否都是大写字母，符号不算 格式：字符串.isupper() 返回值：布尔值 13.islower() 检测一个字符串中的英文是否都是小写字母，符号不算 格式：字符串.islower() 返回值：布尔值 14.isalsum() 检测字符串是否由数字，字母和文字等组成 格式：字符串.isalum() 返回值：布尔值，汉字当作普通字符处理，没有标点和特殊字符就是真，空字符串为False 15.isalpha() 检测字符串是否由字母和文字等组成 格式：字符串.isalpha() 返回值：布尔值，汉字当作普通字符处理，空字符串为False 16.isdigit() 检测字符串是否由纯数字组成 (十进制) 格式：字符串.isdigit() 返回值：布尔值 17.isspace() 检测字符串是否空白字符组成 格式：字符串.isspace() 返回值：布尔值 18.istitle() 检测是否符合标题要求 （整数） 格式：字符串.istitle() 返回值：布尔值 19.isnumeric() 检测是否是数值字符串 格式：字符串.isnumeric() 返回值：布尔值 20.isdecimal() 检测字符串是否是纯数值字符串组成 格式：字符串.isdecimal() 返回值：布尔值 21.split() 使用指定的字符串切割字符串 格式：字符串，split(切割指定字符串) 返回值：列表 22.splitlines() 将字符串按照换行位置进行切割操作 格式：字符串.splitlines() 返回值：列表 23.join 将列表中的内容按照指定字符连接成一个字符串 格式：连接字符串。join(列表) 返回值：字符串 24.zfill 在原有字符串长度不足指定长度，用0填充 格式：字符串.zfill(指定字符串长度) 返回值：字符串 不足的长度使用0填充，原来的字符串内容靠右 26.center() 指定字符串长度，并且使得元字符串内容剧中，其余位置使用指定字符串填充 格式：字符串.center(指定字符串长度[,&apos;指定字符串&apos;]) 返回值：字符串 填充字符默认空格，可以指定其他 27.ljust() 指定字符串长度，并且使得元字符串内容靠左，其余位置使用指定字符串填充 格式：字符串.ljust(指定字符串长度[,&apos;指定字符串&apos;]) 返回值：字符串 填充字符默认空格，可以指定其他 28.rjust() 指定字符串长度，并且使得元字符串内容靠右，其余位置使用指定字符串填充 格式：字符串.rjust()(指定字符串长度[,&apos;指定字符串&apos;]) 返回值：字符串 填充字符默认空格，可以指定其他 29.strip() 去掉左右两侧的指定字符，默认空格 格式：字符串.strip([指定字符]) 返回值:字符串 30.lstrip() 去掉左侧的指定字符，默认空格 格式：字符串.lstrip()([指定字符]) 返回值:字符串 31.rstrip() 去掉右侧的指定字符，默认空格 格式：字符串.rstrip()([指定字符]) 返回值:字符串 32.maketrans() 制作用于字符替换的映射表 格式：字符串.maketrans(&apos;查找字符&apos;，&apos;替换字符&apos;) 两个字符必须长度相等 返回值：字典 33.translate() 进行字符串替换操作 格式：字符串.translate(映射表) 返回值：字符串 替换之后的字符串 format 字符格式化操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 方法1 位置参数# 非关键字参数str1 = &apos;&#123;&#125;位和&#123;&#125;位操作系统是指：CPU一次处理数据的能力是&#123;&#125;位还是&#123;&#125;位&apos;result1 = str1.format(&apos;32&apos;,&apos;64&apos;,&apos;32&apos;,&apos;64&apos;)print(result1)# 多次利用参数str2 = &apos;&#123;0&#125;位和&#123;1&#125;位操作系统是指：CPU一次处理数据的能力是&#123;0&#125;位还是&#123;1&#125;位&apos;result2 = str2.format(&apos;32&apos;,&apos;64&apos;)print(result2)# 关键字参数str3 = &apos;&#123;(threetwo&#125;位和&#123;sixforth&#125;位操作系统是指：CPU一次处理数据的能力是&#123;(threetwo&#125;位还是&#123;sixforth&#125;位&apos;result3 = str3.format(threetwo = &apos;32&apos;,sixforth = &apos;64&apos;)print(result3) # 方法2 通过下标str4 = &apos;&#123;0[0]&#125;位和&#123;0[1]&#125;位操作系统是指：CPU一次处理数据的能力是&#123;0[0]&#125;位还是&#123;0[1]&#125;位&apos;result4 = str4.format([&apos;32&apos;,&apos;64&apos;])print(result4)str5 = &apos;&#123;0[t]&#125;位和&#123;0[f]&#125;位操作系统是指：CPU一次处理数据的能力是&#123;0[0]&#125;位还是&#123;0[1]&#125;位&apos;result5 = str5.format(&#123;&apos;t&apos;:&apos;32&apos;,&apos;f&apos;:&apos;64&apos;&#125;)print(result5)# 方法3 格式限定符#填充与补齐str6 = &apos;速度。重新定义&#123;:□&gt;10&#125;&apos;# 速度。重新定义□□□□□□新的高度 【靠右齐，且补满10】str6 = &apos;速度。重新定义&#123;:□&lt;10&#125;&apos;# 速度。重新定义□□□□□□新的高度 【靠左齐，且补满10】str6 = &apos;速度。重新定义&#123;:□^ 10&#125;&apos;# 速度。重新定义□□□□□□新的高度 【靠剧中齐，且补满10】result6 = str6.format(&apos;新的高度&apos;)print(result6)# 精度计算str7 = &apos;快捷快递价格表，山西省1kg&#123;:.1f&#125;&apos; # 浮点数保留1位小数result7 = str7.format(3.55777)print(result7)# 进制进制操作（默认十进制）&#123;:d&#125;str8 = &apos;&#123;:b&#125;元买了一件风衣&apos; # 转化成了二进制str8 = &apos;&#123;:o&#125;元买了一件风衣&apos; # 转化成了八进制str8 = &apos;&#123;:x&#125;元买了一件风衣&apos; # 转化成了十六进制result8 = str8.format(15)pirnt(result8)# 金融字符，逗号分隔str9 = &apos;今天上班，得了&#123;:,&#125;元&apos; # 今天上班，得了2,600,000元result9 = str.format(2600000)print(result9) 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习五]]></title>
    <url>%2F2018%2F01%2F16%2Fpython%E5%AD%A6%E4%B9%A0%E4%BA%94%2F</url>
    <content type="text"><![CDATA[函数文档 定义函数的文档 变量的作用域 内部函数 函数文档函数文档就是用来查看当前函数相关信息介绍的一个特定格式而已 查看函数文档的方法 help(函数名称) 直接输出显示函数文档的内容字符串 函数名称.__doc__ 直接输出显示函数文档的内容元字符串(转义字符不转义) 定义函数的文档def 函数名称(参数...) &apos;&apos;&apos; 在此处声明函数文档 &apos;&apos;&apos; 函数功能代码... 函数功能代码... ... 注意：函数文档的作用是函数进行说明，便于阅读和快速掌握函数的使用，通常函数文档需要具有以下信息： 函数的作用 函数的参数介绍(个数，数据类型) 函数的返回值(数据和类型) 变量的作用域变量的作用域就是指变量的有有效范围 变量按照作用范围分为2类： 全局变量： 在函数外部声明的变量就是全局（在函数内部需要global关键字才可以使用） 局部变量： 在函数内部声明的变量就是局部变量 全局变量和局部变量的有效范围： 1.全局变量在函数外部也可以正常使用 2.全局变量在函数内部也可以正常使用(需要global声明) 3.局部变量在函数内部可以正常使用 4.局部变量在函数外部不可以被访问 global关键字 将局部变量提升为全局变量 格式： def 函数名(): # 提升局部变量为全局变量 global 变量名 函数的其他功能代码... ... 注意：只有在函数内部使用global关键字对变量进行全局声明，该变量才是一个完整的全局变量，在函数内外可以进行任意获取修改删除等操作。 内部函数在函数内部声明的函数就是内部函数 特征： 1.内部函数的本质就是局部变量(函数就是一个变量) 2.内部函数在函数外部不可以直接调用 3.内部函数在函数内部调用必须定义在内部函数之后可以调用 闭包(函数式开发使用)想办法将局部变量引入到全局环境中可以使用，这就是闭包操作 闭包方法1： def 函数名(): 局部变量1 局部变量2 ... def 内部函数1() pass def 内部函数2() pass ... return (局部变量1，局部变量2...内部函数2...) 闭包方法2： def 函数名(): 局部变量1 局部变量2 ... def 内部函数1() pass def 内部函数2() pass ... # 获取/收集所有需要进行闭包操作的内部函数和变量 def all(): return (局部变量1，局部变量2...内部函数2...) return all 闭包的优缺点： 优点： 1.可以方便的进行函数式编程，组织程序代码 2.使用局部变量和内部函数在外部可以访问 缺点： 1.闭包操作会导致整个函数的内部环境，被长久保存，占用大量内存 闭包环境查看： \_\_closure\_\_ 用于查询当前闭包操作所使用的环境中的变量和内部函数等信息 123456789101112131415161718192021222324252627282930313233343536# 实现闭包操作1# 全局环境# 函数局部环境def py(): # 局部变量 boy = &apos;aqqje&apos; girl = &apos;yjgmy&apos; # 内部函数 def boyName(): print(boy+&apos;123456&apos;) def girlName(): print(girl+&apos;987654&apos;) # 通过return语句和容器数据将局部变量和内部函数返回 return (boy,girl,boyName,girlName)# 调用函数获取所有的返回值result = py()print(result)# 高级写法men,wemen,name1,name2 = result# 初级写法#men = result[0]#wemen = result[1]#name1 = result[2]#name2 = result[3]name2() 结果如下： 12(&apos;aqqje&apos;, &apos;yjgmy&apos;, &lt;function py.&lt;locals&gt;.boyName at 0x01DFD780&gt;, &lt;function py.&lt;locals&gt;.girlName at 0x01E5DA98&gt;)yjgmy987654 1234567891011121314151617181920212223# 实现闭包操作2# 全局环境# 函数局部环境def py(): # 局部变量 boy = &apos;aqqje&apos; girl = &apos;yjgmy&apos; # 内部函数 def boyName(): print(boy+&apos;123456&apos;) def girlName(): print(girl+&apos;987654&apos;) def getall(): return [boy,girl,boyName,girlName] return getallresult = py()print(result)allvar = result()print(allvar) 123456789101112131415161718192021222324252627# 实现闭包操作3# 全局环境allinner = None# 函数局部环境def py(): # 局部变量 global allinner boy = &apos;aqqje&apos; girl = &apos;yjgmy&apos; # 内部函数 def boyName(): print(boy+&apos;123456&apos;) def girlName(): print(girl+&apos;987654&apos;) def getall(): return [boy,girl,boyName,girlName] allinner = getall()py()n,a,b,c = allinnerprint(n)print(a)b()c() 1234567891011121314# 闭包环境查看：def demo(): x = 6 y = 3 def inner1(): pass def inner2(): pass def all(): return [y,inner1,inner2] return allbb = demo()print(bb.\_\_closure\_\_) 结果如下：1(&lt;cell at 0x01E53690: function object at 0x01346A08&gt;, &lt;cell at 0x01E53670: function object at 0x01DFD780&gt;, &lt;cell at 0x01E536D0: int object at 0x5B382AA0&gt;) 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习四]]></title>
    <url>%2F2018%2F01%2F16%2Fpython%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[函数 函数的作用 函数的定义 收集参数 多种参数混合 关于返回值问题 函数函数的英文单词： function 在计算机中称之为函数 在现实生活中称之为功能 函数是能够实现特定功能的计算机代码而已，他是一种特定的代码组结构 函数的作用1.提升代码的重复利用率，避免重复开发相同代码 2.提高程序开发效率 3.便于程序维护 函数的定义：1.基本格式： def 函数名(): 函数功能代码... 函数功能代码... ... 调用函数：函数名(): 特征：函数定义之后不会自动执行，必须在调用函数后函数才会执行 函数名的命名规则：和变量基本一样 1.推荐使用英文或者拼音，禁止使用中文 2.可以使用数字，但是不能用数字开头 3.不可以使用特殊字符，除了_ 4.函数名严格区分大小写 5.函数名必须要有意义 6.不能和系统已经存在的保留关键字冲突 7.禁止使用和系统提供函数相同的函数名 带有参数的格式： def 函数名(形参，形参...): 函数功能代码... 函数功能代码... ... 调用函数：函数名(实参，实参...): 形参：形式上的参数，声明函数时()中的参数是形参 实参：实际上的参数，调用函数时()中的参数是实参 注意:实参将值传递给形参的过程本质上就是简单的变量赋值仅此而已 1234567891011121314def myStar(maxRow,maxLine): hang = 0; while hang &lt; maxRow : lie = 0 while lie &lt; maxLine : if lie % 2 == 0 : print('★',end = '') else : print('☆',end = '') lie += 1 print('\n',end = '') hang += 1myStar(4,10) 带有默认值的参数: def 函数名(形参 = 默认值，形参 = 默认值...): 函数功能代码... 函数功能代码... ... 调用函数： 函数名() 使用函数时所有形参采用默认值操作 函数名(实参，实参...) 使用时形象的值面抛弃默认值 注意： 在此情况下使用实参值覆盖原有形参的默认值，本质上就是变量的重新赋值操作 关键字参数： def 函数名(形参 = 默认值，形参 = 默认值...): 函数功能代码... 函数功能代码... ... 调用函数：函数名(形参 = 实参，形参 = 实参...) 关键字参数就是调用函数时，在实参前面指定形参的做法，为了防止参数按照位置传递出现的错误 收集参数1.非关键字收集参数 def 函数名(*参数名)： 函数功能代码... 函数功能代码... ... 调用函数：函数名(实参，实参...) 没有数量限制 特征： 1.非关键字收集参数，在形参前添加一个*即可 2.非关键字收集参数收集实参组成一个元组 3.非关键字收集，仅收集没任何形参接受的非关键字实参 4.非关键字收集参数和普通的形参可以共存 12345678910111213141516171819202122232425262728293031323334353637## 制作一个可以计算任意数的和的函数def sum(*args): num = 0 total = 0 while num &lt; len(args): total = total + args[num] num += 1 print(total)sum(1,2,3,4,5,6)# 定义一个元组tuple1 = (2,3,4,6,22,33,4,55,)# 遍历元组for tupleCollec in tuple1: print(tupleCollec)print('\n',end = '')i = 0while i &lt; len(tuple1): print(tuple1[i]) i += 1# 检测收集参数收集的规则def myargs(no1,no2,*args): print(no1) print(no2) print(args)myargs(2,323,32,1,4,5,2,) 2.关键字收集参数 def 函数名(**参数名)： 函数功能代码... 函数功能代码... ... 调用函数： 函数名(形参 = 实参，形参 = 实参...) 没有数量限制 特征： 1.关键字收集参数，在形参前添加两个**即可 2.关键字收集参数，收集的结果组成一个字典，关键字成为的键，实参成为值 3.关键字收集参数，仅收集没有任何形参接受的关键字参数 4.关键字参数可以和普通的形参共存 12345678910# 收集关键字参数def myArgs(**args): # 打印所有 print(args) # 打印指定的 print(args['qq']) passmyArgs(ch = 'wifi',g5 = '5g',qq = '104232323' ) 结果如下：12&#123;&apos;ch&apos;: &apos;wifi&apos;, &apos;g5&apos;: &apos;5g&apos;, &apos;qq&apos;: &apos;104232323&apos;&#125;104232323 多种参数混合定义函数时尽量避免多种参数格式混合(普通参数/非关键字参数，关键字参数，非关键字收集参数，关键字收集参数) 1.普通参数(非关键字参数)和关键字参数必须在两种收集参数之前 2.非关键字收集参数，必须在关键字收集参数之前 3.如果多种参数在一起，必须注意进制参数多次赋值操作(相同赋值之后，关键字参数在此赋值！) 12345678910111213141516# 非关键字参数，关键字参数，非关键字收集参数，关键字收集参数共存'''num 非关键字参数name 关键字参数*fargs 非关键字收集参数**args 关键字收集参数'''def argsAll(num,name,*fargs,**args): print(num) print(name) print(fargs) print(args)argsAll(100,99,88,name = 'aaje',sex = '0') 结果如下： 123410099(88,)&#123;'naem': 'aaje', 'sex': '0'&#125; 关于返回值问题函数根据执行完毕是否可以得到一个结果，将函数分为2个类型： 执行过程函数：print() 函数执行完毕之后，不会有任何结果可以被接受的函数。 123456def learn1(): print('努力学习一个月')learn1()print(learn1()) 结果如下： 123努力学习一个月努力学习一个月None 具有返回值的函数：id(),type() 函数执行完毕之后，会产生一个结果，可以被变量接收或者使用的函数 格式： def 函数名(参数...) 函数功能代码... 函数功能代码... ... [return 语句] return 的特征： 1.具有return 语句的函数称为具有返回值的函数 2.return 可以为当前函数执行完毕返回一个结果，这样的函数调用可以被接受 3.return 执行之后，函数则会终止，所有return之后的语句不会执行 4.一个函数可以眉宇 多个return语句，但是一般放入分支结构当中。 5.一个函数如果需要返回多个数据，需要借助复合数据数据类型(list,tupe,set,dict)来操作即可！ 123456def learn2(): print('努力学习一年') return '程序员一个'learn2()print(learn2()) 结果如下: 123努力学习一年努力学习一年程序员一个 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习三]]></title>
    <url>%2F2018%2F01%2F14%2Fpython%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[流程控制 流程分类 顺序结构 break continue pa 流程控制流程: 计算机执行代码的顺序就是流程。 流程控制： 对计算机代码执行顺序的管理就是流程控制。 流程分类 流程控制一共分为三类： 1.顺序结构 2.分支结构/选择结构 3.循环结构 顺序结构: 顺序结构就是代码一种自上而下执行的结构，这是python默认的流程 分支/选择结构: 分支结构一共分为4类： 1.单项分支 2.双项分支 3.多项分支 4.巢状分支 单项分支： 格式： if 条件表达式： 一条python语句... 一条python语句... 一条python语句... ... 特征： 1.if条件表达式结果为真，则执行if之后所有的控制代码组，如果为假，则不执行后面的代码组(:后面的N行中有相同缩进的代码) 2.:之后下一行的内容必须缩进，否则语法错误。 3.if之后的代码 中如果缩进不一致，则不受if条件表达式的控制，也不是单项分支的内容，是顺序结构的一部分。 4.if:后面的代码是在条件表达式结果为真的情况下执行，所以称之为真区间或者if区间 双项分支: 格式: if 条件表达式： 一条python语句... 一条python语句... 一条python语句... ... else: 一条python语句... 一条python语句... 一条python语句... ... 特征： 1.双项分支有2个区间：分别是 True 控制的if区间和 False 控制的else区间（假区间） 2.if区间的内容在双项分支中必须缩进，否则语法错误。 多项分支： 格式： if 条件表达式： 一条python语句... 一条python语句... 一条python语句... ... elif 条件表达式： 一条python语句... 一条python语句... 一条python语句... ... else: 一条python语句... 一条python语句... 一条python语句... ... 特征： 1.多项分支可以添加无限个elif分支，无论如何只会执行一个分支。 2.执行完一个分支后，分支结构就会结束，后面的分支都不会判断也不会执行。 3.多项分支的判断顺序是自上而下逐个进行判断。 巢状分支： 巢状分支是其他分支结构的嵌套结构，无论哪个分支都可以嵌套 循环结构: 循环结构分为2类： 1.while 循环 1.for .. in 循环 while 循环： 格式1： while 条件表达式： 循环的内容 [变量的变化] 格式2： while 条件表达式： 循环的内容 [变量的变化] else: python语句.. 注意：while 循环中的else是在while条件表达式为假的情况下执行的代码内容。 123456789num = 0while num &lt; 100 : if num % 2 == 0 : print(&apos;★&apos;,end = &apos;&apos;) else : print(&apos;☆&apos;,end = &apos;&apos;) if num % 10 == 9 : print(&apos;\n&apos;,end = &apos;&apos;) num += 1; 结果如下： 12345678910★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆ for ... in 循环 用于遍历容器类的数据（字符串，列表，元组，字典，集合） 格式1: for 变量 in 容器: python代码,可以在此使用变量 格式2: for 变量1,变量2 in 容器: python代码,可以在此使用变量1和变量2 要求遍历的容器必须是以下几种格式: [(),(),()] 列表中有元组 [[],[],[]] 列表中有列表 ((),(),()) 元组中有元组 {(),(),()} 集合中有元组 格式3: for 变量 in 容器: python代码,可以在此使用变量 else: 循环结束是执行的代码! 遍历字典的特殊方式 12345678dict1 = &#123;&apos;aqqj&apos;:&apos;sdsd&apos;,&apos;dfef&apos;:&apos;dfsd&apos;&#125;for i,j in dict1.items() : print(i) print(j)``` 结果如下: aqqjsdsddfefdfsd12----------------- str1 = ‘liu’ for onechar in str1 : print(onechar) 12结果如下： liu1234567891011121314151617181920-----------## break break 破坏,结束,打破作用:在循环中break的作用是终止当前循环结构的后续操作,一旦程序运行了break,循环也就终止了.## continuecontinue 继续作用:在循环中continue的作用是跳过本次循环,开始下一次循环操作,continue执行之后当前循环的后续代码就不会在执行,直接进入下一次循环(主要用于数据过渡)## pass 空语句作用:pass是没有任何意义的空语句,但是在书写语言结构时如果不需要任何操作,那么为了避免语法错误,可以使用pass占位语句,占位 aqqje = ‘li’if aqqje == ‘li’ : passelse: print(aqqje)` 无结果: 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE学习二]]></title>
    <url>%2F2018%2F01%2F14%2FjavaSE%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE学习一]]></title>
    <url>%2F2018%2F01%2F14%2FjavaSE%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[基础常识(了解) Java语言概述(了解) Java程序运行机制及运行过程(掌握) 注 释(掌握) Java API文档(掌握) 基础常识 (了解) 常用的DOS命令 dir : 列出当前目录下的文件以及文件夹 md : 创建目录 rd : 删除目录 cd : 进入指定目录 cd.. : 退回到上一级目录 cd\: 退回到根目录 del : 删除文件 exit : 退出 dos 命令行 Java语言概述(了解) 是SUN(Stanford University Network，斯坦福大学网络公司)1995年推出的一门高级编程语言。95年，SUN发布JDK 1.0，98年，JDK1.2，后续JDK1.3， 1.4，1.5（更名为Java5.0）最新为JDK1.8。 是一种面向Internet的编程语言。 随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 Java技术体系平台 Java SE(Java Standard Edition)标准版 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE Java EE(Java Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE Java ME(Java Micro Edition)小型版 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME Java Card 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台 Java语言运行机制及运行过程(掌握) Java语言的特点 特点一：面向对象 1.两个基本概念：类、对象 2.三大特性：封装、继承、多态 特点二：健壮性 1.吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制 特点三：跨平台性 1.跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” 2.原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。 Java两种核心机制 Java虚拟机（Java Virtal Machine） 1.JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。 2.对于不同的平台，有不同的虚拟机。 3.Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。 垃圾收集机制（Garbage Collection） 1.不再使用的内存空间应回收—— 垃圾回收。 2.在C/C++等语言中，由程序员负责回收无用内存。 3.Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。 4.垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。 注释 用于注解说明解释程序的文字就是注释。 提高了代码的阅读性；调试程序的重要方法。 Java中的注释类型： 1.单行注释 // -- &lt;!-- --&gt; 2.多行注释 3.文档注释（java特有） 注释是一个程序员必须要具有的良好编程习惯。 将自己的思想通过注释先整理出来，再用代码去体现 单行注释 格式： //注释文字 多行注释 格式： /* 注释文字 */ 注意： 1.对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。 2.多行注释里面不允许有多行注释嵌套。 文档注释（java特有） 格式： /** * @author 指定java程序的作者 *@version 指定源文件的版本 *@param 方法的参数说明信息 */ 注意： 1.注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 操作方式：(DOS) javadoc -d mydoc -author -version HelloWorld.java Java API文档(掌握) API （Application Programming Interface,应用程序编程接口）是 Java 提供的基本编程接口。 Java语言提供了大量的基础类，因此 Oracle 也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。 javadoc 和 javadoc注释规范 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习二]]></title>
    <url>%2F2018%2F01%2F13%2Fpython%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[运算 运算符 运算的分类 关系运算/比较运算 赋值运算 逻辑运算 位运算 身份运算 运算优先级的问题 检测数据归属类型 运算由一个以上的值经过变化等到新值的过短就是运算。 运算符用于运算的符号就是运算符。 运算的分类1.算数运算 2.比较运算/关系运算 3.赋值运算 4.逻辑运算 5.位运算 6.成员运算 7.身份运算 算数运算+ 加法运算 - 减法运算 * 乘法运算 / 除法运算 % 取余运算 // 取商运算/地板除 ** 幂运算 注意：python中没有自增的 ++ ，也没自减的 – 运算 关系运算/比较运算&gt; 大于运算 &lt; 小于运算 == 等于运算 &gt;= 大于等于运算 &lt;= 小于等于运算 != 不于运算 注意：python中没有类型判断，所以没有 === 和 ！== 运算 赋值运算= 普通赋值运算 += 加法赋值运算 -= 减法赋值运算 *= 乘法赋值运算 /= 除法赋值运算 %= 取余赋值运算 //= 取商赋值运算 **= 幂赋值运算 注意：所有的运算操作的格式都可以转化为 【变量 = 变量 运算符 值】，等号两侧一定都变量 var /= 5 -&gt; var = var / 5 逻辑运算逻辑运算就是布尔值之间的运算，python只有三种运算方式 and 逻辑与运算 -&gt; 有假则假 or 逻辑或运算 -&gt; 有真则真 not 逻辑非运算 -&gt; 真变假，假变真 注意：逻辑运算一共四种，python只提供了三种：没有提供逻辑异或【相同为假，不同为真】运算 位运算在二进制基础上进行的逻辑运算就是位运算 &amp; 按与运算 | 按或运算 ~ 按非运算 ^ 按位异或运算 &gt;&gt; 右移运算 相当于*2运算 &lt;&lt; 左移运算 相当于//2运算 成员运算检测一个数据是否在指定的容器(复合数据)当中 检测一个数据a是否在别名一个数据b当中 格式： 数据a in 数据b 检测一个数据a是否不在别名一个数据b当中 格式： 数据a not in 数据b 身份运算检测2个变量在内存中是否同一个值 检测2个变量是不是同一个值 格式： 数据a is 数据b 检测2个变量是不是不是同一个值 格式： 数据a is not 数据b 运算优先级的问题** 指数（最高优先级） ~ + - 按位翻转，一元加号和减号（+@ 和 -@） * / % // 乘，除，取模，取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移 运算符 &amp; 位 &apos;AND&apos; ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is (is not) 身份运算符 in (not in) 成员运算符 not or and 逻辑运算符 注意：实际中，使用()来解决 检测数据归属类型type() 测试可以使用，开发尽量避免。 ininstance() 检测一个数据是否由指定类型创建。 格式： isinstance(变量，检测的类型) 检测的类型名称就是类型转换的那些功能的名称，不需要() 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习一]]></title>
    <url>%2F2018%2F01%2F12%2Fpython%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[python的安装 python的检测 python的语言特色 如何创建python文件 注释 python的语句分类 变量 python赋值原理 python变量的三个常用操作 python数据类型 转义字符 元字符串 数据类型转换 python的安装 目前python有2个大的版本 2X版本 和 3X版本 windows安装python 根据操作系统的位数选择对应的版本的安装程序即可。 注意: 安装界面中 Add python... TO PATH 的选项一定要打勾。 python的检测1.”开始菜单” -&gt; “运行” -&gt; “cmd” -&gt; “python” 出现以提示表示成功: 1234Python 3.7.0a4 (v3.7.0a4:07c9d85, Jan 9 2018, 06:16:56) [MSC v.1900 32 bit (Intel)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 2.DOS界面中 -&gt; “python -v” (直接查看版本) 出现以提示表示成功: 12Python 3.7.0a4 3.”开始菜单” -&gt; “所有程序” -&gt; “Python …” 出现正常的文件夹表示成功 python的语言特色1.python是一门解释性的语言 解释性语言： 在系统运行时需解释器将代码翻译成计算机可识别的语言，这种类型就解释性语言。 java,python,php ... 编译性语言： 在系统运行程序之前，已经由开发者将源代码翻译成计算机可识别的代码，计算机直接运行即可，不需要任何解释器，这就是编译性语言。 c,object-c 开发效率 解释性语言 &lt; 编译性语言 2.强类型语言 ? 弱类型语言 强类型语言特色： 1.存储数据时需要预先声明的数据类型。 2.在进行不同的数据类型运算时不可以运算。 （python） 弱类型语言特色： 1.存储数据是不需要预先声明数据类型。 （python） 2.在进行不同的数据类型运算时可以自动转换类型并运算。 3.python是一门面向对象的语言 python支持全面的面向对象开发模式，当然python也支持过程开发和函数式开发。 4.python是一门胶水语言 python可以把其他语言开发的模块嵌入python当中进行使用。 python语言本身大部分都是由C语言构建而来的。 如何创建python文件文件名称部分 1.可以使用英文，不要使用中文。 2.可以使用数字，但是尽量不要使用数字。 3.可以使用_或者.等部分字符分隔文件名。 4.文件命名要有意义方便维护。 文件后辍部分 常用文件后辍：.py .pyc 123#第一句python代码 -- 注释print(&apos;你好！python!&apos;) 注释注释就是注解，解释，主要用坏在代码中进行代码相关的文字提示或者程序调试功能 注释一共分2种 单行注释： #注释内容 多行注释： ··· 多行内容 多行内容 多行内容 ... ··· 或者: &quot;&quot;&quot; 多行内容 多行内容 多行内容 ... &quot;&quot;&quot; python的语句分类python语句分为2类： 单行语句： 一行python代码 多行语句： 代码组都是特定的语言结构 12345678# 代码组if 1 : print(&apos;liuliaqqje&apos;) print(&apos;liuliaqqje&apos;) print(&apos;liuliaqqje&apos;) print(&apos;liuliaqqje&apos;) 变量变量就是可以改变的量 变量赋值： 格式： 变量名 = 值 变量的命名规范： 1.汉字变量名能用，不推荐使用。 2.可以使用数字但是不能用数字开头。 3.不可以使用特殊字符，除了_。 4.变量严格区分大小写。 5.变量命名要有意义（规范）。 6.变量命名要避免和系统使用的保留关键字冲突。 关键字： False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;async&apos;, &apos;await&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos; 查询系统保留关键字： import keyword print(keyword.kwlist) 其他的变量赋值格式 变量名 = 值 变量1 = 变量2 = 变量3 = 值 变量1，变量2，变量3 = 值1，值2，值3 python赋值原理 12345678910# 变量1 = 变量2 = 变量3 = 值name1 = name2 = name3 = &apos;aqqje&apos;print(name1);print(id(name1));print(name2);print(id(name2));print(name3);print(id(name3)); 输出结果： 123456aqqje33830688aqqje33830688aqqje33830688 12345678910# 变量1，变量2，变量3 = 值1，值2，值3name1,name2,name3 = &apos;aqqje1&apos;,&apos;aqqje2&apos;,&apos;aqqje3&apos;;print(name1);print(id(name1));print(name2);print(id(name2));print(name3);print(id(name3)); 输出结果：12345aqqje13180313631803072aqqje331803168 Python无变量，万物皆对象！ python变量的三个常用操作输出值： print(变量名); 输出ID： print(id(变量名)); 输出类型： print(type(变量名)); python数据类型python中可以自定义类型类型，可以具有无限个类型。 python提供默认6个标准数据类型： 1.Number 数值型 2.String 字符型 3.List 列表型 4.Tuple 元组型 5.Dict 字典型 6.Set 集合型 Number类型 Number型一共分为四个小类型:整型，浮点型，布尔型，复数 整型： 整型就是数字中的整数，包含正整，0和负整数。 声明整型有四种方式： 十进制： 0 ~ 9 变量 = 十进制数字 二进制： 0 ~ 1 变量 = 0b二进制数字 0b二进制标志符 八进制： 0 ~ 7 变量 = 0o八进制数字 0o八进制标志符 十六进制： 0 ~ 9 A ~ F 变量 = 0x十六进制数字 0x十六进制标志符 浮点型： 浮点型就是小数类型 声明浮点型的两种方式： 小数方式： 变量 = 3.1452114; 科学计数法： 变量 = 314e2 314*10的平方 布尔型： 计算专用的数据类型，只有两个值： true 和 false true 表示肯定的答案 false 表示否定的答案 复数： 复数的完整结构 （实数部分 + 虚数部分） 实数：现实存在的所有数值就是实数，真实存在的数字 虚数：不是真实存在的数字(), 声明复数的两种方式： 表达式方式： 变量 = 实数 + 虚数 comVal1 = 3 + 2j; 特定功能 变量 = complex(实数，虚数值) comVal2 = complex(5,3); String类型 字符串类型就是文字类型 声明一个字符串类型有三种方式： 单引号： 变量 = &apos;内容&apos; 内容中包含大量的双引号时适合使用单引号声明字符串 双引号： 变量 = &quot;内容&quot; 内容中包含大量的单引号时适合使用双引号声明字符串 三引号： 变量 = &apos;&apos;&apos;内容&apos;&apos;&apos; 或者 变量 = &quot;&quot;&quot;内容&quot;&quot;&quot; 适合多内容，单双引号都存在的情况下声明字符串 在双引号中使用双引号，在单引号中使用单引号（转义） List 列表类型 一组数据的有序组合就是 List 类型。 格式： 变量 = [值1，值2，值3...]; 注意：列表的标志符号是 [] Tuple 元组类型 一组数据的有序集合就是元组，元组是一种特殊的列表，不可以修改。 格式： 变量 = (值1，值2，值3...); 注意元组的标志符号是 ， Dict 字典类型 由一组具有键值对格式的数据 组成的无序的数据就是字典。 格式： 变量 = {键:值，键:值，键:值，键:值...} 注意：字典的标志就是 {} Set 集合类型 一组特定(去重)数据 的无序组合就是集合（） 格式： 变量 = {值，值，值...} 注意：集合没有标志符号 集合中的数据一定是唯一的，不会重复。 转义字符转义字符就是通过指定的格式，改变字符的意义。 转义字符 描述 * (在行尾时) 续行符 * \ 反斜杠符号 *** \’ 单引号 ** \” 双引号 ** \a 响铃 \b 退格(Backspace) \e 转义 \000 空 \n 换行 ** \v 纵向制表符 \t 横向制表符 ** \r 回车 ** \f 换页 \oyy 八进制数，yy代表的字符 例如：\o12代表换行 xyy 十六进制数，十六代表的字符 例如：\x0a代表换行 \other 其他的字符以普通格式输出 元字符串元字符就是字符串中的转义字符格式不进行任何转义操作的字符串，能够使得转义失效。 格式： 变量 = r&apos;字符串&apos; 或者 R&apos;字符串&apos; 数据类型转换将数据具当前类型变化为其他类型的操作就是数据类型转换 数据类型转换分类： 隐式转换（自动转换）：程序根据运算要求行的转换，不需要人工干预。 1.自动类型转换不需要人工干预 2.自动类型转换多发在运算或者判断过程中 3.转化时向着更加精确的类型转换 显示转换（强制转换）：根据程序需要，由编写程序人员人为改变数据类型的方式就是强制数据类型转换。 int() 将其他类型转化为整型 1.数字整型转化之后，还是原来的。 2.浮点型转化之后，舍去小数部分。 3.布尔值转化 True -&gt; 1 False -&gt; 0 4.字符串转换，仅纯整型字符串可以转换。 5.复数不可以转换。 float() 将其他类型转化为浮点型 1.整型转换之后变为浮点型，后面 +.0 2.浮点数不需要转化，转化也不会变化。 3.布尔值转化 True -&gt; 1.0 False -&gt; 0.0 4.字符串，纯整型和纯浮点型字符串可以转换。 complex() 将其他类型转化为复数 1.整型转换之后变为(整型 + 0j) 2.浮点型转换之后变为(浮点型 + 0j) 3.布尔值转化之后 True -&gt; (1 + 0j) False(0j) 4.字符串，纯整型和纯浮点型字符串可以转换。 5.复数，无需转换。 bool() 将其他类型转化为布尔值 1.整型 0 2.浮点型 0.0 3.复数 0 + 0j 4.布尔 True/False 5.字符串 &apos;&apos; 空字符串 6.列表 [] 空列表 7.元组 () 空元组 8.字典 {} 空字典 9.集合 set() 空集合 str() 将其他类型转化为字符串 1.所有转换均改变类型为字符串，表示方式依旧不变。 list() 将其他类型转化为列表类型 在python中5种可迭代序列，可以互相转换，他们分别是：字符串，列表，元组，字典，集合 注意： 1.字符串转换时每个字符变成列表中的一个值。 2.字典类型转换时，仅将字典的键部分转换成列表，忽略值的部分。 例如： 123var = (&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;);newvar = list(var);print(newvar); 结果如下: [‘张三’, ‘李四’, ‘王五’] tupe() 将其他类型转化为元组类型 注意： 1.字符串转换时每个字符变成列表中的一个值。 2.字典类型转换时，仅将字典的键部分转换成列表，忽略值的部分。 例如： 123var = (&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;);newvar = tuple(var);print(newvar); 结果如下: [‘张三’, ‘李四’, ‘王五’] set() 将其他类型转化为集合类型 注意： 1.字符串转换时每个字符变成列表中的一个值。 2.字典类型转换时，仅将字典的键部分转换成列表，忽略值的部分。 例如： 123var = (&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;);newvar = tuple(var);print(newvar); 结果如下: [‘张三’, ‘李四’, ‘王五’] 值的顺序不定 dict() 将其他类型转化为字典类型 其他类型转化为字典时需要按照指定的格式才可以转化：（列表和元组的组合可以） [[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;],[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;],[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]] [(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;),(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;),(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;)] 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pull 冲突解决方法]]></title>
    <url>%2F2017%2F12%2F19%2Fgithub-pull-%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[多人协作git pull 问题解决 1.首先将本地修改存储 存储修改 1git stash 查看保存信息 1git stash list 其中stash@{0}是保存的标记 ## 2.pull远程仓库 1git pull 还原暂存内容1git stash pop stash@&#123;0&#125; 手动解决文件冲突部分其中Updated upstream 和=====之间的内容就是pull下来的内容，====和stashed changes之间的内容就是本地修改的内容 正常push到远程仓库1git push origin master 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>git pull问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeTalk-Forum总结]]></title>
    <url>%2F2017%2F12%2F19%2FFreeTalk-Forum%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[创建数据库 创建存储过程 sql server日期时间转字符串 新加一个列（表已存在） java调用存储过程 创建数据库123456789101112131415161718/*创建数据库*/create database FreeTalkDB on(name=FreeTalkDB_dat,filename=&apos;F:\FreeTalk\FreeTalkDB.mdf&apos;,size=5MB,maxsize=50MB,filegrowth=5%)log on(name=FreeTalkBD_log,filename=&apos;F:\FreeTalk\FreeTalkDB.ldf&apos;,size=3MB,maxsize=20MB,filegrowth=3MB) 创建存储过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*创建用户表*/create table Fuser (UId char(10) not null, --用户ID [1712180001] pkUserName varchar(25) not null, --用户名PassWord varchar(16) not null, --密码U_Sex int not null, --性别U_Head varchar(50) not null, --头像地址U_Grand int not null --权限等级);/*创建存储过程 * 实现ID字段的自动增长并实现insert功能 * */ --创建UID_increment create proc UID_increment @uName varchar(25), @passWord varchar(16), @uSex int, @uHead varchar(50), @uGrand int as begin declare @date char(6),@id char(4),@uID char(10) select @date=right(convert(varchar(8),getdate(),112),6); select @id=MAX(UID) from Fuser if @id IS null begin set @id =&apos;0001&apos;; end else begin select @id=(convert(int,RIGHT(UID,4))+1) from Fuser; if @id &lt;10 set @id = &apos;000&apos;+(convert(char,@id)); else if @id &lt; 100 and @id &gt;= 10 set @id = &apos;00&apos;+(convert(char,@id)); else if @id &lt; 1000 and @id &gt;= 100 set @id = &apos;0&apos;+(convert(char,@id)); end select @uID=@date+@id; insert into Fuser values (@UID,@uName,@passWord,@uSex,@uHead,@uGrand); end; /*调用存储过程*/exec UId_increment &apos;adf&apos;,&apos;123&apos;,1,&apos;sdfs&apos;,1; /*查询结果*/select * from Fuser; sql server日期时间转字符串sql server日期时间转字符串 新加一个列（表已存在）1234/*版块表(Section)增加一个列(S_notify)*/alter table Section add S_notify varchar(256); java调用存储过程123456789101112131415161718192021222324252627public boolean addUser(User user) &#123; Connection conn = DBConnection.getConnection(); try &#123; CallableStatement cs = conn.prepareCall(&quot;&#123;call UId_increment（?,?,?,?,?）&#125;&quot;); cs.setString(1, user.getUserName()); cs.setString(2, user.getPassWord()); cs.setInt(3, user.getSex()); cs.setString(4, user.getuHead()); cs.setInt(5,user.getGrand()); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return false; &#125; finally &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; // TODO Auto-generated method stub return true; &#125; 通过集合获取一个对象12345678910111213141516171819202122232425262728293031323334353637public List&lt;Section&gt; getSections() &#123; // TODO Auto-generated method stub Connection conn = DBConnection.getConnection(); PreparedStatement pstmt = null; ResultSet rs = null; List&lt;Section&gt; list = new ArrayList&lt;Section&gt;(); String sql = &quot;select * from Section order by ? asc&quot;; try &#123; Section s = new Section(); pstmt = conn.prepareStatement(sql); pstmt.setInt(1,s.getsId()); rs = pstmt.executeQuery(); while(rs.next()) &#123; s.setsId((rs.getInt(1))); s.setsName(rs.getString(2)); s.setsNotice(rs.getString(3)); User u1 = new User(); u1.setuId(rs.getString(4)); s.setModerator1(u1); User u2 = new User(); u2.setuId(rs.getString(5)); s.setModerator1(u2); User u3 = new User(); u3.setuId(rs.getString(6)); s.setModerator1(u3); s.setsClickCount(rs.getInt(7)); list.add(s); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return null; &#125; return list; &#125; java中的几个集合类的详解java中的几个集合类的详解 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Item</category>
      </categories>
      <tags>
        <tag>Item  summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十四]]></title>
    <url>%2F2017%2F12%2F13%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十四章，主要是用来复习和巩固在课堂学习的知识！ 笔记一、游标参数的传递 例： 12345678910111213SET SERVEROUTPUT ON DECLARE V_empno NUMBER(5); V_ename VARCHAR2(10); CURSOR emp_cursor(p_deptno NUMBER,p_job VARCHAR2) IS SELECT empno,ename FROM emp WHERE deptno = p_deptno AND job = p_job; BEGIN OPEN emp_cursor(10, 'CLERK'); LOOP FETCH emp_cursor INTO v_empno,v_ename; EXIT WHEN emp_cursor%NOTFOUND; DBMS_OUTPUT.PUT_LINE(v_empno||','||v_ename); END LOOP; END; 二、异常处理错误处理的语法如下： 123456 EXCEPTIONWHEN 错误1[OR 错误2] THEN 语句序列1;WHEN 错误3[OR 错误4] THEN 语句序列2;...WHEN OTHERS 语句序列n; END; 例： 12345678910SET SERVEROUTPUT ON DECLARE v_name VARCHAR2(10); BEGIN SELECT ename INTO v_name FROM emp WHERE empno = 1234; DBMS_OUTPUT.PUT_LINE('该雇员名字为：'|| v_name); EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('编号错误，没有找到相应雇员！'); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！'); END; 三、存储过程1.创建和删除存储过程格式： 12345678CREATE [OR REPLACE] PROCEDURE 存储过程名[(参数[IN|OUT|IN OUT] 数据类型...)] &#123;AS|IS&#125; [说明部分] --定义需要使用的临时变量 BEGIN 语句集; [EXCEPTION] [错误处理部分] END [过程名]; 删除： 1drop procedure 存储过程名; 调用存储过程1234567方法1： EXECUTE 模式名.存储过程名[(参数...)]; (适用于命今行窗口及sql窗口)方法2： (适用于sql窗口)BEGIN 模式名.存储过程名[(参数...)];END; 例：编写显示雇员信息的存储过程EMP_LIST，并引用EMP_COUNT存储过程(无参存储过程 )。 123456789CREATE OR REPLACE PROCEDURE EMP_LISTASCURSOR emp_cursor IS SELECT empno,ename FROM emp;BEGIN FOR Emp_record IN emp_cursor LOOP DBMS_OUTPUT.PUT_LINE(Emp_record.empno||Emp_record.ename); END LOOP; EMP_COUNT; END; 调用： 123begin EMP_LIST;end; 参数传递 a.输入参数: 参数名 IN 数据类型 DEFAULT 值； 例：编写给雇员增加工资的存储过程CHANGE_SALARY，通过IN类型的参数传递要增加工资的雇员编号和增加的工资额。 12345678910111213CREATE OR REPLACE PROCEDURE CHANGE_SALARY(P_EMPNO IN NUMBER DEFAULT 7788,P_RAISE NUMBER DEFAULT 10) --形参P_EMPNO及P_RAISEAS V_ENAME VARCHAR2(10); V_SAL NUMBER(5);BEGIN SELECT ENAME,SAL INTO V_ENAME,V_SAL FROM EMP WHERE EMPNO=P_EMPNO; UPDATE EMP SET SAL=SAL+P_RAISE WHERE EMPNO=P_EMPNO; DBMS_OUTPUT.PUT_LINE('雇员'||V_ENAME||'的工资被改为'||TO_CHAR(V_SAL+P_RAISE)); COMMIT;EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生错误，修改失败！'); ROLLBACK; --如果出了异常则撤消END; 调用： 123begin CHANGE_SALARY(7788,80)end; b.输出参数: 参数名 OUT 数据类型 DEFAULT 值； 例：统计雇员的人数 12345CREATE OR REPLACE PROCEDURE EMP_COUNT(P_TOTAL OUT NUMBER) --P_TOTAL为输出参数ASBEGINSELECT COUNT(*) INTO P_TOTAL FROM EMP; END; 调用： 1234567DECLARE V_EMPCOUNT NUMBER; --定义变量接收过程求出的结果 BEGIN EMP_COUNT(V_EMPCOUNT); DBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_EMPCOUNT); END;` c.输入输出参数： 参数名 IN OUT 数据类型 DEFAULT 值； 例：使用IN OUT类型的参数，给电话号码增加区码。 12345CREATE OR REPLACE PROCEDURE ADD_REGION(P_HPONE_NUM IN OUT VARCHAR2) AS BEGIN P_HPONE_NUM:='024-'||P_HPONE_NUM; END; 调用： 1234567DECLARE V_PHONE_NUM VARCHAR2(15); BEGIN V_PHONE_NUM:='26731092'; ADD_REGION(V_PHONE_NUM); DBMS_OUTPUT.PUT_LINE('新的电话号码：'||V_PHONE_NUM); END; 错误处理错误处理部分位于程序的可执行部分之后，是由WHEN语句引导的多个分支构成的。错误处理的语法如下： 1234EXCEPTIONWHEN 错误1[OR 错误2] THEN语句序列1；WHEN 错误3[OR 错误4] THEN 语句序列2； 123WHEN OTHERS语句序列n；END; 其中：错误是在标准包中由系统预定义的标准错误，或是由用户在程序的说明部分自定义的错误，参见下一节系统预定义的错误类型。语句序列就是不同分支的错误处理部分。 凡是出现在WHEN后面的错误都是可以捕捉到的错误，其他未被捕捉到的错误，将在WHEN OTHERS部分进行统一处理，OTHENS必须是EXCEPTION部分的最后一个错误处理分支。如要在该分支中进一步判断错误种类，可以通过使用预定义函数SQLCODE( )和SQLERRM( )来获得系统错误号和错误信息。 如果在程序的子块中发生了错误，但子块没有错误处理部分，则错误会传递到主程序中。 下面是由于查询编号错误而引起系统预定义异常的例子。 【训练1】 查询编号为1234的雇员名字。 123456789101112131415SET SERVEROUTPUT ONDECLAREv_name VARCHAR2(10);BEGIN SELECT ename INTO v_name FROM emp WHERE empno = 1234;DBMS_OUTPUT.PUT_LINE('该雇员名字为：'|| v_name);EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('编号错误，没有找到相应雇员！'); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！');END; 说明：在以上查询中，因为编号为1234的雇员不存在，所以将发生类型为“NO_DATA_ FOUND”的异常。“NO_DATA_FOUND”是系统预定义的错误类型，EXCEPTION部分下的WHEN语句将捕捉到该异常，并执行相应代码部分。在本例中，输出用户自定义的错误信息“编号错误，没有找到相应雇员!”。如果发生其他类型的错误，将执行OTHERS条件下的代码部分，显示“发生其他错误!”。 【训练2】 由程序代码显示系统错误。 1234567891011SET SERVEROUTPUT ONDECLAREv_temp NUMBER(5):=1;BEGINv_temp:=v_temp/0;EXCEPTION WHEN OTHERS THENDBMS_OUTPUT.PUT_LINE('发生系统错误！'); DBMS_OUTPUT.PUT_LINE('错误代码：'|| SQLCODE( )); DBMS_OUTPUT.PUT_LINE('错误信息：' ||SQLERRM( )); END; 说明：程序运行中发生除零错误，由WHEN OTHERS捕捉到，执行用户自己的输出语句显示错误信息，然后正常结束。在错误处理部分使用了预定义函数SQLCODE( )和SQLERRM( )来进一步获得错误的代码和种类信息。 预定义错误Oracle的系统错误很多，但只有一部分常见错误在标准包中予以定义。定义的错误可以在EXCEPTION部分通过标准的错误名来进行判断，并进行异常处理。 比如，如果程序向表的主键列插入重复值，则将发生DUP_VAL_ON_INDEX错误。 如果一个系统错误没有在标准包中定义，则需要在说明部分定义，语法如下： 1错误名 EXCEPTION; 定义后使用PRAGMA EXCEPTION_INIT来将一个定义的错误同一个特别的Oracle错误代码相关联，就可以同系统预定义的错误一样使用了。语法如下： 1PRAGMA EXCEPTION_INIT(错误名，- 错误代码)； 【训练1】 定义新的系统错误类型。 12345678910111213 SET SERVEROUTPUT ON DECLARE V_ENAME VARCHAR2(10); NULL_INSERT_ERROR EXCEPTION; PRAGMA EXCEPTION_INIT(NULL_INSERT_ERROR,-1400); BEGIN INSERT INTO EMP(EMPNO) VALUES(NULL);EXCEPTIONWHEN NULL_INSERT_ERROR THEN DBMS_OUTPUT.PUT_LINE('无法插入NULL值！'); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他系统错误！');END; 说明：NULL_INSERT_ERROR是自定义异常，同系统错误1400相关联。 自定义异常程序设计者可以利用引发异常的机制来进行程序设计，自己定义异常类型。可以在声明部分定义新的异常类型，定义的语法是： 1错误名 EXCEPTION; 用户定义的错误不能由系统来触发，必须由程序显式地触发，触发的语法是： 1RAISE 错误名； RAISE也可以用来引发模拟系统错误，比如，RAISE ZERO_DIVIDE将引发模拟的除零错误。 使用RAISE_APPLICATION_ERROR函数也可以引发异常。该函数要传递两个参数，第一个是用户自定义的错误编号，第二个参数是用户自定义的错误信息。使用该函数引发的异常的编号应该在20 000和20 999之间选择。 自定义异常处理错误的方式同前。 【训练1】 插入新雇员，限定插入雇员的编号在7000～8000之间。 123456789101112131415161718192021222324SET SERVEROUTPUT ONDECLAREnew_no NUMBER(10);new_excp1 EXCEPTION;new_excp2 EXCEPTION;BEGIN new_no:=6789;INSERT INTO emp(empno,ename) VALUES(new_no, '小郑'); IF new_no&lt;7000 THEN RAISE new_excp1; END IF; IF new_no&gt;8000 THEN RAISE new_excp2; END IF; COMMIT;EXCEPTIONWHEN new_excp1 THEN ROLLBACK; DBMS_OUTPUT.PUT_LINE('雇员编号小于7000的下限！'); WHEN new_excp2 THEN ROLLBACK; DBMS_OUTPUT.PUT_LINE('雇员编号超过8000的上限！'); END; 说明：在此例中，自定义了两个异常：new_excp1和new_excp2，分别代表编号小于7000和编号大于8000的错误。在程序中通过判断编号大小，产生对应的异常，并在异常处理部分回退插入操作，然后显示相应的错误信息。 【训练2】 使用RAISE_APPLICATION_ERROR函数引发系统异常。 12345678910111213141516SET SERVEROUTPUT ONDECLARENew_no NUMBER(10);BEGIN New_no:=6789; INSERT INTO emp(empno,ename) VALUES(new_no, 'JAMES');IF new_no&lt;7000 THEN ROLLBACK; RAISE_APPLICATION_ERROR(-20001, '编号小于7000的下限！'); END IF; IF new_no&gt;8000 THEN ROLLBACK; RAISE_APPLICATION_ERROR (-20002, '编号大于8000的下限！'); END IF;END; 说明：在本训练中，使用RAISE_APPLICATION_ERROR引发自定义异常，并以系统错误的方式进行显示。错误编号为20001和20002。 注意：同上一个训练比较，此种方法不需要事先定义异常，可直接引发。 可以参考下面的程序片断将出错信息记录到表中，其中，errors为记录错误信息的表，SQLCODE为发生异常的错误编号，SQLERRM为发生异常的错误信息。 12345678910111213DECLARE v_error_code NUMBER; v_error_message VARCHAR2(255);BEGIN...EXCEPTION...WHEN OTHERS THEN v_error_code := SQLCODE ; v_error_message := SQLERRM ; INSERT INTO errors VALUES(v_error_code, v_error_message);END; 阶段训练【训练1】 将雇员从一个表复制到另一个表。 步骤1：创建一个结构同EMP表一样的新表EMP1： 1CREATE TABLE emp1 AS SELECT * FROM SCOTT.EMP WHERE 1=2; 步骤2：通过指定雇员编号，将雇员由EMP表移动到EMP1表： 12345678910111213141516SET SERVEROUTPUT ON DECLAREv_empno NUMBER(5):=7788;emp_rec emp%ROWTYPE;BEGIN SELECT * INTO emp_rec FROM emp WHERE empno=v_empno; DELETE FROM emp WHERE empno=v_empno;INSERT INTO emp1 VALUES emp_rec; IF SQL%FOUND THEN COMMIT; DBMS_OUTPUT.PUT_LINE('雇员复制成功！'); ELSE ROLLBACK; DBMS_OUTPUT.PUT_LINE('雇员复制失败！'); END IF;END; 步骤2：显示复制结果： 1SELECT empno,ename,job FROM emp1; 说明：emp_rec变量是根据emp表定义的记录变量，SELECT…INTO…语句将整个记录传给该变量。INSERT语句将整个记录变量插入emp1表，如果插入成功(SQL%FOUND为真)，则提交事务，否则回滚撤销事务。试修改雇员编号为7902，重新执行以上程序。 【训练2】 输出雇员工资，雇员工资用不同高度的█表示。 输入并执行以下程序： 123456SET SERVEROUTPUT ON BEGIN FOR re IN (SELECT ename,sal FROM EMP) LOOP DBMS_OUTPUT.PUT_LINE(rpad(re.ename,12,' ')||rpad(' █ ',re.sal/100,' █ ')); END LOOP;END; 说明：第一个rpad函数产生对齐效果，第二个rpad函数根据工资额产生不同数目的*。该程序采用了隐式的简略游标循环形式。 【训练3】 编写程序，格式化输出部门信息。 输入并执行如下程序： 12345678910111213141516SET SERVEROUTPUT ON DECLARE v_count number:=0; CURSOR dept_cursor IS SELECT * FROM dept; BEGIN DBMS_OUTPUT.PUT_LINE('部门列表');DBMS_OUTPUT.PUT_LINE('---------------------------------'); FOR Dept_record IN dept_cursor LOOP DBMS_OUTPUT.PUT_LINE('部门编号：'|| Dept_record.deptno); DBMS_OUTPUT.PUT_LINE('部门名称：'|| Dept_record.dname); DBMS_OUTPUT.PUT_LINE('所在城市：'|| Dept_record.loc); DBMS_OUTPUT.PUT_LINE('---------------------------------'); v_count:= v_count+1; END LOOP; DBMS_OUTPUT.PUT_LINE('共有'||to_char(v_count)||'个部门！'); END; 说明：该程序中将字段内容垂直排列。V_count变量记录循环次数，即部门个数。 【训练4】 已知每个部门有一个经理，编写程序，统计输出部门名称、部门总人数、总工资和部门经理。 输入并执行如下程序： 1234567891011121314151617181920212223242526SET SERVEROUTPUT ON DECLARE v_deptno number(8); v_count number(3); v_sumsal number(6); v_dname varchar2(15);v_manager varchar2(15); CURSOR list_cursor IS SELECT deptno,count(*),sum(sal) FROM emp group by deptno;BEGIN OPEN list_cursor; DBMS_OUTPUT.PUT_LINE('----------- 部 门 统 计 表 -----------');DBMS_OUTPUT.PUT_LINE('部门名称 总人数 总工资 部门经理'); FETCH list_cursor INTO v_deptno,v_count,v_sumsal; WHILE list_cursor%found LOOP SELECT dname INTO v_dname FROM dept WHERE deptno=v_deptno; SELECT ename INTO v_manager FROM emp WHERE deptno=v_deptno and job='MANAGER';DBMS_OUTPUT.PUT_LINE(rpad(v_dname,13)||rpad(to_char(v_count),8) ||rpad(to_char(v_sumsal),9)||v_manager); FETCH list_cursor INTO v_deptno,v_count,v_sumsal; END LOOP; DBMS_OUTPUT.PUT_LINE('--------------------------------------'); CLOSE list_cursor; END; 说明：游标中使用到了起分组功能的SELECT语句，统计出各部门的总人数和总工资。再根据部门编号和职务找到部门的经理。该程序假定每个部门有一个经理。 【训练5】 为雇员增加工资，从工资低的雇员开始，为每个人增加原工资的10%，限定所增加的工资总额为800元，显示增加工资的人数和余额。 输入并调试以下程序： 12345678910111213141516171819202122232425262728293031323334SET SERVEROUTPUT ON DECLARE V_NAME CHAR(10); V_EMPNO NUMBER(5); V_SAL NUMBER(8); V_SAL1 NUMBER(8); V_TOTAL NUMBER(8) := 800; --增加工资的总额V_NUM NUMBER(5):=0; --增加工资的人数 CURSOR emp_cursor IS SELECT EMPNO,ENAME,SAL FROM EMP ORDER BY SAL ASC; BEGIN OPEN emp_cursor; DBMS_OUTPUT.PUT_LINE('姓名 原工资 新工资'); DBMS_OUTPUT.PUT_LINE('---------------------------'); LOOP FETCH emp_cursor INTO V_EMPNO,V_NAME,V_SAL;EXIT WHEN emp_cursor%NOTFOUND; V_SAL1:= V_SAL*0.1; IF V_TOTAL&gt;V_SAL1 THEN V_TOTAL := V_TOTAL - V_SAL1; V_NUM:=V_NUM+1; DBMS_OUTPUT.PUT_LINE(V_NAME||TO_CHAR(V_SAL,'99999')|| TO_CHAR(V_SAL+V_SAL1,'99999')); UPDATE EMP SET SAL=SAL+V_SAL1 WHERE EMPNO=V_EMPNO; ELSEDBMS_OUTPUT.PUT_LINE(V_NAME||TO_CHAR(V_SAL,'99999')||TO_CHAR(V_SAL,'99999')); END IF; END LOOP; DBMS_OUTPUT.PUT_LINE('---------------------------'); DBMS_OUTPUT.PUT_LINE('增加工资人数:'||V_NUM||' 剩余工资：'||V_TOTAL); CLOSE emp_cursor; COMMIT; END; 识存储过程和函数存储过程和函数也是一种PL/SQL块，是存入数据库的PL/SQL块。但存储过程和函数不同于已经介绍过的PL/SQL程序，我们通常把PL/SQL程序称为无名块，而存储过程和函数是以命名的方式存储于数据库中的。和PL/SQL程序相比，存储过程有很多优点，具体归纳如下： 存储过程和函数以命名的数据库对象形式存储于数据库当中。存储在数据库中的优点是很明显的，因为代码不保存在本地，用户可以在任何客户机上登录到数据库，并调用或修改代码。 存储过程和函数可由数据库提供安全保证，要想使用存储过程和函数，需要有存储过程和函数的所有者的授权，只有被授权的用户或创建者本身才能执行存储过程或调用函数。 存储过程和函数的信息是写入数据字典的，所以存储过程可以看作是一个公用模块，用户编写的PL/SQL程序或其他存储过程都可以调用它(但存储过程和函数不能调用PL/SQL程序)。一个重复使用的功能，可以设计成为存储过程，比如：显示一张工资统计表，可以设计成为存储过程；一个经常调用的计算，可以设计成为存储函数；根据雇员编号返回雇员的姓名，可以设计成存储函数。 像其他高级语言的过程和函数一样，可以传递参数给存储过程或函数，参数的传递也有多种方式。存储过程可以有返回值，也可以没有返回值，存储过程的返回值必须通过参数带回；函数有一定的数据类型，像其他的标准函数一样，我们可以通过对函数名的调用返回函数值。 存储过程和函数需要进行编译，以排除语法错误，只有编译通过才能调用。 创建和删除存储过程创建存储过程，需要有CREATE PROCEDURE或CREATE ANY PROCEDURE的系统权限。该权限可由系统管理员授予。创建一个存储过程的基本语句如下： 12345678CREATE [OR REPLACE] PROCEDURE 存储过程名[(参数[IN|OUT|IN OUT] 数据类型...)]&#123;AS|IS&#125;[说明部分]BEGIN可执行部分[EXCEPTION错误处理部分]END [过程名]; 其中： 可选关键字OR REPLACE 表示如果存储过程已经存在，则用新的存储过程覆盖，通常用于存储过程的重建。 参数部分用于定义多个参数(如果没有参数，就可以省略)。参数有三种形式：IN、OUT和IN OUT。如果没有指明参数的形式，则默认为IN。 关键字AS也可以写成IS，后跟过程的说明部分，可以在此定义过程的局部变量。 编写存储过程可以使用任何文本编辑器或直接在SQLPlus环境下进行，编写好的存储过程必须要在SQLPlus环境下进行编译，生成编译代码，原代码和编译代码在编译过程中都会被存入数据库。编译成功的存储过程就可以在Oracle环境下进行调用了。 一个存储过程在不需要时可以删除。删除存储过程的人是过程的创建者或者拥有DROP ANY PROCEDURE系统权限的人。删除存储过程的语法如下： 1DROP PROCEDURE 存储过程名； 如果要重新编译一个存储过程，则只能是过程的创建者或者拥有ALTER ANY PROCEDURE系统权限的人。语法如下： 1ALTER PROCEDURE 存储过程名 COMPILE； 执行(或调用)存储过程的人是过程的创建者或是拥有EXECUTE ANY PROCEDURE系统权限的人或是被拥有者授予EXECUTE权限的人。执行的方法如下： 123456方法1：EXECUTE 模式名.存储过程名[(参数...)];方法2：BEGIN模式名.存储过程名[(参数...)];END; 传递的参数必须与定义的参数类型、个数和顺序一致(如果参数定义了默认值，则调用时可以省略参数)。参数可以是变量、常量或表达式，用法参见下一节。 如果是调用本账户下的存储过程，则模式名可以省略。要调用其他账户编写的存储过程，则模式名必须要添加。 以下是一个生成和调用简单存储过程的训练。注意要事先授予创建存储过程的权限。 【训练1】 创建一个显示雇员总人数的存储过程。 步骤1：登录SCOTT账户(或学生个人账户)。 步骤2：在SQL*Plus输入区中，输入以下存储过程： 1234567CREATE OR REPLACE PROCEDURE EMP_COUNTASV_TOTAL NUMBER(10);BEGIN SELECT COUNT(*) INTO V_TOTAL FROM EMP; DBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_TOTAL);END; 步骤3：按“执行”按钮进行编译。 如果存在错误，就会显示: 警告: 创建的过程带有编译错误。 如果存在错误，对脚本进行修改，直到没有错误产生。 如果编译结果正确，将显示： 过程已创建。 步骤4：调用存储过程，在输入区中输入以下语句并执行： 1EXECUTE EMP_COUNT; 显示结果为： 雇员总人数为：14 PL/SQL 过程已成功完成。 说明：在该训练中，V_TOTAL变量是存储过程定义的局部变量，用于接收查询到的雇员总人数。 注意：在SQL*Plus中输入存储过程，按“执行”按钮是进行编译，不是执行存储过程。 如果在存储过程中引用了其他用户的对象，比如表，则必须有其他用户授予的对象访问权限。一个存储过程一旦编译成功，就可以由其他用户或程序来引用。但存储过程或函数的所有者必须授予其他用户执行该过程的权限。 存储过程没有参数，在调用时，直接写过程名即可。 【训练2】 在PL/SQL程序中调用存储过程。 步骤1：登录SCOTT账户。 步骤2：授权STUDENT账户使用该存储过程，即在SQL*Plus输入区中，输入以下的命令： 1GRANT EXECUTE ON EMP_COUNT TO STUDENT 授权成功。 步骤3：登录STUDENT账户，在SQL*Plus输入区中输入以下程序： 1234SET SERVEROUTPUT ONBEGINSCOTT.EMP_COUNT;END; 步骤4：执行以上程序，结果为： 雇员总人数为：14 PL/SQL 过程已成功完成。 说明：在本例中，存储过程是由SCOTT账户创建的，STUDEN账户获得SCOTT账户的授权后，才能调用该存储过程。 注意：在程序中调用存储过程，使用了第二种语法。 【训练3】 编写显示雇员信息的存储过程EMP_LIST，并引用EMP_COUNT存储过程。 步骤1：在SQL*Plus输入区中输入并编译以下存储过程： 12345678910CREATE OR REPLACE PROCEDURE EMP_LISTASCURSOR emp_cursor IS SELECT empno,ename FROM emp;BEGINFOR Emp_record IN emp_cursor LOOP DBMS_OUTPUT.PUT_LINE(Emp_record.empno||Emp_record.ename);END LOOP;EMP_COUNT;END; 执行结果： 过程已创建。 步骤2：调用存储过程，在输入区中输入以下语句并执行： 1EXECUTE EMP_LIST 显示结果为：7369SMITH7499ALLEN7521WARD7566JONES 执行结果： 雇员总人数为：14 PL/SQL 过程已成功完成。 说明：以上的EMP_LIST存储过程中定义并使用了游标，用来循环显示所有雇员的信息。然后调用已经成功编译的存储过程EMP_COUNT，用来附加显示雇员总人数。通过EXECUTE命令来执行EMP_LIST存储过程。 【练习1】编写显示部门信息的存储过程DEPT_LIST，要求统计出部门个数。 参数传递参数的作用是向存储过程传递数据，或从存储过程获得返回结果。正确的使用参数可以大大增加存储过程的灵活性和通用性。 参数的定义形式和作用如下： 1参数名 IN 数据类型 DEFAULT 值； 定义一个输入参数变量，用于传递参数给存储过程。在调用存储过程时，主程序的实际参数可以是常量、有值变量或表达式等。DEFAULT 关键字为可选项，用来设定参数的默认值。如果在调用存储过程时不指明参数，则参数变量取默认值。在存储过程中，输入变量接收主程序传递的值，但不能对其进行赋值。 1参数名 OUT 数据类型； 定义一个输出参数变量，用于从存储过程获取数据，即变量从存储过程中返回值给主程序。 在调用存储过程时，主程序的实际参数只能是一个变量，而不能是常量或表达式。在存储过程中，参数变量只能被赋值而不能将其用于赋值，在存储过程中必须给输出变量至少赋值一次。 1参数名 IN OUT 数据类型 DEFAULT 值； 定义一个输入、输出参数变量，兼有以上两者的功能。在调用存储过程时，主程序的实际参数只能是一个变量，而不能是常量或表达式。DEFAULT 关键字为可选项，用来设定参数的默认值。在存储过程中，变量接收主程序传递的值，同时可以参加赋值运算，也可以对其进行赋值。在存储过程中必须给变量至少赋值一次。 如果省略IN、OUT或IN OUT，则默认模式是IN。 【训练1】 编写给雇员增加工资的存储过程CHANGE_SALARY，通过IN类型的参数传递要增加工资的雇员编号和增加的工资额。 步骤1：登录SCOTT账户。 步骤2：在SQL*Plus输入区中输入以下存储过程并执行： 1234567891011121314CREATE OR REPLACE PROCEDURE CHANGE_SALARY(P_EMPNO IN NUMBER DEFAULT 7788,P_RAISE NUMBER DEFAULT 10) AS V_ENAME VARCHAR2(10); V_SAL NUMBER(5); BEGIN SELECT ENAME,SAL INTO V_ENAME,V_SAL FROM EMP WHERE EMPNO=P_EMPNO; UPDATE EMP SET SAL=SAL+P_RAISE WHERE EMPNO=P_EMPNO; DBMS_OUTPUT.PUT_LINE('雇员'||V_ENAME||'的工资被改为'||TO_CHAR(V_SAL+P_RAISE));COMMIT; EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生错误，修改失败！'); ROLLBACK; END; 执行结果为： 过程已创建。 步骤3：调用存储过程，在输入区中输入以下语句并执行： 1EXECUTE CHANGE_SALARY(7788,80) 显示结果为： 雇员SCOTT的工资被改为3080 说明：从执行结果可以看到，雇员SCOTT的工资已由原来的3000改为3080。 参数的值由调用者传递，传递的参数的个数、类型和顺序应该和定义的一致。如果顺序不一致，可以采用以下调用方法。如上例，执行语句可以改为： 1EXECUTE CHANGE_SALARY(P_RAISE=&gt;80,P_EMPNO=&gt;7788); 可以看出传递参数的顺序发生了变化，并且明确指出了参数名和要传递的值，=&gt;运算符左侧是参数名，右侧是参数表达式，这种赋值方法的意义较清楚。 【练习1】创建插入雇员的存储过程INSERT_EMP，并将雇员编号等作为参数。 在设计存储过程的时候，也可以为参数设定默认值，这样调用者就可以不传递或少传递参数了。 【训练2】 调用存储过程CHANGE_SALARY，不传递参数，使用默认参数值。 在SQL*Plus输入区中输入以下命令并执行： 1EXECUTE CHANGE_SALARY 显示结果为： 雇员SCOTT的工资被改为3090 说明：在存储过程的调用中没有传递参数，而是采用了默认值7788和10，即默认雇员号为7788，增加的工资为10。 【训练3】 使用OUT类型的参数返回存储过程的结果。 步骤1：登录SCOTT账户。 步骤2：在SQL*Plus输入区中输入并编译以下存储过程： 12345CREATE OR REPLACE PROCEDURE EMP_COUNT(P_TOTAL OUT NUMBER) AS BEGIN SELECT COUNT(*) INTO P_TOTAL FROM EMP; END; 执行结果为： 过程已创建。 步骤3：输入以下程序并执行： 123456DECLARE V_EMPCOUNT NUMBER; BEGIN EMP_COUNT(V_EMPCOUNT); DBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_EMPCOUNT); END; 显示结果为： 雇员总人数为：14 PL/SQL 过程已成功完成。 说明：在存储过程中定义了OUT类型的参数P_TOTAL，在主程序调用该存储过程时，传递了参数V_EMPCOUNT。在存储过程中的SELECT…INTO…语句中对P_TOTAL进行赋值，赋值结果由V_EMPCOUNT变量带回给主程序并显示。 以上程序要覆盖同名的EMP_COUNT存储过程，如果不使用OR REPLACE选项，就会出现以下错误： ERROR 位于第 1 行: ORA-00955: 名称已由现有对象使用。 【练习2】创建存储过程，使用OUT类型参数获得雇员经理名。 以上程序要覆盖同名的EMP_COUNT存储过程，如果不使用OR REPLACE选项，就会出现以下错误： ERROR 位于第 1 行: ORA-00955: 名称已由现有对象使用。 【练习2】创建存储过程，使用OUT类型参数获得雇员经理名。 【训练4】 使用IN OUT类型的参数，给电话号码增加区码。 步骤1：登录SCOTT账户。 步骤2：在SQL*Plus输入区中输入并编译以下存储过程： 12345CREATE OR REPLACE PROCEDURE ADD_REGION(P_HPONE_NUM IN OUT VARCHAR2) AS BEGIN P_HPONE_NUM:='024-'||P_HPONE_NUM;END; 执行结果为： 过程已创建。 步骤3：输入以下程序并执行： 12345678SET SERVEROUTPUT ONDECLAREV_PHONE_NUM VARCHAR2(15);BEGINV_PHONE_NUM:='26731092';ADD_REGION(V_PHONE_NUM);DBMS_OUTPUT.PUT_LINE('新的电话号码：'||V_PHONE_NUM);END; 显示结果为： 新的电话号码：024-26731092 PL/SQL 过程已成功完成。 说明：变量V_HPONE_NUM既用来向存储过程传递旧电话号码，也用来向主程序返回新号码。新的号码在原来基础上增加了区号024和-。 创建和删除存储函数创建函数，需要有CREATE PROCEDURE或CREATE ANY PROCEDURE的系统权限。该权限可由系统管理员授予。创建存储函数的语法和创建存储过程的类似. 在可执行部分的RETURN(表达式)，用来生成函数的返回值，其表达式的类型应该和定义部分说明的函数返回值的数据类型一致。在函数的执行部分可以有多个RETURN语句，但只有一个RETURN语句会被执行，一旦执行了RETURN语句，则函数结束并返回调用环境。 一个存储函数在不需要时可以删除，但删除的人应是函数的创建者或者是拥有DROP ANY PROCEDURE系统权限的人。其语法如下： 1DROP FUNCTION 函数名； 重新编译一个存储函数时，编译的人应是函数的创建者或者拥有ALTER ANY PROCEDURE系统权限的人。重新编译一个存储函数的语法如下： 1234567ALTER PROCEDURE 函数名 COMPILE；``` 函数的调用者应是函数的创建者或拥有EXECUTE ANY PROCEDURE系统权限的人，或是被函数的拥有者授予了函数执行权限的账户。函数的引用和存储过程不同，函数要出现在程序体中，可以参加表达式的运算或单独出现在表达式中，其形式如下： ```sql变量名:=函数名(...) 【训练1】 创建一个通过雇员编号返回雇员名称的函数GET_EMP_NAME。 步骤1：登录SCOTT账户。 步骤2：在SQL*Plus输入区中输入以下存储函数并编译： 123456789101112131415161718CREATE OR REPLACE FUNCTION GET_EMP_NAME(P_EMPNO NUMBER DEFAULT 7788) RETURN VARCHAR2 AS V_ENAME VARCHAR2(10); BEGIN SELECT ENAME INTO V_ENAME FROM EMP WHERE EMPNO=P_EMPNO;RETURN(V_ENAME);EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('没有该编号雇员！'); RETURN (NULL); WHEN TOO_MANY_ROWS THEN DBMS_OUTPUT.PUT_LINE('有重复雇员编号！'); RETURN (NULL); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！'); RETURN (NULL);END; 步骤3：调用该存储函数，输入并执行以下程序： 1234BEGIN DBMS_OUTPUT.PUT_LINE('雇员7369的名称是：'|| GET_EMP_NAME(7369)); DBMS_OUTPUT.PUT_LINE('雇员7839的名称是：'|| GET_EMP_NAME(7839));END; 存储过程和函数的查看可以通过对数据字典的访问来查询存储过程或函数的有关信息，如果要查询当前用户的存储过程或函数的源代码，可以通过对USER_SOURCE数据字典视图的查询得到。USER_SOURCE的结构如下： 1DESCRIBE USER_SOURCE 【训练1】 查询过程EMP_COUNT的脚本。 在SQL*Plus中输入并执行如下查询： 1select TEXT from user_source WHERE NAME='EMP_COUNT'; 【训练2】 查询过程GET_EMP_NAME的参数。 在SQL*Plus中输入并执行如下查询： 1DESCRIBE GET_EMP_NAME 【训练2】 查询过程GET_EMP_NAME的参数。 在SQL*Plus中输入并执行如下查询： 12345678910111213141516DESCRIBE GET_EMP_NAME``` 【训练3】 在发生编译错误时，显示错误。 ```sqlSHOW ERRORS``` 说明：查询一个存储过程或函数是否是有效状态(即编译成功)，可以使用数据字典USER_OBJECTS的STATUS列.【训练4】 查询EMP_LIST存储过程是否可用： ```sqlSELECT STATUS FROM USER_OBJECTS WHERE OBJECT_NAME='EMP_LIST'; 当一个存储过程编译成功，状态变为VALID，会不会在某些情况下变成INVALID。结论是完全可能的。比如一个存储过程中包含对表的查询，如果表被修改或删除，存储过程就会变成无效INVALID。所以要注意存储过程和函数对其他对象的依赖关系。 如果要检查存储过程或函数的依赖性，可以通过查询数据字典USER_DENPENDENCIES来确定，该表结构如下： 1DESCRIBE USER_DEPENDENCIES; 还有一种情况需要我们注意：如果一个用户A被授予执行属于用户B的一个存储过程的权限，在用户B的存储过程中，访问到用户C的表，用户B被授予访问用户C的表的权限，但用户A没有被授予访问用户C表的权限，那么用户A调用用户B的存储过程是失败的还是成功的呢？答案是成功的。如果读者有兴趣，不妨进行一下实际测试。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[易错集二]]></title>
    <url>%2F2017%2F12%2F13%2F%E6%98%93%E9%94%99%E9%9B%86(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[oracle存储过程的易错点 第一点对于创建存储过程和修改命令窗口中可使用【set serveroutput on】而在SQL窗口不可使用： 命令窗口： undefined SQL窗口： undefined 第二点对于调用存储过程中 命令窗口 中可使用 execute procdure_name ，而在SQL窗口不用 第三点undefined undefined 第四点存储函数函数的调用要依赖DBMS_OUTPUT.PUT_LINE(); undefined]]></content>
      <categories>
        <category>易错集</category>
      </categories>
      <tags>
        <tag>易错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十三]]></title>
    <url>%2F2017%2F12%2F10%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十三章，主要是用来复习和巩固在课堂学习的知识！ 笔记IF语句1、IF-THEN-END IF形式 undefined 2、IF-THEN-ELSE-END IF形式 undefined 3．IF-THEN-ELSIF-ELSE-END IF形式 undefined CASE语句1．基本CASE结构 undefined 2.搜索CASE结构 undefined 循环1．基本LOOP循环 undefined 2.FOR LOOP循环 FOR循环是固定次数循环，格式如下： undefined 注：循环控制变量是隐含定义的，不需要声明。 下限和上限用于指明循环次数。正常情况下循环控制变量的取值由下限到上限递增，REVERSE关键字表示循环控制变量的取值由上限到下限递减。 3．WHILE LOOP循环 undefined 游标游标概念 游标是SQL的一个内存工作区，由系统或用户以变量的形式定义。游标的作用就是用于临时存储从数据库中提取的数据块。在某些情况下，需要把数据从存放在磁盘的表中调到计算机内存中进行处理，最后将处理结果显示出来或最终写回数据库。这样数据处理的速度才会提高，否则频繁的磁盘数据交换会降低效率。 游标有两种类型：显式游标和隐式游标。 在前述程序中用到的SELECT…INTO…查询语句，一次只能从数据库中 提取一行数据，系统都会使用一个隐式游标。 显式游标对应一个返回结果为多行多列的SELECT语句。 游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。 隐式游标属性 隐式游标的属性 返回值类型 意 义 SQL%ROWCOUNT 整型 代表DML语句成功执行的数据行数 SQL%FOUND 布尔型 值为TRUE代表插入、删除、更新或单行查询操作成功 SQL%NOTFOUND 布尔型 与SQL%FOUND属性返回值相反 SQL%ISOPEN 布尔型 DML执行过程中为真，结束后为假 如：使用隐式游标的属性，判断对雇员工资的修改是否成功。 步骤1：输入和运行以下程序： undefined 显式游标游标的使用分成以下4个步骤。a．声明游标 在DECLEAR部分按以下格式声明游标： undefined 参数是可选部分，所定义的参数可以出现在SELECT语句的WHERE子句中。如果定义了参数，则必须在打开游标时传递相应的实际参数。 b.打开游标 在可执行部分，按以下格式打开游标： undefined 打开游标时，SELECT语句的查询结果就被传送到了游标工作区。 c.提取数据 在可执行部分，按以下格式将游标工作区中的数据取到变量中。提取操作必须在打开游标之后进行。 undefined 游标打开后有一个指针指向数据区，FETCH语句一次返回指针所指的一行数据，要返回多行需重复执行，可以使用循环语句来实现。控制循环可以通过判断游标的属性来进行。 定义记录变量的方法如下： undefined d.关闭游标 undefined 显式游标打开后，必须显式地关闭。游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。 【例1】 用游标提取emp表中7788雇员的名称和职务。 undefined 【例2】 用游标提取emp表中7788雇员的姓名、职务和工资。 undefined 【例3】 显示工资最高的前3名雇员的名称和工资。 undefined 游标循环（重点）方法一：使用特殊的FOR循环形式显示全部雇员的编号和名称(省略掉定义记录变量、打开游标、提取数据、关闭游标)。 undefined 方法二：最简单方式 undefined 利用游标属性做循环条件【训练1】 使用游标的属性练习。 undefined PL/SQL的基本构成 PL/SQL语言是SQL语言的扩展，具有为程序开发而设计的特性，如数据封装、异常处理、面向对象等特性。PL/SQL是嵌入到Oracle服务器和开发工具中的，所以具有很高的执行效率和同Oracle数据库的完美结合。在PL/SQL模块中可以使用查询语句和数据操纵语句(即进行DML操作)，这样就可以编写具有数据库事务处理功能的模块。 至于数据定义(DDL)和数据控制(DCL)命令的处理，需要通过Oracle提供的特殊的DBMS_SQL包来进行。PL/SQL还可以用来编写过程、函数、包及数据库触发器。过程和函数也称为子程序，在定义时要给出相应的过程名和函数名。它们可以存储在数据库中成为存储过程和存储函数，并可以由程序来调用，它们在结构上同程序模块类似。 PL/SQL过程化结构的特点是：可将逻辑上相关的语句组织在一个程序块内；通过嵌入或调用子块，构造功能强大的程序；可将一个复杂的问题分解成为一组便于管理、定义和实现的小块。 PL/SQL块结构和基本语法要求PL/SQL程序的基本单元是块(BLOCK)，块就是实现一定功能的逻辑模块。一个PL/SQL程序由一个或多个块组成。块有固定的结构，也可以嵌套。一个块可以包括三个部分，每个部分由一个关键字标识。 块中各部分的作用解释如下： (1) DECLARE：声明部分标志。 (2) BEGIN：可执行部分标志。 (3) EXCEPTION：异常处理部分标志。 (4) END；：程序结束标志。 输出 使用函数DBMS_OUTPUT.PUT_LINE显示输出结果。 DBMS_OUTPUT是Oracle提供的包，该包有如下三个用于输出的函数，用于显示PL/SQL程序模块的输出信息。 第一种形式： undefined 用于输出字符串，但不换行，括号中的参数是要输出的字符串表达式。 第二种形式： undefined 用于输出一行字符串信息，并换行，括号中的参数是要输出的字符串表达式。 第三种形式： undefined 用来输出一个换行，没有参数。调用函数时，在包名后面用一个点“.”和函数名分隔，表示隶属关系。 要使用该方法显示输出数据，在SQL*Plus环境下要先执行一次如下的环境设置命令： undefined 用来打开DBMS_OUTPUT.PUT_LINE函数的屏幕输出功能，系统默认状态是OFF。其中，n表示输出缓冲区的大小。n的范围在2000～1 000 000之间，默认为2000。如果输出内容较多，需要使用SIZE n来设置较大的输出缓冲区。 在PL/SQL模块中可以使用查询语句和数据操纵语句(即进行DML操作)，所以PL/SQL程序是同SQL语言紧密结合在一起的。在PL/SQL程序中，最常见的是使用SELECT语句从数据库中获取信息，同直接执行SELECT语句不同，在程序中的SELECT语句总是和INTO相配合，INTO后跟用于接收查询结果的变量，形式如下： undefined 注意：接收查询结果的变量类型、顺序和个数同SELECT语句的字段的类型、顺序和个数应该完全一致。并且SELECT语句返回的数据必须是一行，否则将引发系统错误。当程序要接收返回的多行结果时，可以采用后面介绍的游标的方法。 使用INSERT、DELETE和UPDATE的语法没有变化，但在程序中要注意判断语句执行的状态，并使用COMMIT或ROLLBACK进行事务处理。 【训练1】 查询雇员编号为7788的雇员姓名和工资。 步骤1：用SCOTT账户登录SQL*Plus。 步骤2：在输入区输入以下程序： undefined 步骤3：按执行按钮或F5快捷键执行程序。 以上程序的作用是，查询雇员编号为7788的雇员姓名和工资，然后显示输出。这种方法同直接在SQL环境下执行SELECT语句显示雇员的姓名和工资比较，程序变得更复杂。那么两者究竟有什么区别呢？SQL查询的方法，只限于SQL环境，并且输出的格式基本上是固定的。而程序通过把数据取到变量中，可以进行复杂的处理，完成SQL语句不能实现的功能，并通过多种方式输出。 “–”是注释符号，后边是程序的注释部分。该部分不编译执行，所以在输入程序时可以省略。/……/中间也是注释部分，同“–”注释方法不同，它可以跨越多行进行注释。 PL/SQL程序的可执行语句、SQL语句和END结束标识都要以分号结束。 数据类型 量的基本数据类型同SQL部分的字段数据类型相一致，但是也有不同 变量的数据类型: LOB数据类型可以存储视频、音频或图片，支持随机访问，存储的数据可以位于数据库内或数据库外，具体有四种类型：BFILE、BLOB、CLOB、NCLOB。但是操纵大对象需要使用Oracle提供的DBMS_LOB包。 变量定义 变量定义: 变量的作用是用来存储数据，可以在过程语句中使用。 变量在声明部分可以进行初始化，即赋予初值。 变量的命名规则: 变量名不要和在程序中引用的字段名相重，如果相重，变量名会被当作列名来使用。 变量的作用范围是在定义此变量的程序范围内，如果程序中包含子块，则变量在子块中也有效。但在子块中定义的变量，仅在定义变量的子块中有效，在主程序中无效。 【训练1】 变量的定义和初始化。 输入和运行以下程序： undefined 根据表的字段定义变量变量的声明还可以根据数据库表的字段进行定义或根据已经定义的变量进行定义。 【训练2】 根据表的字段定义变量。 输入并执行以下程序： undefined 说明：变量v_ename是根据表emp的ename字段定义的，两者的数据类型总是一致的。 如果我们根据数据库的字段定义了某一变量，后来数据库的字段数据类型又进行了修改，那么程序中的该变量的定义也自动使用新的数据类型。使用该种变量定义方法，变量的数据类型和大小是在编译执行时决定的，这为书写和维护程序提供了很大的便利。 结合变量的定义和使用我们还可以定义SQLPlus环境下使用的变量，称为结合变量。结合变量也可以在程序中使用，该变量是在整个SQLPlus环境下有效的变量，在退出SQLPlus之前始终有效，所以可以使用该变量在不同的程序之间传递信息。结合变量不是由程序定义的，而是使用系统命令VARIABLE定义的。在SQLPlus环境下显示该变量要用系统的PRINT命令。 【训练3】 定义并使用结合变量。 步骤1：输入和执行下列命令，定义结合变量g_ename： undefined 步骤2：输入和执行下列程序： undefined 步骤3：重新执行程序。 输出结果： ? 步骤4：程序结束后用命令显示结合变量的内容： undefined 说明：g_ename为结合变量，可以在程序中引用或赋值，引用时在结合变量前面要加上“∶”。在程序结束后该变量的值仍然存在，其他程序可以继续引用。 记录变量的定义还可以根据表或视图的一个记录中的所有字段定义变量，称为记录变量。记录变量包含若干个字段，在结构上同表的一个记录相同，定义方法是在表名后跟%ROWTYPE。记录变量的字段名就是表的字段名，数据类型也一致。 【训练4】 根据表定义记录变量。 输入并执行如下程序： undefined TABLE类型变量在PL/SQL中可以定义TABLE类型的变量。 TABLE数据类型用来存储可变长度的一维数组数据，即数组中的数据动态地增长。要定义TABLE变量，需要先定义TABLE数据类型。通过使用下标来引用TABLE变量的元素。 【训练5】 定义和使用TABLE变量： undefined 说明：本例定义了长度为10的字符型TABLE变量，通过赋值语句为前五个元素赋值，最后输出第三个元素。 运算符和函数PL/SQL常见的运算符和函数包括以下方面(这里只做简单的总结，可参见SQL部分的例子)： 算术运算：加(+)、减(-)、乘(*)、除(/)、指数(**)。 关系运算：小于(&lt;)、小于等于(&lt;=)、大于(&gt;)、大于等于(&gt;=)、等于(=)、不等于(!=或&lt;&gt;)。 字符运算：连接(||)。 逻辑运算：与(AND)、或(OR)、非(NOT)。 特殊运算: IS NULL或IS NOT NULL用来判断运算对象的值是否为空，不能用“=”去判断。另外，对空值的运算也必须注意，对空值的算术和比较运算的结果都是空，但对空值可以进行连接运算，结果是另外一部分的字符串。例如： undefined 结构控制语句分支结构 分支结构是最基本的程序结构，分支结构由IF语句实现。 IF-THEN-END IF形式这是最简单的IF结构，练习如下： 【训练1】 如果温度大于30℃，则显示“温度偏高”。 输入并执行以下程序： undefined IF-THEN-ELSE-END IF形式这种形式的练习如下： 【训练2】 根据性别，显示尊称。 输入并执行以下程序： undefined 说明：该程序根据性别显示尊称和问候，无论性别的值为何，总会有显示结果输出。如果V_sex的值不是‘男’和‘女’，那么输出结果会是什么？ IF-THEN-ELSIF-ELSE-END IF形式这种形式的练习如下： 【训练3】 根据雇员工资分级显示税金。 输入并运行以下程序： undefined 选择结构CASE语句适用于分情况的多分支处理，可有以下三种用法。1．基本CASE结构 2．表达式结构CASE语句在Oracle中，CASE结构还能以赋值表达式的形式出现，它根据选择变量的值求得不同的结果。 3．搜索CASE结构Oracle还提供了一种搜索CASE结构，它没有选择变量，直接判断条件表达式的值，根据条件表达式决定转向。 基本CASE结构训练1】 使用CASE结构实现职务转换。 输入并执行程序： undefined 说明：以上实例检索雇员7788的职务，通过CASE结构转换成中文输出。 表达式结构CASE语句【训练2】 使用CASE的表达式结构。 undefined 说明：该CASE表达式通过判断变量v_grade的值，对变量V_result赋予不同的值。 搜索CASE结构【训练3】 使用CASE的搜索结构。 undefined 循环结构循环结构是最重要的程序控制结构，用来控制反复执行一段程序。比如我们要进行累加，则可以通过适当的循环程序实现。PL/SQL循环结构可划分为以下3种： 1.基本LOOP循环。EXIT用于在循环过程中退出循环，WHEN用于定义EXIT的退出条件。如果没有WHEN条件，遇到EXIT语句则无条件退出循环。 2.FOR LOOP循环。 FOR循环是固定次数循环，格式如下： undefined 循环控制变量是隐含定义的，不需要声明。 下限和上限用于指明循环次数。正常情况下循环控制变量的取值由下限到上限递增，REVERSE关键字表示循环控制变量的取值由上限到下限递减。 3.WHILE LOOP循环。 多重循环 基本LOOP循环【训练1】 求：1２+3２+5２+…+15２ 的值。 输入并执行以下程序： undefined 说明：基本循环一定要使用EXIT退出，否则就会成为死循环。 【训练2】 用FOR循环输出图形。 undefined 说明：该程序在循环中使用了循环控制变量I，该变量隐含定义。在每次循环中根据循环控制变量I的值，使用RPAD函数控制显示相应个数的“*”。 【练习2】为以上程序增加REVERSE关键字，观察执行结果。 【训练3】 输出一个空心三角形。 undefined 说明：该实例采用循环和IF结构相结合，对第1行和第9行(I=1 OR I=9)执行同样的输出语句，其他行执行另外的输出语句。 WHILE LOOP循环【训练3】 使用WHILE 循环向emp表连续插入5个记录。 步骤1：执行下面的程序： undefined 步骤2：显示插入的记录： undefined 步骤3：删除插入的记录： undefined 多重循环(了解)循环可以嵌套，以下是一个二重循环的练习。 【训练4】 使用二重循环求1！+2！+…+10！的值。 步骤1：第1种算法： undefined 步骤2：第2种算法： undefined 阶段训练训练1】 插入雇员，如果雇员已经存在，则输出提示信息。 undefined 说明：在本程序中，使用了一个技巧来判断一个雇员是否存在。如果一个雇员不存在，那么使用SELECT…INTO来获取雇员信息就会失败，因为SELECT…INTO形式要求查询必须返回一行。但如果使用COUNT统计查询，返回满足条件的雇员人数，则该查询总是返回一行，所以任何情况都不会失败。COUNT返回的统计人数为0说明雇员不存在，返回的统计人数为1说明雇员存在，返回的统计人数大于1说明有多个满足条件的雇员存在。本例在雇员不存在时进行插入操作，如果雇员已经存在则不进行插入。 【训练2】 输出由符号“*”构成的正弦曲线的一个周期(0～360°)。 undefined 说明：在本程序中使用到了固定次数的循环以及SIN和LPAD函数，通过正确地设置步长、幅度和位移的参数，在屏幕上可正确地显示图形。 游标的概念游标是SQL的一个内存工作区，由系统或用户以变量的形式定义。游标的作用就是用于临时存储从数据库中提取的数据块。在某些情况下，需要把数据从存放在磁盘的表中调到计算机内存中进行处理，最后将处理结果显示出来或最终写回数据库。这样数据处理的速度才会提高，否则频繁的磁盘数据交换会降低效率。 游标有两种类型：显式游标和隐式游标。 在前述程序中用到的SELECT…INTO…查询语句，一次只能从数据库中 提取一行数据，系统都会使用一个隐式游标。 显式游标对应一个返回结果为多行多列的SELECT语句。 游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。 隐式游标如前所述，DML操作和单行SELECT语句会使用隐式游标，它们是： * 插入操作：INSERT。 * 更新操作：UPDATE。 * 删除操作：DELETE。 * 单行查询操作：SELECT ... INTO ...。 当系统使用一个隐式游标时，可以通过隐式游标的属性来了解操作的状态和结果，进而控制程序的流程。 通过SQL游标名总是只能访问前一个DML操作或单行SELECT操作的游标属性。所以通常在刚刚执行完操作之后，立即使用SQL游标名来访问属性。游标的属性有四种 隐式游标属性： 【训练1】 使用隐式游标的属性，判断对雇员工资的修改是否成功。 步骤1：输入和运行以下程序： undefined 步骤2：将雇员编号1234改为7788，重新执行以上程序： 说明：本例中，通过SQL%FOUND属性判断修改是否成功，并给出相应信息。 显式游标游标的定义和操作游标的使用分成以下4个步骤。 1．声明游标 在DECLEAR部分按以下格式声明游标： undefined 参数是可选部分，所定义的参数可以出现在SELECT语句的WHERE子句中。如果定义了参数，则必须在打开游标时传递相应的实际参数。 语句的查询结果就被传送到了游标工作区。SELECT语句是对表或视图的查询语句，甚至也可以是联合查询。可以带WHERE条件、ORDER BY或GROUP BY等子句，但不能使用INTO子句。在SELECT语句中可以使用在定义游标之前定义的变量。 2．打开游标 在可执行部分，按以下格式打开游标： undefined 3．提取数据 在可执行部分，按以下格式将游标工作区中的数据取到变量中。提取操作必须在打开游标之后进行。 undefined 游标打开后有一个指针指向数据区，FETCH语句一次返回指针所指的一行数据，要返回多行需重复执行，可以使用循环语句来实现。控制循环可以通过判断游标的属性来进行。 下面对这两种格式进行说明： 第一种格式中的变量名是用来从游标中接收数据的变量，需要事先定义。变量的个数和类型应与SELECT语句中的字段变量的个数和类型一致。 第二种格式一次将一行数据取到记录变量中，需要使用%ROWTYPE事先定义记录变量，这种形式使用起来比较方便，不必分别定义和使用多个变量。 定义记录变量的方法如下： undefined 其中的表必须存在，游标名也必须先定义。 4．关闭游标 undefined 显式游标打开后，必须显式地关闭。游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。 以下是使用显式游标的一个简单练习。 【训练1】 用游标提取emp表中7788雇员的名称和职务。 undefined 说明：该程序通过定义游标emp_cursor，提取并显示雇员7788的名称和职务。 作为对以上例子的改进，在以下训练中采用了记录变量。 【训练2】 用游标提取emp表中7788雇员的姓名、职务和工资。 undefined 说明：实例中使用记录变量来接收数据，记录变量由游标变量定义，需要出现在游标定义之后。 注意：可通过以下形式获得记录变量的内容： 记录变量名.字段名。 【训练3】 显示工资最高的前3名雇员的名称和工资。 undefined 说明：该程序在游标定义中使用了ORDER BY子句进行排序，并使用循环语句来提取多行数据。 ##游标循环 【训练1】 使用特殊的FOR循环形式显示全部雇员的编号和名称。 undefined 说明：可以看到该循环形式非常简单，隐含了记录变量的定义、游标的打开、提取和关闭过程。Emp_record为隐含定义的记录变量，循环的执行次数与游标取得的数据的行数相一致。 【训练2】 另一种形式的游标循环。 undefined 说明：该种形式更为简单，省略了游标的定义，游标的SELECT查询语句在循环中直接出现。 显式游标属性虽然可以使用前面的形式获得游标数据，但是在游标定义以后使用它的一些属性来进行结构控制是一种更为灵活的方法 标的属性: 可按照以下形式取得游标的属性： undefined 要判断游标emp_cursor是否处于打开状态，可以使用属性emp_cursor%ISOPEN。如果游标已经打开，则返回值为“真”，否则为“假”。具体可参照以下的训练。 【训练1】 使用游标的属性练习。 undefined 说明：本例使用emp_cursor%ISOPEN判断游标是否打开；使用emp_cursor%ROWCOUNT获得到目前为止FETCH语句返回的数据行数并输出；使用循环来获取数据，在循环体中使用FETCH语句；使用emp_cursor%NOTFOUND判断FETCH语句是否成功执行，当FETCH语句失败时说明数据已经取完，退出循环。 【练习1】去掉OPEN emp_cursor;语句，重新执行以上程序。 游标参数的传递【训练1】 带参数的游标。 undefined 说明：游标emp_cursor定义了两个参数：p_deptno代表部门编号，p_job代表职务。语句OPEN emp_cursor(10, ‘CLERK’)传递了两个参数值给游标，即部门为10、职务为CLERK，所以游标查询的内容是部门10的职务为CLERK的雇员。循环部分用于显示查询的内容。 【练习1】修改Open语句的参数：部门号为20、职务为ANALYST，并重新执行。 也可以通过变量向游标传递参数，但变量需要先于游标定义，并在游标打开之前赋值。对以上例子重新改动如下： 【训练2】 通过变量传递参数给游标。 undefined 说明：该程序与前一程序实现相同的功能。 动态SELECT语句和动态游标的用法Oracle支持动态SELECT语句和动态游标，动态的方法大大扩展了程序设计的能力。 对于查询结果为一行的SELECT语句，可以用动态生成查询语句字符串的方法，在程序执行阶段临时地生成并执行，语法是： undefined 以下是一个动态生成SELECT语句的例子。 【训练1】 动态SELECT查询。 undefined 说明：SELECT…INTO…语句存放在STR字符串中，通过EXECUTE语句执行。 在变量声明部分定义的游标是静态的，不能在程序运行过程中修改。虽然可以通过参数传递来取得不同的数据，但还是有很大的局限性。通过采用动态游标，可以在程序运行阶段随时生成一个查询语句作为游标。要使用动态游标需要先定义一个游标类型，然后声明一个游标变量，游标对应的查询语句可以在程序的执行过程中动态地说明。 定义游标类型的语句如下： undefined 声明游标变量的语句如下： undefined 在可执行部分可以如下形式打开一个动态游标： undefined 【训练2】 按名字中包含的字母顺序分组显示雇员信息。 输入并运行以下程序： undefined 说明：使用了二重循环，在外循环体中，动态生成游标的SELECT语句，然后打开。通过语句letter:=chr(ascii(letter)+1)可获得字母表中的下一个字母。 例题（一）【训练1】 查询雇员编号为7788的雇员姓名和工资。 步骤1：用SCOTT账户登录SQL*Plus。 步骤2：在输入区输入以下程序： undefined 步骤3：按执行按钮或F5快捷键执行程序。 【训练2】 变量的定义和初始化。 输入和运行以下程序： undefined 【训练3】 根据表的字段定义变量。 输入并执行以下程序： undefined 【训练4】 定义并使用结合变量。步骤1：输入和执行下列命令，定义结合变量g_ename： undefined 步骤2：输入和执行下列程序： undefined 步骤3：重新执行程序。 步骤4：程序结束后用命令显示结合变量的内容： undefined 【训练5】 根据表定义记录变量。 输入并执行如下程序： undefined 【训练6】 定义和使用TABLE变量： undefined 【训练7】 如果温度大于30℃，则显示“温度偏高”。输入并执行以下程序： undefined 试修改温度的初值为25℃，重新执行，观察结果。 【训练8】 根据性别，显示尊称。 输入并执行以下程序： undefined 【训练9】 根据雇员工资分级显示税金。 输入并运行以下程序： undefined 例题（二）【训练1】 使用CASE结构实现职务转换。 输入并执行程序： undefined 【训练2】 使用CASE的表达式结构。 undefined 【训练3】 使用CASE的搜索结构。 undefined 【训练4】 求：1２+3２+5２+…+15２ 的值。 输入并执行以下程序： undefined 【训练5】 用FOR循环输出图形。 undefined 【训练6】 输出一个空心三角形。 undefined 【训练7】 使用WHILE 循环向emp表连续插入5个记录。步骤1：执行下面的程序： undefined 步骤2：显示插入的记录： undefined 步骤3：删除插入的记录： undefined 【训练8】 使用二重循环求1！+2！+…+10！的值。 步骤1：第1种算法： undefined 步骤2：第2种算法： undefined 【训练9】 插入雇员，如果雇员已经存在，则输出提示信息。 undefined 【训练10】 输出由符号“*”构成的正弦曲线的一个周期(0～360°)。 undefined ## 例题（三）【训练1】 使用隐式游标的属性，判断对雇员工资的修改是否成功。 步骤1：输入和运行以下程序： undefined 步骤2：将雇员编号1234改为7788，重新执行以上程序： 【训练2】 用游标提取emp表中7788雇员的名称和职务。 undefined 【训练3】 用游标提取emp表中7788雇员的姓名、职务和工资。 undefined 【训练4】 显示工资最高的前3名雇员的名称和工资。 undefined 【训练5】 使用特殊的FOR循环形式显示全部雇员的编号和名称。 undefined 【训练6】 另一种形式的游标循环。 undefined 【训练7】 使用游标的属性练习。 undefined 【训练8】 带参数的游标。 undefined 【训练9】 通过变量传递参数给游标。 undefined 【训练10】 动态SELECT查询。 undefined 【训练11】 按名字中包含的字母顺序分组显示雇员信息。 输入并运行以下程序： declare type cur_type is ref cursor; cur cur_type;--声明为一个未绑定的游标 rec scott.emp%rowtype; str varchar2(50); letter char:= 'A'; begin loop str:= 'select ename from emp where ename like ''%'||letter||'%'''; open cur for str;--打开游标变量方式1 dbms_output.put_line('包含字母'||letter||'的名字：'); loop fetch cur into rec.ename; exit when cur%notfound; dbms_output.put_line(rec.ename); end loop; exit when letter='Z'; letter:=chr(ascii(letter)+1); end loop; end;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DW快捷键]]></title>
    <url>%2F2017%2F12%2F09%2FDW%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[DW快捷键！ 文档操作 功能 快捷键 新建文档 Ctrl+N 打开一个 HTML文件 Ctrl+O或者将文件从[文件管理器]或[站点]窗口拖动到[文档]窗口中 在框架中打开 Ctrl+Shift+O 关闭 Ctrl+W 保存 Ctrl+S 另存为 Ctrl+Shift+S 检查链接 Shift + F8 退出 Ctrl+Q 编辑菜单 功能 快捷键 撤消 Ctrl+Z 重复 Ctrl+Y 或 Ctrl+Shift+Z 剪切 Ctrl+X 或Shift+Del 拷贝 Ctrl+C 或Ctrl+Ins 粘贴 Ctrl+V 或Shift+Ins 清除 Delete 全选 Ctrl+A 选择父标签 Ctrl+Shift+&lt; 选择子标签 Ctrl+Shift+&gt; 查找和替换 Ctrl+F 查找下一个 F3 缩进代码 Ctrl+Shift+] 左缩进代码 Ctrl+Shift+[ 平衡大括弧 Ctrl+’ 启动外部编辑器 Ctrl+E 参数选择 Ctrl+U 页面视图 功能 快捷键 标准视图 Ctrl+Shift+F6 布局视图 Ctrl+F6 工具条 Ctrl+Shift+T 查看页面元素 功能 快捷键 可视化助理 Ctrl+Shift+I 标尺 Ctrl+Alt+R 显示网格 Ctrl+Alt+G 靠齐到网格 Ctrl+Alt+Shift+G 头内容 Ctrl+Shift+W 页面属性 Ctrl+Shift+J 代码编辑 功能 快捷键 切换到设计视图 Ctrl+Tab 打开快速标签编辑器 Ctrl+T 选择父标签 Ctrl+Shift+&lt; 平衡大括弧 Ctrl+’ 全选 Ctrl+A 拷贝 Ctrl+C 查找和替换 Ctrl+F 查找下一个 F3 替换 Ctrl+H 粘贴 Ctrl+V 剪切 Ctrl+X 重复 Ctrl+Y 撤消 Ctrl+Z 切换断点 Ctrl+Alt+B 向上选择一行 Shift+Up 向下选择一行 Shift+Down 选择左边字符 Shift+Left 选择右边字符 Shift+Right 向上翻页 Page Up 向下翻页 Page Down 向上选择一页 Shift+Page Up 向下选择一页 Shift+Page Down 选择左边单词 Ctrl+Shift+Left 选择右边单词 Ctrl+Shift+Right 移到行首 Home 移到行尾 End 移 动到代码顶部 Ctrl+Home 移 动到代码尾部 Ctrl+End 向上选择到代码顶部 Ctrl+Shift+Home 向下选择到代码顶部 Ctrl+Shift+End 编辑文本 功能 快捷键 创建新段落 Enter 插入换行 Shift+Enter 插入不换行空格 Ctrl+Shift+Spacebar 拷贝文本或对象到页面其他位置 Ctrl+拖动选取项目到新位置 选取一个单词 双击 将选定项目添加到库 Ctrl+Shift+B 在设计视图和代码编辑器之间切换 Ctrl+Tab 打开和关闭[属性]检查器 Ctrl+Shift+J 检查拼写 Shift+F7 格式化文本 功能 快捷键 缩进 Ctrl+] 左缩进 Ctrl+[ 格式&gt;无 Ctrl+0 (零) 段落格式 Ctrl+Shift+P 应用标题1到6到段落 Ctrl+1 到 6 对齐&gt;左对齐 Ctrl+Shift+Alt+L 对齐&gt;居中 Ctrl+Shift+Alt+C 对齐&gt;右对齐 Ctrl+Shift+Alt+R 加粗选定文本 Ctrl+B 倾斜选定文本 Ctrl+I 编辑样式表 Ctrl+Shift+E 查找和替换文本 功能 快捷键 查找 Ctrl+F 查找下一个/再查找 F3 替换 Ctrl+H 处理表格 功能 快捷键 选择表格（光标在表格中） Ctrl+A 移 动到下一单元格 Tab 移 动到上一单元格 Shift+Tab 插入行（在当前行之前） Ctrl+M 在表格末插入一行 在最后一个单元格 Tab 删除当前行 Ctrl+Shift+M 插入列 Ctrl+Shift+A 删除列 Ctrl+Shift+ - (连字符) 合并单元格 Ctrl+Alt+M 拆分单元格 Ctrl+Alt+S 更新表格布局（在“快速表格编辑”模式中强制重绘） Ctrl+Spacebar 处理框架 功能 快捷键 选择框架 框架中Alt+点击 选择下一框架或框架页 Alt+右方向键 选择上一框架或框架页 Alt+左方向键 选择父框架 Alt+上方向键 选择子框架或框架页 Alt+下方向键 添加新框架到框架页 Alt+从框架边界拖动 使用推模式添加新框架到框架页 Alt+Ctrl+从框架边界拖动 处理层 功能 快捷键 选择层 Ctrl+Shift+点击 选择并移 动层 Shift+Ctrl+拖动 从选择中添加或删除层 Shift+点击层 以象素为单位移 动所选层 上方向键 按靠齐增量移 动所选层 Shift+方向键 以象素为单位调整层大小 Ctrl+方向键 以靠齐增量为单位调整层大小 Ctrl+Shift+方向键 将所选层与最后所选层的顶部/底部/左边/右边对齐 Ctrl+上/下/左/右方向键 统一所选层宽度 Ctrl+Shift+[ 统一所选层高度 Ctrl+Shift+] 创建层时切换嵌套设置 Ctrl+拖动 切换网格显示 Ctrl+Shift+Alt+G 靠齐到网格 Ctrl+Alt+G 处理时间轴,图象 功能 快捷键 添加对象到时间轴 Ctrl+Alt+Shift+T 添加关键帧 Shift+F9 删除关键帧 Delete 改变图象源文件属性 Double+点击图象 在外部编辑器中编辑图象 Ctrl+双击图象 管理超链接 功能 快捷键 创建超链接（选定文本） Ctrl+L 删除超链接 Ctrl+Shift+L 拖动并投放以从文档创建超链接 选取文本，图象或对象，然后Shift+拖动选择到[站点]窗口中的文件 拖动并投放以使用[属性]检查器创建超链接 选取文本，图象或对象，然后拖动[属性]检查器的指向文件图表到[站点]窗口的文件 在Dreamweaver打开链接文档 Ctrl+双击链接 检查选定链接 Shift+F8 检查整个站点中的链接 Ctrl+F8 在浏览器中定位和预览 功能 快捷键 在主浏览器中预览 F12 在次要浏览器中预览 Ctrl+F12 在浏览器中调试 功能 快捷键 在主浏览器中调试 Alt+F12 在次要浏览器中调试 Ctrl+Alt+F12 站点管理和FTP 功能 快捷键 创建新文件 Ctrl+Shift+N 创建新文件夹 Ctrl+Shift+Alt+N 打开选定 Ctrl+Shift+Alt+O 从远程FTP站点下载选定文件或文件夹 Ctrl+Shift+D或将文件从[站点]窗口的[远程]栏拖动到[本地]栏 将选定文件或文件夹上载到远程FTP站点 Ctrl+Shift+U或将文件从[站点]窗口的[本地]栏拖动到[远程]栏 取出 Ctrl+Shift+Alt+D 存回 Ctrl+Shift+Alt+U 查看站点地图 Alt+F8 刷新远端站点 Alt+F5 站点地图 功能 快捷键 查看站点文件 F8 刷新本地栏 Shift+F5 设为根 Ctrl+Shift+R 链接到现存文件 Ctrl+Shift+K 改变链接 Ctrl+L 删除链接 Delete 功能 快捷键 显示/隐藏链接 Ctrl+Shift+Y 显示页面标题 Ctrl+Shift+T 重命名文件 F2 放大站点地图 Ctrl+ + (plus) 缩小站点地图 Ctrl+ - (hyphen) 播放插件 功能 快捷键 播放插件 Ctrl+Alt+P 停止插件 Ctrl+Alt+X 播放所有插件 Ctrl+Shift+Alt+P 停止所有插件 Ctrl+Shift+Alt+X 处理模板 功能 快捷键 创建新的可编辑区域 Ctrl+Alt+V 插入对象 功能 快捷键 任何对象（图象，Shockwave影片等） 文件从[资源管理器]或[站点]窗口拖动到[文档]窗口 图象 Ctrl+Alt+I 表格 Ctrl+Alt+T Flash影片 Ctrl+Alt+F Shockwave和Director影片 Ctrl+Alt+D 命名锚记 Ctrl+Alt+A 历史纪录面板 功能 快捷键 打开[历史纪录]面板 Shift F10 开始/停止录制命令 Ctrl+Shift+X 播放录制好的命令 Ctrl+P 打开和关闭面板 功能 快捷键 对象 Ctrl+F2 属性 Ctrl+F3 站点文件 F5 站点地图 trl+F5 资源 F11 CSS样式 Shift+F11 HTML样式 Ctrl+F11 行为 Shift+F3 历史纪录 Shift+F10 时间轴 Shift+F9 代码检查器 F10 框架 Shift+F2 层 F2 参考 Ctrl+Shift+F1 显示/隐藏浮动面板 F4 最小化所有窗口 Shift+F4 最大化所有窗口 Alt+Shift+F4 获得帮助 功能 快捷键 使用Dreamweaver[帮助主题] F1 参考 Shift+F1 Dreamweaver支持中心 Ctrl+F1 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>DW cc 快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[易错集（一）]]></title>
    <url>%2F2017%2F12%2F09%2F%E6%98%93%E9%94%99%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[sql server delete truncat drop 三者区别 sql server 插入数据的几种方式 html5背景音乐 背景音乐的控制 sql server delete truncat drop 三者区别 相同点： 1.truncate和不带where子句的delete、以及drop都会删除表内的数据。 2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。 不同点： truncate 和 delete 只删除数据不删除表的结构(定义)drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。 delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。 3.delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动drop 语句将表所占用的空间全部释放。truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。 4.速度，一般来说: drop&gt; truncate &gt; delete 5.安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.想删除表,当然用 drop想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。 6.delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交。 7、TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 8、TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 9、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 10、TRUNCATE TABLE 不能用于参与了索引视图的表。 参考 sql server 插入数据的几种方式 单行插入： insert into [table] values (); 示例： insert into student (No,Name,Sex) values (1,&apos;小丽&apos;，&apos;女&apos;); -- 不整行插入（键对值） insert into student values (1,&apos;小丽&apos;，&apos;女&apos;); -- 整行插入; 多行插入(1)： Insert into [Table2](field1,field2,...) select value1,value2,... from [Table1] Table1和Table2表都存在 示例： --1.创建测试表 create TABLE Table1 ( a varchar(10), b varchar(10), c varchar(10) ) create TABLE Table2 ( a varchar(10), c varchar(10), d int ) --2.创建测试数据 Insert into Table1 values(&apos;张三&apos;,&apos;123456&apos;,&apos;90&apos;) Insert into Table1 values(&apos;李四&apos;,&apos;123456&apos;&apos;,&apos;100&apos;) Insert into Table1 values(&apos;王五&apos;,&apos;123456&apos;&apos;,&apos;80&apos;) Insert into Table1 values(&apos;赵六&apos;,&apos;123456&apos;&apos;,null) --3.INSERT INTO SELECT语句复制表数据部分列和常值 Insert into Table2(a, c, d) select a,c,5 from Table1 或： Insert into Table2 select * from Table1 多行插入(2)： SELECT vale1, value2 into Table2 from Table1 -- Table2表不存在 示例： --1.创建测试表 create TABLE Table1 ( a varchar(10), b varchar(10), c varchar(10) ) --2.创建测试数据 Insert into Table1 values(&apos;张三&apos;,&apos;123456&apos;,&apos;90&apos;) Insert into Table1 values(&apos;李四&apos;,&apos;123456&apos;&apos;,&apos;100&apos;) Insert into Table1 values(&apos;王五&apos;,&apos;123456&apos;&apos;,&apos;80&apos;) Insert into Table1 values(&apos;赵六&apos;,&apos;123456&apos;&apos;,null) --3.SELECT INTO FROM语句创建表Table2并复制数据 select a,c INTO Table2 from Table1 多行插入(3)： --去重复（会把完全重复的数据过滤掉） insert into [table1](例名) select (例名值) union select (例名值) union ... 或： -- 不去重复(会保留完全重复的数据) insert into [table1](例名) select (例名值) union all select (例名值) union all 示例： -- 只会插入两条数据，因为会把完全重复的数据过滤掉 insert into test(No,name) select 1,&apos;a&apos; union select 2,&apos;b&apos; union select 1,&apos;a&apos; -- 如果有完全相同的数据要插入，则用union all insert into test(No,name) select 1,&apos;a&apos; union select 2,&apos;b&apos; union select 1,&apos;a&apos; 参考 html5背景音乐 属性 值 描述 autoplay autoplay 如果出现该属性，则音频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 loop loop 如果出现该属性，则每当音频结束时重新循环开始播放。 preload preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。 如果使用 “autoplay”，则忽略该属性。src|url|要播放的音频的 URL。也可以使用标签来设置音频。 第一种： //会显示播放器 &lt;video controls=&quot;&quot; autoplay=&quot;&quot; name=&quot;media&quot;&gt;&lt;source src=&quot;/&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/video&gt; 第二种： //能支持大部分的浏览器 &lt;embed src=&quot;/&quot; autostart=&quot;true&quot; loop=&quot;true&quot; hidden=&quot;true&quot;&gt;&lt;/embed&gt; 第三种： //不显示播放器 &lt;audio autoplay=&quot;&quot; loop=&quot;&quot;&gt;&lt;source src=&quot;/&quot;&gt;&lt;/audio&gt; 第四种： //最简洁的 &lt;bgsound src=背景音乐链接地址 loop=-1&gt; 第五种： &lt;audio src=&quot;/&quot; id=&quot;aud&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt; 背景音乐的控制代码： undefined]]></content>
      <categories>
        <category>易错集</category>
      </categories>
      <tags>
        <tag>易错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十二]]></title>
    <url>%2F2017%2F12%2F09%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十二章，主要是用来复习和巩固在课堂学习的知识！ 笔记 索引 索引(INDEX)是为了加快数据的查找而创建的数据库对象，特别是对大表，索引可以有效地提高查找速度，也可以保证数据的惟一性创建索引一般要掌握以下原则：只有较大的表才有必要建立索引，表的记录应该大于50条，查询数据小于总行数的2%～4%。虽然可以为表创建多个索引，但是无助于查询的索引不但不会提高效率，还会增加系统开销。因为当执行DML操作时，索引也要跟着更新，这时索引可能会降低系统的性能。创建索引： 1CREATE INDEX 索引名 ON 表名(列名); 删除索引： 1DROP INDEX 索引名； 同义词 同义词(SYNONYM)是为模式对象起的别名，可以为表、视图、序列、过程、函数和包等数据库模式对象创建同义词。创建私有同义词： 1CREATE SYNONYM BOOK FOR 图书； 创建公有同义词(先要获得创建公有同义词的权限)： 1CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书； 删除同义词： 1DROP SYNONYM 同义词名； 数据库链接 数据库链接(DATABASE LINK)是在分布式环境下，为了访问远程数据库而创建的数据通信链路。 格式： 1CREATE DATABASE LINK 链接名 CONNECT TO 账户 IDENTIFIED BY 口令 USING 服务名; 数据库链接一旦建立并测试成功，就可以使用以下形式来访问远程用户的表。 表名@数据库链接名 PL/sql 1.块结构和基本语法要求 块中各部分的作用解释如下： 1234567(1) DECLARE：声明部分标志。(2) BEGIN：可执行部分标志。(3) EXCEPTION：异常处理部分标志。(4) END；：程序结束标志。 2、输出第一种形式： 1DBMS_OUTPUT.PUT(字符串表达式)； 第二种形式： 1DBMS_OUTPUT.PUT_LINE(字符串表达式)； 第三种形式： 1DBMS_OUTPUT.NEW_LINE； 3、变量赋值： 第一种形式：SELECT 列名1，列名2… INTO 变量1，变量2… FROM 表名 WHERE 条件； 第二种形式：变量名:=值 例：查询雇员编号为7788的雇员姓名和工资。SET SERVEROUTPUT ON 123456789101112131415161718192021DECLARE--定义部分标识 v_name VARCHAR2(10); --定义字符串变量v_name v_sal NUMBER(5); --定义数值变量v_sal BEGIN --可执行部分标识SELECT ename,sal INTO v_name,v_sal FROM emp WHERE empno=7788;--在程序中插入的SQL语句 DBMS_OUTPUT.PUT_LINE('7788号雇员是：'||v_name||'，工资为：'||to_char(v_sal));--输出雇员名和工资 END;``` 4、结合变量的定义和使用（即全局变量） - 该变量是在整个SQL*Plus环境下有效的变量，在退出SQL*Plus之前始终有效，所以可以使用该变量在不同的程序之间传递信息。结合变量不是由程序定义的，而是使用系统命令VARIABLE定义的。例：定义并使用结合变量步骤1：输入和执行下列命令，定义结合变量g_ename： ```sql VARIABLE g_ename VARCHAR2(100) 步骤2：输入和执行下列程序： 123456789SET SERVEROUTPUT ON BEGIN :g_ename:=:g_ename|| 'Hello~ '; --在程序中使用结合变量 DBMS_OUTPUT.PUT_LINE(:g_ename); --输出结合变量的值 END; 5．记录变量的定义 还可以根据表或视图的一个记录中的所有字段定义变量，称为记录变量。记录变量包含若干个字段，在结构上同表的一个记录相同，定义方法是在表名后跟%ROWTYPE。记录变量的字段名就是表的字段名，数据类型也一致。 如： 1v_name emp.ename%TYPE; 数据库模式对象 Oracle数据库的模式对象 对 象 名 称 作 用 TABLE 表 用于存储数据的基本结构 VIEW 视图 以不同的侧面反映表的数据，是一种逻辑上的表 INDEX 索引 加快表的查询速度 CLUSTER 聚簇 将不同表的字段并用的一种特殊结构的表集合 SEQUENCE 序列 生成数字序列，用于在插入时自动填充表的字段 SYNONYM 同义词 为简化和便于记忆，给对象起的别名 DATABASE LINK 数据库链接 为访问远程对象创建的通道 STORED PROCEDURE、FUNCTION 存储过程和函数 存储于数据库中的可调用的程序和函数 PACKAGE、PACKAGE BODY 包和包体 将存储过程、函数及变量按功能和类别进行捆绑 索引 索引(INDEX)是为了加快数据的查找而创建的数据库对象，特别是对大表，索引可以有效地提高查找速度，也可以保证数据的惟一性。索引是由Oracle自动使用和维护的，一旦创建成功，用户不必对索引进行直接的操作。索引是独立于表的数据库结构，即表和索引是分开存放的，当删除索引时，对拥有索引的表的数据没有影响。 在创建PRIMARY KEY和UNIQUE约束条件时，系统将自动为相应的列创建惟一(UNIQUE)索引。索引的名字同约束的名字一致。 索引有两种：B*树索引和位图(BITMAP)索引。 【B树索引是通常使用的索引，也是默认的索引类型。在这里主要讨论B树索引。B*树是一种平衡2叉树，左右的查找路径一样。这种方法保证了对表的任何值的查找时间都相同。】 【B*树索引可分为：惟一索引、非惟一索引、一列简单索引和多列复合索引。】 创建索引一般要掌握以下原则：只有较大的表才有必要建立索引，表的记录应该大于50条，查询数据小于总行数的2%～4%。虽然可以为表创建多个索引，但是无助于查询的索引不但不会提高效率，还会增加系统开销。因为当执行DML操作时，索引也要跟着更新，这时索引可能会降低系统的性能。一般在主键列或经常出现在WHERE子句或连接条件中的列建立索引，该列称为索引关键字。 索引的创建 创建索引不需要特定的系统权限。索引会自动被引用。 1DROP INDEX 索引名； 【训练1】 创建和删除索引。 步骤1：创建索引： 1CREATE INDEX EMP_ENAME ON EMP(ENAME); 步骤2：查询中引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE ENAME='SCOTT'; 步骤3：删除索引： 1DROP INDEX EMP_ENAME; 【训练2】 创建复合索引。索引出现在WHERE子句中的时候就会被自动被引用。 步骤1：创建复合索引： 1CREATE INDEX EMP_JOBSAL ON EMP(JOB,SAL); 步骤2：查询中引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE JOB='MANAGER'AND SAL&gt;2500; 如下的查询也会引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE JOB='CLERK'; 但以下查询不会引用索引，因为没有先引用索引关键字的主键： 1SELECT ENAME,JOB,SAL FROM EMP WHERE SAL&gt;2500; 查看索引 通过查询数据字典USER_INDEXES可以检查创建的索引。 通过查询数据字典USER_IND_COLUMNS可以检查索引的列。 【训练1】 显示emp表的索引： 1SELECT INDEX_NAME, INDEX_TYPE, UNIQUENESS FROM USER_INDEXES WHERE TABLE_NAME=&apos;EMP&apos;; 【训练2】 显示索引的列。 12SELECT COLUMN_NAME FROM USER_IND_COLUMNS WHERE INDEX_NAME='EMP_JOBSAL'; 同义词 同义词(SYNONYM)是为模式对象起的别名，可以为表、视图、序列、过程、函数和包等数据库模式对象创建同义词。同义词有两种：公有同义词和私有同义词。公有同义词是对所有用户都可用的。创建公有同义词必须拥有系统权限CREATE PUBLIC SYNONYM；创建私有同义词需要CREATE SYNONYM系统权限。私有同义词只对拥有同义词的账户有效，但私有同义词也可以通过授权，使其对其他用户有效。同义词通过给本地或远程对象分配一个通用或简单的名称，隐藏了对象的拥有者和对象的真实名称，也简化了SQL语句。 如果同义词同对象名称重名，私有同义词又同公有同义词重名，那么，识别的顺序是怎样的呢？如果存在对象名，则优先识别，其次识别私有同义词，最后识别公有同义词。比如,执行以下的SELECT语句： 1SELECT * FROM ABC; 如果存在表ABC，就对表ABC执行查询语句；如果不存在表ABC，就去查看是否有私有同义词ABC，如果有就对ABC执行查询(此时ABC是另外一个表的同义词)；如果没有私有同义词ABC，则去查找公有同义词；如果找不到，则查询失败。 同义词的创建和使用1DROP SYNONYM 同义词名； 【训练1】 创建同义词。 步骤1：创建私有同义词： 1CREATE SYNONYM BOOK FOR 图书； 步骤2：创建公有同义词(先要获得创建公有同义词的权限)： 1CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书； 步骤3：使用同义词： 1SELECT * FROM BOOK; 同义词的查看 通过查询数据字典USER_OBJECTS和USER_SYNONYMS，可以查看同义词信息。 【训练1】 查看用户拥有的同义词： 1SELECT OBJECT_NAME FROM USER_OBJECTS WHERE OBJECT_TYPE='SYNONYM'; 系统定义同义词 系统为常用的对象预定义了一些同义词，利用它们可以方便地访问用户的常用对象 Oracle数据库模式对象 对 象 名 称 作 用 DICT DICTIONARY 数据字典 CAT USER_CATALOG 用户拥有的表、视图、同义词和序列 CLU USER_CLUSTERS 用户拥有的聚簇 IND USER_INDEXES 用户拥有的索引 OBJ USER_OBJECTS 用户拥有的对象 SEQ USER_SEQUENCES 用户拥有的序列 SYN USER_SYNONYMS 用户拥有的私有同义词 COLS USER_TAB_COLUMNS 用户拥有的表、视图和聚簇的列 TABS USER_TABLES 用户拥有的表 【训练1】 查看用户拥有的表： 1SELECT TABLE_NAME FROM TABS; 聚簇【了解】 所谓聚簇(CLUSTER)，形象地说，就是生长在一起的表。聚簇包含一张或多张表，表的公共列被称为聚簇关键字，在公共列上具有同一值的列物理上存储在一起。那么在什么情况下需要创建聚簇呢？通常在多个表有共同的列时，应使用聚簇。比如有一张学生基本情况表，其中包含学生的学号、姓名、性别、住址等信息。另外，还设计了一张学生成绩表，其中除了包含学生成绩，也包含学生的学号、姓名、性别。那么这两张表共同的列就可以创建成聚簇。这样两张表的共同的学号、姓名和性别，就存放在了一起，相同的值只存放一次。如果两个表通过聚簇列进行联合，则会大大提高查询的速度，但对于插入等操作则会降低效率。 创建聚簇后，要创建使用聚簇的表，对聚簇还应该建立索引。如果不对聚簇建立索引，则不能对聚簇表进行插入、修改和删除操作。 创建聚簇需要CREATE CLUSTER系统权限。 【训练1】 创建和使用聚簇。 步骤1：创建聚簇： 123CREATE CLUSTER COMM(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2))SIZE 500TABLESPACE USERS; 步骤2：创建第一张聚簇表： 12345678CREATE TABLE STUDENT(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2),ADDRESS VARCHAR2(20),E_MAIL VARCHAR2(20))CLUSTER COMM(STUNO,STUNAME,SEX); 步骤3：创建第二张聚簇表： 12345678CREATE TABLE SCORE(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2),CHINESE NUMBER(3),MATH NUMBER(3),ENGLISH NUMBER(3) )CLUSTER COMM(STUNO,STUNAME,SEX); 步骤4：为聚簇创建索引： 1CREATE INDEX INX_COMM ON CLUSTER COMM; 步骤5：向表中插入数据： 123456INSERT INTO STUDENT VALUES(10001,'黄凯','男','宝安','HK123@163.COM');INSERT INTO STUDENT VALUES(10002,'苏丽','女','罗湖','SL99@163.COM');INSERT INTO STUDENT VALUES(10003,'刘平平','男','南山','PP2003@SHOU.COM');INSERT INTO SCORE VALUES(10001,'黄凯','男',70,85,93);INSERT INTO SCORE VALUES(10002,'苏丽','女',65,74,83);INSERT INTO SCORE VALUES(10003,'刘平平','男',88,75,69); 步骤6：删除聚簇及聚簇表： 1DROP CLUSTER COMM INCLUDING TABLES CASCADE CONSTRAINTS; 数据库链接 数据库链接(DATABASE LINK)是在分布式环境下，为了访问远程数据库而创建的数据通信链路。数据库链接隐藏了对远程数据库访问的复杂性。通常，我们把正在登录的数据库称为本地数据库，另外的一个数据库称为远程数据库。 有了数据库链接，可以直接通过数据库链接来访问远程数据库的表。常见的形式是访问远程数据库固定用户的链接，即链接到指定的用户，创建这种形式的数据库链接的语句 如下： 12CREATE DATABASE LINK 链接名 CONNECT TO 账户 IDENTIFIED BY 口令USING 服务名; 创建数据库链接，需要CREATE DATABASE LINK系统权限。 数据库链接一旦建立并测试成功，就可以使用以下形式来访问远程用户的表。 表名@数据库链接名 【训练1】 在局域网上创建和使用数据库链接。 步骤1：创建远程数据库的服务名，假定局域网上另一个数据库服务名为MYDB_REMOTE。 步骤2：登录本地数据库SCOTT账户，创建数据库链接： 12CONNECT SCOTT/TIGER@MYDBCREATE DATABASE LINK abc CONNECT TO scott IDENTIFIED BY tiger USING 'MYDB_REMOTE'; 步骤3：查询远程数据库的数据： 1SELECT * FROM emp@abc; 结果略。 步骤4：一个分布查询： 1SELECT ename,dname FROM emp@abc e,dept d WHERE e.deptno=d.deptno; 说明：在本例中，远程数据库服务名是MYDB_REMOTE，创建的数据库链接名称是abc.emp@abc表示远程数据库的emp表。步骤4是一个联合查询，数据来自本地服务器的dept表和远程服务器的emp表。 例题【训练1】 创建和删除索引。 步骤1：创建索引： 1CREATE INDEX EMP_ENAME ON EMP(ENAME); 步骤2：查询中引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE ENAME='SCOTT'; 步骤3：删除索引： 1DROP INDEX EMP_ENAME; 【训练2】 创建复合索引。索引出现在WHERE子句中的时候就会被自动被引用。 步骤1：创建复合索引： 1CREATE INDEX EMP_JOBSAL ON EMP(JOB,SAL); 步骤2：查询中引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE JOB='MANAGER'AND SAL&gt;2500; 如下的查询也会引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE JOB='CLERK'; 但以下查询不会引用索引，因为没有先引用索引关键字的主键： 1SELECT ENAME,JOB,SAL FROM EMP WHERE SAL&gt;2500; 【训练3】 显示emp表的索引： 1SELECT INDEX_NAME, INDEX_TYPE, UNIQUENESS FROM USER_INDEXES WHERE TABLE_NAME='EMP'; 【训练4】 显示索引的列。 12SELECT COLUMN_NAME FROM USER_IND_COLUMNS WHERE INDEX_NAME='EMP_JOBSAL'; 【训练5】 创建同义词。 步骤1：创建私有同义词： 1CREATE SYNONYM BOOK FOR 图书； 步骤2：创建公有同义词(先要获得创建公有同义词的权限)： 1CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书； 步骤3：使用同义词： 1SELECT * FROM BOOK; 【训练6】 查看用户拥有的同义词： 1SELECT OBJECT_NAME FROM USER_OBJECTS WHERE OBJECT_TYPE='SYNONYM'; 【训练7】 查看用户拥有的表： 1SELECT TABLE_NAME FROM TABS; 【训练8】 创建和使用聚簇。 步骤1：创建聚簇： 123CREATE CLUSTER COMM(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2))SIZE 500TABLESPACE USERS; 步骤2：创建第一张聚簇表： 1234567CREATE TABLE STUDENT(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2),ADDRESS VARCHAR2(20),E_MAIL VARCHAR2(20))CLUSTER COMM(STUNO,STUNAME,SEX); 步骤3：创建第二张聚簇表： 12345678CREATE TABLE SCORE(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2),CHINESE NUMBER(3),MATH NUMBER(3),ENGLISH NUMBER(3) )CLUSTER COMM(STUNO,STUNAME,SEX); 步骤4：为聚簇创建索引： CREATE INDEX INX_COMM ON CLUSTER COMM; 步骤5：向表中插入数据： 123456INSERT INTO STUDENT VALUES(10001,'黄凯','男','宝安','HK123@163.COM');INSERT INTO STUDENT VALUES(10002,'苏丽','女','罗湖','SL99@163.COM');INSERT INTO STUDENT VALUES(10003,'刘平平','男','南山','PP2003@SHOU.COM');INSERT INTO SCORE VALUES(10001,'黄凯','男',70,85,93);INSERT INTO SCORE VALUES(10002,'苏丽','女',65,74,83);INSERT INTO SCORE VALUES(10003,'刘平平','男',88,75,69); 步骤6：删除聚簇及聚簇表： 1DROP CLUSTER COMM INCLUDING TABLES CASCADE CONSTRAINTS; 【训练9】 在局域网上创建和使用数据库链接。 步骤1：创建远程数据库的服务名，假定局域网上另一个数据库服务名为MYDB_REMOTE。 步骤2：登录本地数据库SCOTT账户，创建数据库链接： 12CONNECT SCOTT/TIGER@ORACLECREATE DATABASE LINK abc CONNECT TO scott IDENTIFIED BY tiger USING 'MYDB_REMOTE'; 步骤3：查询远程数据库的数据： 1SELECT * FROM emp@abc; 步骤4：一个分布查询： 1SELECT ename,dname FROM emp@abc e,dept d WHERE e.deptno=d.deptno;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[staruml教程]]></title>
    <url>%2F2017%2F12%2F07%2Fstaruml%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这一个外接教程！ 教程地址]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>staruml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种编程命名法(转)]]></title>
    <url>%2F2017%2F12%2F06%2F%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E5%91%BD%E5%90%8D%E6%B3%95%2F</url>
    <content type="text"><![CDATA[三种编程命名法! 三种编程命名规范（匈牙利命名法、驼峰式命名法、帕斯卡命名法） 匈牙利命名开头字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，要求单词第一个字母大写。 ex:int iMyAge; “i”是int类型的缩写；char cMyName[10]; “c”是char类型的缩写；float fManHeight; “f”是float类型的缩写； 其他：前缀类型 a b by c cb cr cx,cy dw fn h i l lp m_ n np p s sz w （一一对应关系）数组 (Array) 布尔值 (Boolean) 字节 (Byte) 有符号字符 (Char) 无符号字符 (Char Byte，没有多少人用) 颜色参考值 (ColorRef) 坐标差（长度 ShortInt） Double Word 函数 Handle（句柄） 整型 长整型 (Long Int) Long Pointer 类的成员 短整型 (Short Int) Near Pointer Pointer 字符串型 以 null 做结尾的字符串型 (String with Zero End) Word 驼峰式命名法：又叫小驼峰式命名法。第一个单词首字母小写，后面其他单词首字母大写。 ex:int myAge;char myName[10];float manHeight; 帕斯卡命名法：又叫大驼峰式命名法。每个单词的第一个字母都大写。 ex:int MyAge;char MyName[10];float ManHeight; 其他的命名规范如：下划线命名法，但是不是太常用，个人感觉可能是因为下划线位置太偏的事，不方便大量使用。综合各方面考虑，驼峰式命名法比较好，优势明显，事实上，目前使用驼峰式命名法的人也真的越来越多了。 下一章数据库模式对象 转载地址 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>命名法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十一]]></title>
    <url>%2F2017%2F12%2F06%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十一章，主要是用来复习和巩固在课堂学习的知识！ 笔记一、分区表在某些场合会使用非常大的表，比如人口信息统计表。如果一个表很大，就会降低查询的速度，并增加管理的难度。一旦发生磁盘损坏，可能整个表的数据就会丢失，恢复比较困难。根据这一情况，可以创建分区表，把一个大表分成几个区(小段)，对数据的操作和管理都可以针对分区进行，这样就可以提高数据库的运行效率。分区可以存在于不同的表空间上，提高了数据的可用性。例：创建和使用分区表。 创建按成绩分区的考生表，共分为3个区： 12345678910111213141516171819202122CREATE TABLE 考生 ( 考号 VARCHAR2(5),姓名 VARCHAR2(30),成绩 NUMBER(3))PARTITION BY RANGE(成绩) (PARTITION A VALUES LESS THAN (300)TABLESPACE USERS,PARTITION B VALUES LESS THAN (500)TABLESPACE USERS,PARTITION C VALUES LESS THAN (MAXVALUE)TABLESPACE USERS);步骤3：检查A区中的考生：SELECT * FROM 考生 PARTITION(A);步骤4：检查全部的考生：SELECT * FROM 考生; 视图视图的概念视图不同于表，视图本身不包含任何数据。而视图只是一种定义，对应一个查询语句。视图的数据都来自于某些表，这些表被称为基表。 视图可以在表能够使用的任何地方使用，但在对视图的操作上同表相比有些限制，特别是插入和修改操作。对视图的操作将传递到基表，所以在表上定义的约束条件和触发器在视图上将同样起作用。 视图的创建 格式： 123create [or replace] view 视图名 asselect 语句; 例：创建图书作者视图：12CREATE VIEW 图书作者(书名,作者) AS SELECT 图书名称,作者 FROM 图书; 查询视图全部内容1SELECT * FROM 图书作者; 查询部分视图：1SELECT 作者 FROM 图书作者; 删除视图：1DROP VIEW 清华图书; 创建只读视图创建只读视图要用WITH READ ONLY选项。 例：创建emp表的经理视图：123CREATE OR REPLACE VIEW manager AS SELECT * FROM emp WHERE job= 'MANAGER'WITH READ ONLY; 使用WITH CHECK OPTION选项使用WITH CHECK OPTION选项。 使用该选项，可以对视图的插入或更新进行限制，即该数据必须满足视图定义中的子查询中的WHERE条件，否则不允许插入或更新。例：123CREATE OR REPLACE VIEW 清华图书 AS SELECT * FROM 图书 WHERE 出版社编号= '01' WITH CHECK OPTION;注：插入数据时，由于带了with check option的选项，则只能插入出版社编为'01'的数据 来自基表的限制除了以上的限制，基表本身的限制和约束也必须要考虑。如果生成子查询的语句是一个分组查询，或查询中出现计算列，这时显然不能对表进行插入。另外，主键和NOT NULL列如果没有出现在视图的子查询中，也不能对视图进行插入。在视图中插入的数据，也必须满足基表的约束条件。 视图的查看 字典 说明 USER_VIEWS 字典中包含了视图的定义。 USER_UPDATABLE_COLUMNS 字典包含了哪些列可以更新、插入、删除。 USER_OBJECTS 字典中包含了用户的对象。 可以通过DESCRIBE命令查看字典的其他列信息。 例：查看用户拥有的视图：1SELECT object_name FROM user_objects WHERE object_type='VIEW'; 表和视图 图书表 出版社表 【训练1】 创建图书和出版社表。 步骤1：创建出版社表，输入并执行以下命令：123456789101112131415161718192021222324CREATE TABLE 出版社(编号 VARCHAR2(2),出版社名称 VARCHAR2(30),地址 VARCHAR2(30),联系电话 VARCHAR2(20));步骤2：创建图书表，输入并执行以下命令：CREATE TABLE 图书(图书编号 VARCHAR2(5),图书名称 VARCHAR2(30),出版社编号 VARCHAR2(2),作者 VARCHAR2(10),出版日期 DATE,数量 NUMBER(3),单价 NUMBER(7,2));步骤3：使用DESCRIBE显示图书表的结构，输入并执行以下命令：DESCRIBE 图书 通过子查询创建表【训练2】 通过子查询创建新的图书表。 步骤1：完全复制图书表到“图书1”，输入并执行以下命令：123456789CREATE TABLE 图书1 AS SELECT * FROM 图书;步骤2：创建新的图书表“图书2”，只包含书名和单价，输入并执行以下命令：CREATE TABLE 图书2(书名,单价) AS SELECT 图书名称,单价 FROM 图书;步骤3：创建新的图书表“图书3”，只包含书名和单价，不复制内容，输入并执行以下命令：CREATE TABLE 图书3(书名,单价) AS SELECT 图书名称,单价 FROM 图书 WHERE 1=2; 设置列的默认值可以在创建表的同时指定列的默认值，默认值由DEFAULT部分说明。 【训练3】 创建表时设置默认值。 步骤1：创建表时，设置表的默认值。12345678910111213141516171819CREATE TABLE 图书4(图书编号 VARCHAR2(5) DEFAULT NULL,图书名称 VARCHAR2(30) DEFAULT '未知',出版社编号 VARCHAR2(2) DEFAULT NULL,出版日期 DATE DEFAULT '01-1月-1900',作者 VARCHAR2(10) DEFAULT NULL,数量 NUMBER(3) DEFAULT 0,单价 NUMBER(7,2) DEFAULT NULL,借出数量 NUMBER(3) DEFAULT 0);步骤2：插入数据。INSERT INTO 图书4(图书编号) VALUES('A0001');步骤2：查询插入结果。SELECT * FROM 图书4; 【练习1】创建图书出借信息表，设置适当的默认值，并插入数据。 结构如下： 名称 是否为空? 类型 图书编号 not null VARCHAR2(10) 借书人 not null VARCHAR2(10) 借书日期 not null DATE 归还日期 not null DATE 删除已创建的表表的删除者必须是表的创建者或具有DROP ANY TABLE权限。 【训练4】 删除“图书1”表。 DROP TABLE 图书1;执行结果：表已丢弃。 表的操作 表的重命名 只有表的拥有者，才能修改表名。 清空表 清空表的语法为：1TRUNCATE TABLE 表名； 清空表可删除表的全部数据并释放占用的存储空间。 查看表 可以通过对数据字典USER_OBJECTS的查询，显示当前模式用户的所有表。 【训练1】 显示当前用户的所有表。1SELECT object_name FROM user_objects WHERE object_type='TABLE'; 数据完整性约束 在创建表和修改表时，可通过定义约束条件来保证数据的完整性和一致性。约束条件是一些规则，在对数据进行插入、删除和修改时要对这些规则进行验证，从而起到约束作用。 完整性包括数据完整性和参照完整性，数据完整性定义表数据的约束条件，参照完整性定义数据之间的约束条件。数据完整性由主键(PRIMARY KEY)、非空(NOT NULL)、惟一(UNIQUE)和检查(CHECK)约束条件定义参照完整性由外键(FOREIGN KEY)约束条件定义。在表的创建过程中，应该先创建主表，后创建子表。 约束条件的创建 【训练1】 创建带有约束条件的出版社表(如果已经存在，先删除)：123456CREATE TABLE 出版社(编号 VARCHAR2(2) CONSTRAINT PK_1 PRIMARY KEY,出版社名称 VARCHAR2(30) NOT NULL ,地址 VARCHAR2(30) DEFAULT '未知',联系电话 VARCHAR2(20)); 【训练2】 创建带有约束条件(包括外键)的图书表(如果已经存在，先删除)：12345678910CREATE TABLE 图书(图书编号 VARCHAR2(5) CONSTRAINT PK_2 PRIMARY KEY,图书名称 VARCHAR2(30) NOT NULL,出版社编号 VARCHAR2(2) CHECK(LENGTH(出版社编号)=2) NOT NULL,作者 VARCHAR2(10) DEFAULT '未知',出版日期 DATE DEFAULT '01-1月-1900',数量 NUMBER(3) DEFAULT 1 CHECK(数量&gt;0),单价 NUMBER(7,2),CONSTRAINT YS_1 UNIQUE(图书名称,作者),CONSTRAINT FK_1 FOREIGN KEY(出版社编号) REFERENCES 出版社(编号) ON DELETE CASCADE); 说明：因为两个表同属于一个用户，故约束名不能相重，图书表的主键为“图书编号”列，主键名为PK_2。其中，约束条件CHECK(LENGTH(出版社编号)=2)表示出版社编号的长度必须是2，约束条件UNIQUE(图书名称,作者)表示“图书名称”和“作者”两列的内容组合必须惟一。FOREIGN KEY(出版社编号) REFERENCES 出版社(编号) 表示图书表的“出版社编号”列参照出版社的“编号”主键列。出版社表为主表，图书表为子表，出版社表必须先创建。ON DELETE CASCADE表示当删除出版社表的记录时，图书表中的相关记录同时删除，比如删除清华大学出版社，则图书表中清华大学出版社的图书也会被删除。 如果同时出现DEFAULT和CHECK，则DEFAULT需要出现在CHECK约束条件之前。 【训练3】插入数据，验证约束条件。12345678910111213141516171819202122232425262728293031323334353637383940步骤1：插入出版社信息：INSERT INTO 出版社 VALUES('01','清华大学出版社','北京','010-83456272');继续插入INSERT INTO 出版社 VALUES('01','电子科技大学出版社','西安','029-88201467');重新执行：INSERT INTO 出版社 VALUES('02','电子科技大学出版社','西安','029-88201467');步骤2：插入图书信息：INSERT INTO 图书(图书编号,图书名称,出版社编号,作者,单价) VALUES('A0001','计算机原理','01','刘勇',25.30);继续插入：INSERT INTO 图书(图书编号，图书名称，出版社编号，作者，单价) VALUES('A0002',' C语言程序设计','03','马丽', 18.75);INSERT INTO 图书(图书编号，图书名称，出版社编号，作者，单价) VALUES(‘A0002’,‘ C语言程序设计’,‘02’,‘马丽’, 18.75);继续插入：INSERT INTO 图书(图书编号,图书名称,出版社编号,作者,数量,单价) VALUES('A0003','汇编语言程序设计','02','黄海明',0,20.18);重新执行：INSERT INTO 图书(图书编号,图书名称,出版社编号,作者,数量,单价) VALUES('A0003','汇编语言程序设计','02','黄海明',15,20.18); 步骤3：显示插入结果：SELECT * FROM 出版社;继续查询：SELECT * FROM 图书;步骤4：提交插入的数据：COMMIT; 说明：在图书表中，没有插入的数量取默认值1，没有插入的出版日期取默认值01-1月-00(即1900年1月1日)。 【训练4】 通过删除数据验证ON DELETE CASCADE的作用。1234567891011121314151617步骤1：删除出版社01(清华大学)：DELETE FROM 出版社 WHERE 编号='01';步骤2：显示删除结果：显示出版社表结果：SELECT * FROM 出版社;显示图书表结果：SELECT * FROM 图书;步骤3：恢复删除:ROLLBACK； 查看约束条件 数据字典USER_CONSTRAINTS中包含了当前模式用户的约束条件信息。其中，CONSTRAINTS_TYPE 显示的约束类型为： C：CHECK约束。P：PRIMARY KEY约束。U：UNIQUE约束。R：FOREIGN KEY约束。 其他信息可根据需要进行查询显示，可用DESCRIBE命令查看USER_CONSTRAINTS的结构。 【训练1】 检查表的约束信息：12SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCH_CONDITION FROM USER_CONSTRAINTSWHERE TABLE_NAME='图书'; 修改表结构 增加新列 【训练1】 为“出版社”增加一列“电子邮件”：12ALTER TABLE 出版社ADD 电子邮件 VARCHAR2(30) CHECK(电子邮件 LIKE '%@%'); 修改列 修改列定义有以下一些特点： (1) 列的宽度可以增加或减小，在表的列没有数据或数据为NULL时才能减小宽度。(2) 在表的列没有数据或数据为NULL时才能改变数据类型，CHAR和VARCHAR2之间可以随意转换。(3) 只有当列的值非空时，才能增加约束条件NOT NULL。(4) 修改列的默认值，只影响以后插入的数据。 【训练1】 修改“出版社”表“电子邮件”列的宽度为40。12ALTER TABLE 出版社MODIFY 电子邮件 VARCHAR2(40); 删除列 【训练1】删除“出版社”表的“电子邮件”列。12ALTER TABLE 出版社DROP COLUMN 电子邮件; 【训练2】 将“图书”表的“出版日期”列置成UNUSED，并查看。1234567891011步骤1：设置“出版日期”列为UNUSED：ALTER TABLE 图书 SET UNUSED COLUMN 出版日期;步骤2：显示结构：DESC 图书;步骤3：删除UNUSED列：ALTER TABLE 图书 DROP UNUSED COLUMNS; 约束条件的修改 可以为表增加或删除表级约束条件。 增加约束条件 【训练1】 为emp表的mgr列增加外键约束： 1ALTER TABLE emp ADD CONSTRAINT FK_3 FOREIGN KEY(mgr) REFERENCES emp(empno); 删除约束条件 【训练2】 删除为emp表的mgr列增加的外键约束： 1ALTER TABLE emp DROP CONSTRAINT FK_3; 视图创建和操作 视图的概念 视图不同于表，视图本身不包含任何数据。而视图只是一种定义，对应一个查询语句。视图的数据都来自于某些表，这些表被称为基表。 视图可以在表能够使用的任何地方使用，但在对视图的操作上同表相比有些限制，特别是插入和修改操作。对视图的操作将传递到基表，所以在表上定义的约束条件和触发器在视图上将同样起作用。 视图的创建 创建简单视图 【训练1】 创建图书作者视图。12345678910111213141516步骤1：创建图书作者视图：CREATE VIEW 图书作者(书名,作者) AS SELECT 图书名称,作者 FROM 图书;步骤2：查询视图全部内容SELECT * FROM 图书作者;步骤3：查询部分视图：SELECT 作者 FROM 图书作者;步骤4：删除视图：DROP VIEW 清华图书; 创建复杂视图 【训练3】 修改作者视图，加入出版社名称。123456789步骤1：重建图书作者视图：CREATE OR REPLACE VIEW 图书作者(书名,作者,出版社) AS SELECT 图书名称,作者,出版社名称 FROM 图书,出版社 WHERE 图书.出版社编号=出版社.编号;步骤2：查询新视图内容：SELECT * FROM 图书作者; 【训练4】 创建一个统计视图。123456789步骤1：创建emp表的一个统计视图：CREATE VIEW 统计表(部门名,最大工资,最小工资,平均工资)AS SELECT DNAME,MAX(SAL),MIN(SAL),AVG(SAL) FROM EMP E,DEPT DWHERE E.DEPTNO=D.DEPTNO GROUP BY DNAME; 步骤2：查询统计表：SELECT * FROM 统计表; 创建只读视图 创建只读视图要用WITH READ ONLY选项。 【训练5】 创建只读视图。123456789步骤1：创建emp表的经理视图：CREATE OR REPLACE VIEW manager AS SELECT * FROM emp WHERE job= 'MANAGER'WITH READ ONLY;步骤2：进行删除：DELETE FROM manager; 视图的操作 对视图经常进行的操作是查询操作，但也可以在一定条件下对视图进行插入、删除和修改操作。对视图的这些操作最终传递到基表。但是对视图的操作有很多限定。如果视图设置了只读，则对视图只能进行查询，不能进行修改操作。 视图的插入 【训练1】 视图插入练习。 步骤1：创建清华大学出版社的图书视图：1234567891011121314CREATE OR REPLACE VIEW 清华图书 AS SELECT * FROM 图书 WHERE 出版社编号= '01';步骤2：插入新图书：INSERT INTO 清华图书 VALUES('A0005','软件工程','01','冯娟',5,27.3);步骤3：显示视图：SELECT * FROM 清华图书;步骤4：显示基表SELECT * FROM 图书; 问题:如果在“清华图书”的视图中插入其他出版社的图书，结果会怎么样呢？ 结果是允许插入，但是在视图中看不见，在基表中可以看见，这显然是不合理的。 使用WITH CHECK OPTION选项 为了避免上述情况的发生，可以使用WITH CHECK OPTION选项。使用该选项，可以对视图的插入或更新进行限制，即该数据必须满足视图定义中的子查询中的WHERE条件，否则不允许插入或更新。 【训练2】 使用WITH CHECK OPTION选项限制视图的插入。 步骤1：重建清华大学出版社的图书视图，带WITH CHECK OPTION选项：1234567CREATE OR REPLACE VIEW 清华图书 AS SELECT * FROM 图书 WHERE 出版社编号= '01'WITH CHECK OPTION;步骤2：插入新图书：INSERT INTO 清华图书 VALUES('A0006','Oracle数据库','02','黄河',3,39.8); 来自基表的限制 除了以上的限制，基表本身的限制和约束也必须要考虑。如果生成子查询的语句是一个分组查询，或查询中出现计算列，这时显然不能对表进行插入。另外，主键和NOT NULL列如果没有出现在视图的子查询中，也不能对视图进行插入。在视图中插入的数据，也必须满足基表的约束条件。 【训练3】基表本身限制视图的插入。12345678步骤1：重建图书价格视图：CREATE OR REPLACE VIEW 图书价格 AS SELECT 图书名称,单价 FROM 图书;步骤2：插入新图书：INSERT INTO 图书价格 VALUES('Oracle数据库',39.8); 视图的查看 USER_VIEWS字典中包含了视图的定义。USER_UPDATABLE_COLUMNS字典包含了哪些列可以更新、插入、删除。USER_OBJECTS字典中包含了用户的对象。 可以通过DESCRIBE命令查看字典的其他列信息。在这里给出一个训练例子。 【训练1】 查看清华图书视图的定义：1SELECT TEXT FROM USER_VIEWS WHERE VIEW_NAME='清华图书'; 【训练2】 查看用户拥有的视图：1SELECT object_name FROM user_objects WHERE object_type='VIEW'; 阶段训练【训练1】 创建学生、系部、课程和成绩表，根据需要设置默认值、约束条件、主键和外键。`sql步骤1：创建系部表，编号为主键，系部名称非空，电话号码惟一： CREATE TABLE 系部(编号 NUMBER(5) PRIMARY KEY,系部名 VARCHAR2(20) NOT NULL,地址 VARCHAR2(30),电话 VARCHAR2(15) UNIQUE,系主任 VARCHAR2(10)); 步骤2：创建学生表，学号为主键，姓名非空，性别只能是男或女，电子邮件包含@并且惟一，系部编号参照系部表的编号： CREATE TABLE 学生 (学号 VARCHAR2(10) PRIMARY KEY,姓名 VARCHAR2(10) NOT NULL,性别 VARCHAR2(2) CHECK(性别=’男’ OR 性别=’女’),生日 DATE,住址 VARCHAR2(30),电子邮件 VARCHAR2(20) CHECK(电子邮件 LIKE ‘%@%’) UNIQUE,系部编号 NUMBER(5),CONSTRAINT FK_XBBH FOREIGN KEY(系部编号) REFERENCES 系部(编号)); 步骤3：创建课程表，编号为主键，课程名非空，学分为1到5： CREATE TABLE 课程(编号 NUMBER(5) PRIMARY KEY,课程名 VARCHAR2(30) NOT NULL,学分 NUMBER(1) CHECK(学分&gt;0 AND 学分&lt;=5)); 步骤4：创建成绩表，学号和课程编号为主键，学号参照学生表的学号，课程编号参照课程表的编号： CREATE TABLE 成绩(学号 VARCHAR2(10),课程编号 NUMBER(5),成绩 NUMBER (3),CONSTRAINT PK PRIMARY KEY(学号,课程编号),CONSTRAINT FK_XH FOREIGN KEY(学号) REFERENCES 学生(学号),CONSTRAINT FK_KCBH FOREIGN KEY(课程编号) REFERENCES 课程(编号));`sql 说明：注意表之间的主从关系，对于系部和学生表，系部表为主表，学生表为子表。学生表的外键表示插入学生的系部编号必须是系部表的编号。对于成绩表，主键是学号和课程编号，表示如果学号相同课程编号必须不同，这样就可以惟一地标识记录。课程表有两个外键，分别参照学生表和课程表，表示成绩表的学号必须是学生表的学号，成绩表的课程编号必须是课程表的编号。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十]]></title>
    <url>%2F2017%2F12%2F05%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十章，主要是用来复习和巩固在课堂学习的知识！ 笔记 建表 123456格式：create table 表名(列名1 类型 约束,列名2 类型 约束,...... ); 如：步骤1：创建出版社表，输入并执行以下命令： 123456CREATE TABLE 出版社(编号 VARCHAR2(2),出版社名称 VARCHAR2(30),地址 VARCHAR2(30),联系电话 VARCHAR2(20)); 123456789CREATE TABLE 图书(图书编号 VARCHAR2(5),图书名称 VARCHAR2(30),出版社编号 VARCHAR2(2),作者 VARCHAR2(10), 出版日期 DATE, 数量 NUMBER(3), 单价 NUMBER(7,2) ); 通过子查询建表 步骤1：完全复制图书表到“图书1”，输入并执行以下命令：1CREATE TABLE 图书1 AS SELECT * FROM 图书; 步骤2：创建新的图书表“图书2”，只包含书名和单价，输入并执行以下命令： 1CREATE TABLE 图书2(书名,单价) AS SELECT 图书名称,单价 FROM 图书; 步骤3：创建新的图书表“图书3”，只包含书名和单价，不复制内容，输入并执行以下命令：1CREATE TABLE 图书3(书名,单价) AS SELECT 图书名称,单价 FROM 图书 WHERE 1=2; 添加表的约束 约束 关键字 简写 主键 primary key PK 唯一 unique UQ 默认值 default DF 检查约束 check CK 外键约束 foreign key FK 方法一：建表的同时添加约束 123456789create table stuinfo(sno int primary key not null, --主键sname varchar2(10) unique not null, --唯一sex char(2) default '男' check(sex='男' or sex = '女') not null, --默认及检查saddress varchar2(50) not null,phone char(11),email varchar2(50)); 1234567create table stumarks(marksId int,sno int references stuinfo(sno) not null, --外键score number(5,1),examDate date default sysdate); 方法二:建表完成后，再添加约束 （之前已建好了出版社表及图书表） 123456789101112131415161718--主键约束alter table 出版社 add constraint PK_编号primary key (编号);--唯一约束alter table 出版社 add constraint UQ_地址unique (地址);--检查约束alter table 出版社 add constraint CK_联系电话check (联系电话 like '1%');--默认值alter table 出版社 modify 地址 default '湘潭';--外键约束alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号)--外键约束alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号) 查看约束条件 数据字典USER_CONSTRAINTS中包含了当前模式用户的约束条件信息。其中，CONSTRAINTS_TYPE 显示的约束类型为： C：CHECK约束。 P：PRIMARY KEY约束。 U：UNIQUE约束。 R：FOREIGN KEY约束。 其他信息可根据需要进行查询显示，可用DESCRIBE命令查看USER_CONSTRAINTS的结构。 如:检查表的约束信息：12SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCH_CONDITION FROM USER_CONSTRAINTSWHERE TABLE_NAME='图书'; 删除约束条件 1ALTER TABLE 表名 DROP CONSTRAINT 约束名; 表的操作 1、删除表 drop table 表名2、重命名表 RENAME 表名 TO 新表名;3、查看表 可以通过对数据字典USER_OBJECTS的查询，显示当前模式用户的所有表。 如： 显示当前用户的所有表。1SELECT object_name FROM user_objects WHERE object_type='TABLE'; 修改表1、增加新列:如： 为“出版社”增加一列“电子邮件”： 12ALTER TABLE 出版社ADD 电子邮件 VARCHAR2(30) CHECK(电子邮件 LIKE '%@%'); 2、修改列 修改列定义有以下一些特点：(1) 列的宽度可以增加或减小，在表的列没有数据或数据为NULL时才能减小宽度。(2) 在表的列没有数据或数据为NULL时才能改变数据类型，CHAR和VARCHAR2之间可以随意转换。(3) 只有当列的值非空时，才能增加约束条件NOT NULL。(4) 修改列的默认值，只影响以后插入的数据。如：修改“出版社”表“电子邮件”列的宽度为40。1ALTER TABLE 出版社 MODIFY 电子邮件 VARCHAR2(40); 3、删除列如：删除“出版社”表的“电子邮件”列。12ALTER TABLE 出版社DROP COLUMN 电子邮件; 数据操作插入数据【训练1】 表的部分字段插入练习。步骤1：将新雇员插入到emp表：12INSERT INTO emp(empno,ename,job)VALUES (1000, '小李', 'CLERK'); 步骤2：显示插入结果1SELECT * FROM emp WHERE empno=1000; 日期类型的字段值也要用单引号括起来，如’10-1月-03’。日期型的数据默认格式为DD-MON-YY，默认的世纪为当前的世纪，默认的时间为午夜12点。如果指定的世纪不是本世纪或时间不是午夜12点，则必须使用TO_DATE系统函数对字符串进行转换。 【训练2】 时间字段的插入练习。 步骤1：将新雇员插入到emp表：12INSERT INTO emp(empno,ename,job,hiredate)VALUES (1001, '小马', 'CLERK', '10-1月-03'); 【训练3】 表的全部字段的插入练习。 执行以下的查询：1INSERT INTO dept VALUES (50, '培训部','深圳'); 【训练4】 插入空值练习。 执行以下的查询：1INSERT INTO emp(empno,ename,job,sal) VALUES(1005,'杨华', 'CLERK',null); 复制数据:该形式一次可以插入多行数据。【训练5】 通过其他表插入数据的练习。 步骤1：创建一个新表manager：1CREATE TABLE manager AS SELECT empno,ename,sal FROM emp WHERE job='MANAGER'; 步骤2：从emp表拷贝数据到manager： 1234INSERT INTO managerSELECT empno, ename, salFROM empWHERE job = 'CLERK'; ## 修改数据 【训练1】 修改小李(编号为1000)的工资为3000。执行以下的查询：123UPDATE empSET sal = 3000WHERE empno = 1000; 【训练2】 将小李(编号为1000)的雇佣日期改成当前系统日期，部门编号改为50。 执行以下的查询：123UPDATE empSET hiredate=sysdate, deptno=50WHERE empno = 1000; 【训练3】 为所有雇员增加100元工资。执行以下的查询：12UPDATE empSET sal =sal+100; 【训练4】 根据其他表修改数据。 执行以下的查询：123UPDATE managerSET (ename, sal) =(SELECT ename,sal FROM emp WHERE empno = 7788)WHERE empno = 1000; ## 删除数据【训练1】 删除雇员编号为1000的新插入的雇员。 步骤1：删除编号为1000的雇员：1DELETE FROM emp WHERE empno=1000; 步骤2：显示删除结果：1SELECT * FROM emp WHERE empno=1000; 【训练2】 彻底删除manager表的内容。 执行以下的命令：1TRUNCATE TABLE manager; DELETE命令进行的删除可以撤销，但TRUNCATE命令进行的删除不可撤销。 注意：TRUNCATE TABLE命令用来删除表的全部数据而不是删除表，表依旧存在。 数据库事务数据库事务的概念两次连续成功的COMMIT或ROLLBACK之间的操作，称为一个事务。在一个事务内，数据的修改一起提交或撤销，如果发生故障或系统错误，整个事务也会自动撤销。 比如，我们去银行转账，操作可以分为下面两个环节：(1) 从第一个账户划出款项。(2) 将款项存入第二个账户。 在这个过程中，两个环节是关联的。第一个账户划出款项必须保证正确的存入第二个账户，如果第二个环节没有完成，整个的过程都应该取消，否则就会发生丢失款项的问题。 整个交易过程，可以看作是一个事物，成功则全部成功，失败则需要全部撤消，这样可以避免当操作的中间环节出现问题时，产生数据不一致的问题。 数据库事务的应用数据库事务处理可分为隐式和显式两种。显式事务操作通过命令实现，隐式事务由系统自动完成提交或撤销(回退)工作，无需用户的干预。 隐式提交的情况包括：当用户正常退出SQL*Plus或执行CREATE、DROP、GRANT、REVOKE等命令时会发生事务的自动提交。 系统的环境变量AUTOCOMMIT设置为ON(默认状态为OFF) SET AUTOCOMMIT ON/OFF 隐式回退的情况包括：当异常结束SQL*Plus或系统故障发生时，会发生事务的自动回退。 【训练1】 学习使用COMMIT和ROLLBACK。123456789101112131415--步骤1：执行以下命令，提交尚未提交的操作：COMMIT;--步骤2：修改雇员SCOTT的工资：UPDATE emp SET sal=sal+100 WHERE empno=7788;SELECT ename,sal FROM emp WHERE empno=7788;--步骤3：假定修改操作后发现增加的工资应该为1000而不是100，为了取消刚做的操作，可以执行以下命令：ROLLBACK;--显示回退后SCOTT的工资恢复为3000：SELECT ename,sal FROM emp WHERE empno=7788;--步骤4：重新修改雇员SCOTT的工资，工资在原有基础上增加1000：UPDATE emp SET sal=sal+1000 WHERE empno=7788;--显示修改后SCOTT的工资：SELECT ename,sal FROM emp WHERE empno=7788;--步骤5：经查看修改结果正确，提交所做的修改：COMMIT; 注意：在事务执行过程中，随时可以预览数据的变化。对于比较大的事务，可以使用SAVEPOINT命令在事务中间划分一些断点，用来作为回退点。 【训练2】 学习使用SAVEPOINT命令。123456789101112131415161718192021222324252627--步骤1：插入一个雇员：INSERT INTO emp(empno, ename, job)VALUES (3000, '小马','STUDENT');--步骤2：插入保存点，检查点的名称为PA：SAVEPOINT pa;--步骤3：插入另一个雇员：INSERT INTO emp(empno, ename, job)VALUES (3001, '小黄','STUDENT');--步骤4：回退到保存点PA，则后插入的小黄被取消，而小马仍然保留。ROLLBACK TO pa;--步骤5: 提交所做的修改：COMMIT;```sql【训练3】 观察数据的读一致性。--步骤1：显示刚插入的雇员小马:SELECT empno,ename FROM emp WHERE empno=3000;--步骤2：删除雇员小马:DELETE FROM emp WHERE empno=3000;--步骤3：再次显示该雇员，显示结果为该雇员不存在：SELECT empno,ename FROM emp WHERE empno=3000;--步骤4：另外启动第2个SQL*Plus，并以SCOTT身份连接。执行以下命令，结果为该记录依旧存在。SELECT empno,ename FROM emp WHERE empno=3000;--步骤5：在第1个SQL*Plus中提交删除：COMMIT;--步骤6：在第2个SQL*Plus中再次显示该雇员，显示结果与步骤3的结果一致:SELECT empno,ename FROM emp WHERE empno=3000; 说明：在以上训练中，当第1个SQLPlus会话删除小马后，第2个SQLPlus会话仍然可以看到该雇员，直到第1个SQL*Plus会话提交该删除操作后，两个会话看到的才是一致的数据。 表的锁定【了解】锁的概念锁出现在数据共享的场合，用来保证数据的一致性。当多个会话同时修改一个表时，需要对数据进行相应的锁定。锁有“只读锁”、“排它锁”，“共享排它锁”等多种类型，而且每种类型又有“行级锁”(一次锁住一条记录)，“页级锁”(一次锁住一页，即数据库中存储记录的最小可分配单元)，“表级锁”(锁住整个表)。 若为“行级排它锁”，则除被锁住的行外，该表中其他行均可被其他的用户进行修改(Update)或删除(delete)。若为“表级排它锁”，则所有其他用户只能对该表进行查询(select)操作，而无法对其中的任何记录进行修改或删除。当程序对所做的修改进行提交(commit)或回滚(rollback)后，锁住的资源便会得到释放，从而允许其他用户进行操作。 如果两个事务，分别锁定一部分数据，而都在等待对方释放锁才能完成事务操作，这种情况下就会发生死锁。 隐式锁和显式锁在Oracle数据库中，修改数据操作时需要一个隐式的独占锁，以锁定修改的行，直到修改被提交或撤销为止。如果一个会话锁定了数据，那么第二个会话要想对数据进行修改，只能等到第一个会话对修改使用COMMIT命令进行提交或使用ROLLBACK命令进行回滚撤销后，才开始执行。因此应养成一个良好的习惯：执行修改操作后，要尽早地提交或撤销，以免影响其他会话对数据的修改。 【训练1】 对emp表的SCOTT雇员记录进行修改，测试隐式锁。123456789101112131415步骤1：启动第一个SQL*Plus，以SCOTT账户登录数据库(第一个会话)，修改SCOTT记录，隐式加锁。UPDATE emp SET sal=3500 where empno=7788;步骤2：启动第二个SQL*Plus，以SCOTT账户登录数据库(第二个会话)，进行记录修改操作。UPDATE emp SET sal=4000 where empno=7788;步骤3：对第一个会话进行解锁操作：COMMIT;步骤4：查看第二个会话，此时有输出结果：步骤5：提交第二个会话，防止长时间锁定。 表的显式锁定 锁定行【训练1】 对emp表的部门10的雇员记录加显式锁，并测试。12345678910111213步骤1：对部门10加显式锁：SELECT empno,ename,job,sal FROM emp WHERE deptno=10 FOR UPDATE;步骤2：启动第二个SQL*Plus(第二个会话)，以SCOTT账户登录数据库，对部门10的雇员CLARK进行修改操作。UPDATE emp SET sal=sal+100 where empno=7782;步骤3：在第一个会话进行解锁操作：COMMIT;步骤4：查看第二个会话，有输出结果： 锁定表LOCK语句用于对整张表进行锁定。对表的锁定可以是共享(SHARE)或独占(EXCLUSIVE)模式。共享模式下，其他会话可以加共享锁，但不能加独占锁。在独占模式下，其他会话不能加共享或独占锁。 【训练1】 对emp表添加独占锁。1234567步骤1：对emp表加独占锁：LOCK TABLE emp IN EXCLUSIVE MODE;步骤2：对表进行解锁操作：COMMIT;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse主题设置]]></title>
    <url>%2F2017%2F12%2F05%2Feclipse%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一个主题，一个心情！ 准备 我们先从主题官网下载一个主题！ 主题官网 点击图中【Eclipse Preferences(EPF)-for Eclipse import】的下载！ 下载下来的文件格式为 【 .epf 】 导入主题 打开eclipse,点击【 File 】中的【 import 】 进入【 import 】中的 【 General 】中的 【 Preferences 】 点击打开【 Preferences 】点击 【 Browse.. 】选择 格式为[ .epf ] 主题的路径 完成 点击 【 Finish 】完成设置 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天正cad安装教程]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%A4%A9%E6%AD%A3cad%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[此章是关于天正建筑2014和autoCAD 2014的安装教程！ 准备 使用以下的链接下载所需的文件 链接：https://pan.baidu.com/s/1skIYTJJ 密码：fahq 如下图目录： 我们要先清楚正建筑2014和autoCAD 2014的关系，正建筑2014只一个辅助autoCAD 2014 的工具，所以安装顺序是先 autoCAD 2014 后 正建筑2014。 如果你先安装了正建筑2014，运行正建筑2014就会出现以下情况： ##安装autoCAD 2014 现在让我们直接进入正题，安装autoCAD 2014 让我们找到autoCAD 2014文件，在以下目录中点击auto cad 2017 32_64目录中。 选中AutoCAD_2014_Simplified_Chinese_Wi…(注意这里有两个文件其中第一个是32位，第二是64位的)，安自己的机型选择，双击。 出现以下界面：选择解压的路径 解压成功之后，出现以下界面：选择安装 之后选择：我接受 ，点击 下一步 之后按照图中的 序列号 666-69696969 001f1 输入，点击 下一步 之后，选择自己想安装的路径，点击安装 接下来就是耐心等待就好，有点小久哦！ 出现以下界面就说明 autoCAD 2014 安装完成了！ 激活autoCAD 2014 autoCAD 2014 虽然已成为安装了，但并没有激活！ 成功安装的 autoCAD 2014 后，会在桌面上出以下三个东东！ 让我们点击第一个图标 AutoCAD 2014 进入以下界面： 之后出现 ，点击试用 你会看到 接下我们如图操作点击： 出现如下界面：点击右上角的 产品信息 之后出现：点击激活 你会看到：如下提示”很抱歉，您输入的序列号是无效的。该序列号或不是欧特克产品的序列号，又或许它已经被他人使用“ 这时我们再点右下角的 关闭 我们又回到了以下界面：我们点击激活 出现以下界面：选择 ”立即连接并激活“ 点击 下一步 出现以下界面： 我们选择 ”我具有 Autodesk 提供的激活码“ 并复制申请号 如图， 之后我们用acuto cad 2014 注册机得到激活码,首先进入以下目录 进入auto cad 2014 注册机目录 如图 点击符合自己机型的注册机进入，把复制的申请号粘贴在Requset后的文本框中，再点击Genderate 得到激活码并复制下粘贴到激活界面再点击Patch就行了 ：如图 之后点击激活界面的下一步，之后就会出现：如图 设置autoCAD 2014 的信任如果不进行此步骤的话，你使用天正建筑2014就出现以下情况： 第一步：如图找到 选项 第二步：进入选项找到系统再找到可执行文件设置 第三步：如图选择就行了，点击确定 安装天正建筑2014找到点击图标：如图 出现如下界面：点击 ”我接受许可证协议中的条款“，下一步 出现以下界面：点击下一步 出现以下界面：选择自己要的安装路径，点击下一步 出现以下界面：点击下一步 等待安装：如图 完成安装：点击完成 打补丁完成天正建筑2014后，点击进入后会出现以下情况 现在我们开始打补丁 第一步：选择Tarch2014过期补丁 第二步：出现以下界面，点击 补丁 第三步：点击Tarch2014x64/x32(选择一个符合自己机型的) 第四步：如图，点击是 第五步：右击天正建筑2014快捷方式，以管理员的身份运行就行了 成功 出现以下界面说明你安装成功了！ CAD Error问题一: cad安全系统 软件锁许可管理器 不起作用 解决方法： 打开c:\programData\FLEXnet【这个文件夹是隐藏的,要把隐藏属性去了】 删除文件 “FLEXnet” 中的所有文件 使用 win + r 打开快速启动窗口 –&gt; services.msc 找到服务 “FlexNet licensing service” 启动,并设置属性为自动 重启CAD 重新激活（上文有激活方法）]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>天正cad安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps快捷键集锦]]></title>
    <url>%2F2017%2F12%2F01%2Fps%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[本章主要是介绍ps中的快捷方式 工具箱 文件操作 选择功能 视图操作 编辑操作 图像调整 图层操作 工具箱(多种工具共用一个快捷键的可同时按【Shift】加此快捷键选取) 快捷键 说明 【M】 矩形、椭圆选框工具 【V】 移动工具 【L】 套索、多边形套索、磁性套索 【W】 魔棒工具 【C】 裁剪工具 【K】 切片工具、切片选择工具 【J】 喷枪工具 【B】 画笔工具、铅笔工具 【S】 像皮图章、图案图章 【Y】 历史画笔工具、艺术历史画笔 【E】 像皮擦、背景擦除、魔术像皮擦 【G】 渐变工具、油漆桶工具 【R】 模糊、锐化、涂抹工具 【O】 减淡、加深、海棉工具 【A】 路径选择工具、直接选取工具 【T】 文字工具 【P】 钢笔、自由钢笔 【U】 矩形、圆边矩形、椭圆、多边形、直线 【N】 写字板、声音注释 【I】 吸管、颜色取样器、度量工具 【H】 抓手工具 【Z】 缩放工具 【D】 默认前景色和背景色 【X】 切换前景色和背景色 【Q】 切换标准模式和快速蒙板模式 【F】 标准屏幕模式、带有菜单栏的全屏模式、全屏模式 【Ctrl】+【Shift】+【M】 跳到ImageReady3.0中 【Ctrl】 临时使用移动工具 【Alt】 临时使用吸色工具 【空格】 临时使用抓手工具 【0】至【9】 快速输入工具选项(当前工具选项面板中至少有一个可调节数字) 【[】或【]】 循环选择画笔 【Ctrl】+【N】 建立新渐变(在”渐变编辑器”中) 文件操作 快捷键 说明 【Ctrl】+【N】 新建图形文件 【Ctrl】+【Alt】+【N】 用默认设置创建新文件 【Ctrl】+【O】 打开已有的图像 【Ctrl】+【Alt】+【O】 打开为… 【Ctrl】+【W】 关闭当前图像 【Ctrl】+【S】 保存当前图像 【Ctrl】+【Shift】+【S】 另存为… 【Ctrl】+【Alt】+ 【Shift】+【S】 存储为Web所用格式 【Ctrl】+【Shift】+【P】 页面设置 【Ctrl】+【P】打印 【Ctrl】+【K】 打开“预置”对话框 选择功能 快捷键 说明 【Ctrl】+【A】 全部选取 【Ctrl】+【D】 取消选择 【Ctrl】+【Shift】+【D】 重新选择 【Shift】+【F6】 羽化选择 【Ctrl】+【Shift】+【I】 反向选择 【Enter】 路径变选区 数字键盘的 【Ctrl】+点按图层、路径、通道面板中的缩约图滤镜 载入选区 【Ctrl】+【F】 按上次的参数再做一次上次的滤镜 【Ctrl】+【Shift】+【F】 退去上次所做滤镜的效果 【Ctrl】+【Alt】+【F】 重复上次所做的滤镜(可调参数) 视图操作 快捷键 说明 【Ctrl】+【2】 显示彩色通道 【Ctrl】+【数字】 显示单色通道 【Ctrl】+【Y】 以CMYK方式预览(开关) 【Ctrl】+【+】 放大视图 【Ctrl】+【-】 缩小视图 【Ctrl】+【0】 满画布显示 【Ctrl】+【Alt】+【0】 实际象素显示 【Ctrl】+【Shift】+【L】 左对齐或顶对齐 【Ctrl】+【Shift】+【C】 中对齐 【Ctrl】+【Shift】+【R】右对齐或底对齐【Shift】+【←】/【→】|左／右选择 1 个字符【Shift】+【↑】/【↓】|下／上选择 1 行 编辑操作 快捷键 说明 【Ctrl】+【Z】 还原/重做前一步操作 【Ctrl】+【Alt】+【Z】 还原两步以上操作 【Ctrl】+【Shift】+【Z】 重做两步以上操作 【Ctrl】+【X】或【F2】 剪切选取的图像或路径 【Ctrl】+【C】 拷贝选取的图像或路径 【Ctrl】+【Shift】+【C】 合并拷贝 【Ctrl】+【V】或【F4】 将剪贴板的内容粘到当前图形中 【Ctrl】+【Shift】+【V】 将剪贴板的内容粘到选框中 【Ctrl】+【T】 自由变换 【Enter】 应用自由变换(在自由变换模式下) 【Alt】 从中心或对称点开始变换 (在自由变换模式下) 【Shift】 限制(在自由变换模式下) 【Ctrl】 扭曲(在自由变换模式下) 【Esc】 取消变形(在自由变换模式下) 【Ctrl】+【Shift】+【T】 自由变换复制的象素数据 【Ctrl】+【Shift】+【Alt】+【T】 再次变换复制的象素数据并建立一个副本 【DEL】 删除选框中的图案或选取的路径 【Ctrl】+【BackSpace】或【Ctrl】+【Del】 用背景色填充所选区域或整个图层 【Alt】+【BackSpace】或【Alt】+【Del】 用前景色填充所选区域或整个图层 【Shift】+【BackSpace】 弹出“填充”对话框 【Alt】+【Ctrl】+【Backspace】 从历史记录中填充 图像调整 快捷键 说明 【Ctrl】+【L】 调整色阶 【Ctrl】+【Shift】+【L】 自动调整色阶 【Ctrl】+【M】 打开曲线调整对话框 【Ctrl】+【B】 打开“色彩平衡”对话框 【Ctrl】+【U】 打开“色相/饱和度”对话框 【Ctrl】+【Shift】+【U】 去色 【Ctrl】+【I】 反相 图层操作 快捷键 说明 【Ctrl】+【Shift】+【N】 从对话框新建一个图层 【Ctrl】+【Alt】+【Shift】+【N】 以默认选项建立一个新的图层 【Ctrl】+【J】 通过拷贝建立一个图层 【Ctrl】+【Shift】+【J】 通过剪切建立一个图层 【Ctrl】+【G】 与前一图层编组 【Ctrl】+【Shift】+【G】 取消编组 【Ctrl】+【E】 向下合并或合并联接图层 【Ctrl】+【Shift】+【E】 合并可见图层 【Ctrl】+【Alt】+【E】 盖印或盖印联接图层 【Ctrl】+【Alt】+【Shift】+【E】 盖印可见图层 【Ctrl】+【[】 将当前层下移一层 【Ctrl】+【]】 将当前层上移一层 【Ctrl】+【Shift】+【[】 将当前层移到最下面 【Ctrl】+【Shift】+【]】 将当前层移到最上面 【Alt】+【[】 激活下一个图层 【Alt】+【]】 激活上一个图层 【Shift】+【Alt】+【[】 激活底部图层 【Shift】+【Alt】+【]】 激活顶部图层 参考 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处]]></content>
      <categories>
        <category>ps</category>
      </categories>
      <tags>
        <tag>ps快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习九]]></title>
    <url>%2F2017%2F11%2F30%2Foracle%E5%AD%A6%E4%B9%A0%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第九章，主要是用来复习和巩固在课堂学习的知识！ 笔记 增删改 123增: insert into 表名 (列名) values (值)删: delete from 表名 where 条件 (truncate table 表名:清空表)改：update 表名 set 列名1=值1,列名2=值2 。。。 where 条件 复制数据 1、通过一条查询语句创建一个新表(要求目标表不存在)1CREATE TABLE manager AS SELECT empno,ename,sal FROM emp WHERE job='MANAGER'; 2、通过一条查询语句复制数据(要求目标表必须已建好)12INSERT INTO managerSELECT empno, ename, sal FROM emp WHERE job = 'CLERK'; 序列1、创建序列 创建从2000起始，增量为1 的序列abc：12CREATE SEQUENCE abc INCREMENT BY 1 START WITH 2000 MAXVALUE 99999 CYCLE NOCACHE; 使用序列 序列名.nextval: 代表下一个值序列名.currval: 代表当前值 12INSERT INTO manager VALUES(abc.nextval,'小王',2500); 12INSERT INTO manager VALUES(abc.nextval,'小赵',2800); 事务 A.两次连续成功的COMMIT或ROLLBACK之间的操作，称为一个事务。在一个事务内，数据的修改一起提交或撤销，如果发生故障或系统错误，整个事务也会自动撤销 B.数据库事务处理可分为隐式和显式两种。显式事务操作通过命令实现，隐式事务由系统自动完成提交或撤销(回退)工作，无需用户的干预。 C.隐式提交的情况包括：当用户正常退出SQL*Plus或执行CREATE、DROP、GRANT、REVOKE等命令时会发生事务的自动提交。 显示事务: -|-COMMIT|数据库事务提交，将变化写入数据库ROLLBACK|数据库事务回退，撤销对数据的修改SAVEPOINT|创建保存点，用于事务的阶段回退]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习八]]></title>
    <url>%2F2017%2F11%2F29%2Foracle%E5%AD%A6%E4%B9%A0%E5%85%AB%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第八章，主要是用来复习和巩固在课堂学习的知识！ 笔记 子查询 A.通过把一个查询的结果作为另一个查询的一部分,子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。 B.子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。1．单行子查询 如：查询比SCOTT工资高的雇员名字和工资。执行以下查询：123SELECT ename,sal FROM empWHERE sal&gt;(SELECT sal FROM emp WHERE empno=7788); 多行子查询例如如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。 如：查询工资低于任意一个“CLERK”的工资的雇员信息。执行以下查询： 12345SELECT empno, ename, job,sal FROM empWHERE sal &lt; ANY (SELECT sal FROM emp WHERE job = &apos;CLERK&apos;)AND job &lt;&gt; &apos;CLERK&apos;; 如：查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。执行以下查询：1234SELECT empno, ename,sal FROM empWHERE sal &gt; ALL(SELECT sal FROM emp WHERE job= 'SALESMAN'); 如：查询部门20中职务同部门10的雇员一样的雇员信息。执行以下查询： 123SELECT empno, ename, job FROM emp WHERE job IN (SELECT job FROM emp WHERE deptno=10) AND deptno =20; 多列子查询 如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。 查询职务和部门与SCOTT相同的雇员的信息。 1SELECT empno, ename, sal FROM emp WHERE (job,deptno) =(SELECT job,deptno FROM emp WHERE empno=7788); 在FROM从句中使用子查询 在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法。 如：查询雇员表中排在第6～9位置上的雇员。12SELECT ename,sal FROM (SELECT rownum as num,ename,sal FROM emp WHERE rownum&lt;=9 )WHERE num&gt;=6; 集合运算 操 作 描 述 UNION 并集，合并两个操作的结果，去掉重复的部分 UNION ALL 并集，合并两个操作的结果，保留重复的部分 MINUS 差集，从前面的操作结果中去掉与后面操作结果相同的部分 INTERSECT 交集，取两个操作结果中相同的部分 如：查询部门10和部门20的所有职务。 123SELECT job FROM emp WHERE deptno=10UNIONSELECT job FROM emp WHERE deptno=20; 如：查询部门10和20中是否有相同的职务和工资。 123SELECT job,sal FROM emp WHERE deptno=10INTERSECTSELECT job,sal FROM emp WHERE deptno=20; 如：查询只在部门表中出现，但没有在雇员表中出现的部门编号。123SELECT deptno FROM dept MINUS SELECT deptno FROM emp ; 子查询例如我们可能会提出这样的问题，在雇员中谁的工资最高，或者谁的工资比SCOTT高。通过把一个查询的结果作为另一个查询的一部分，可以实现这样的查询功能。出现在其他查询中的查询称为子查询，包含其他查询的查询称为主查询。 A.子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。 B.子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。 C.子查询可以嵌套使用，最里层的查询最先执行。子查询可以在SELECT、INSERT、UPDATE、DELETE等语句中使用。 单行子查询 【训练1】 查询比SCOTT工资高的雇员名字和工资。执行以下查询：12SELECT ename,sal FROM empWHERE sal&gt;(SELECT sal FROM emp WHERE empno=7788); 【训练2】 查询和SCOTT同一部门且比他工资低的雇员名字和工资。执行以下查询： 123SELECT ename,sal FROM empWHERE sal&lt;(SELECT sal FROM emp WHERE empno=7788)AND deptno=(SELECT deptno FROM emp WHERE empno=7788); 【训练3】 查询工资高于平均工资的雇员名字和工资。执行以下查询：12SELECT ename,sal FROM empWHERE sal&gt;(SELECT AVG(sal) FROM emp); 多行子查询 如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。例如【训练4】 查询工资低于任何一个“CLERK”的工资的雇员信息。执行以下查询：123SELECT empno, ename, job,sal FROM empWHERE sal &lt; ANY (SELECT sal FROM emp WHERE job = 'CLERK')AND job &lt;&gt; 'CLERK'; 【训练5】 查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。执行以下查询： 12SELECT empno, ename,sal FROM empWHERE sal &gt; ALL(SELECT sal FROM emp WHERE job= 'SALESMAN'); 【训练6】 查询部门20中职务同部门10的雇员一样的雇员信息。执行以下查询：123SELECT empno, ename, job FROM empWHERE job IN (SELECT job FROM emp WHERE deptno=10)AND deptno =20; 【训练7】 查询职务和SCOTT相同，比SCOTT雇佣时间早的雇员信息。执行以下查询： 123SELECT empno, ename, job FROM empWHERE job =(SELECT job FROM emp WHERE empno=7788)AND hiredate &lt; (SELECT hiredate FROM emp WHERE empno=7788); 多列子查询例如如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。 【训练8】 查询职务和部门与SCOTT相同的雇员的信息。执行以下查询： 12SELECT empno, ename, sal FROM empWHERE (job,deptno) =(SELECT job,deptno FROM emp WHERE empno=7788); 在FROM从句中使用子查询 在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法。 【训练9】 查询雇员表中排在第6～9位置上的雇员。 12SELECT ename,sal FROM (SELECT rownum as num,ename,sal FROM emp WHERE rownum&lt;=9 )WHERE num&gt;=6; 说明：子查询出现在FROM从句中，检索出行号小于等于9的雇员，并生成num编号列。在主查询中检索行号大于等于6的雇员。例如注意：以下用法不会有查询结果，请自行分析原因。12SELECT ename,sal FROM empWHERE rownum&gt;=6 AND rownum&lt;=9; 集合运算 多个查询语句的结果可以做集合运算，结果集的字段类型、数量和顺序应该一样。 【训练1】 查询部门10和部门20的所有职务。 123SELECT job FROM emp WHERE deptno=10&lt;span id="inline-blue"&gt;UNION&lt;/span&gt;SELECT job FROM emp WHERE deptno=20; 【训练2】 查询部门10和20中是否有相同的职务和工资。执行以下查询：123SELECT job,sal FROM emp WHERE deptno=10&lt;span id="inline-blue"&gt;INTERSECT&lt;/span&gt;SELECT job,sal FROM emp WHERE deptno=20; 【训练3】 查询只在部门表中出现，但没有在雇员表中出现的部门编号。执行以下查询： 123SELECT deptno FROM dept&lt;span id="inline-blue"&gt;MINUS&lt;/span&gt;SELECT deptno FROM emp ;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习七]]></title>
    <url>%2F2017%2F11%2F28%2Foracle%E5%AD%A6%E4%B9%A0%E4%B8%83%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第七章，主要是用来复习和巩固在课堂学习的知识！ 笔记 不等连接 拿一个表作为另一表的查询条件或范围如：显示雇员名称，工资和所属工资等级。执行以下查询：123SELECT e.ename, e.sal, s.grade FROM emp e,salgrade sWHERE e.sal BETWEEN s.losal AND s.hisal 自连接 自连接就是一个表，同本身进行连接。对于自连接可以想像存在两个相同的表(表和表的副本)，可以通过不同的别名区别两个相同的表（其它就是内连接）。 显示雇员名称和雇员的经理名称。执行以下查询：123SELECT worker.ename||' 的经理是 '||manager.ename AS 雇员经理 FROM emp worker, emp managerWHERE worker.mgr = manager.empno; 组函数 组函数只能应用于SELECT子句、HAVING子句或ORDER BY子句中。 A.组函数也可以称为统计函数。 B.组函数忽略列的空值。 C.对组可以应用组函数。 D.在组函数中可使用DISTINCT或ALL关键字。 E.ALL表示对所有非NULL值(可重复)进行运算。 F.DISTINCT 表示对每一个非NULL值，如果存在重复值，则组函数只运算一次。如果不指明上述关键字，默认为ALL。 函 数 说 明 AVG 求平均值 COUNT 求计数值，返回非空行数，*表示返回所有行 MAX 求最大值 MIN 求最小值 SUM 求和 STDDEV 求标准偏差，是根据差的平方根得到的 VARIANCE 求统计方差 分组查询 如：按职务统计工资总和。执行以下查询：12SELECT job,SUM(sal) FROM emp GROUP BY job; 多列分组按部门和职务分组统计工资总和。 123SELECT deptno, job, sum(sal) FROM emp GROUP BY deptno, job; HAVING HAVING从句过滤分组后的结果，它只能出现在GROUP BY从句之后，而WHERE从句要出现在GROUP BY从句之前。 统计各部门的最高工资，排除最高工资小于3000的部门。 执行以下查询：123SELECT deptno, max(sal) FROM emp GROUP BY deptnoHAVING max(sal)&gt;=3000; 分组统计结果排序 可以使用ORDER BY从句对统计的结果进行排序，ORDER BY从句要出现在语句的最后。 如：按职务统计工资总和并排序。执行以下查询：123SELECT job 职务, SUM(sal) 工资总和 FROM emp GROUP BY jobORDER BY SUM(sal); 组函数的嵌套使用 如：求各部门平均工资的最高值。执行以下查询：1SELECT max(avg(sal)) FROM emp GROUP BY deptno; 统计查询 统计查询【训练1】 求雇员总人数。执行以下查询： 1SELECT COUNT(*) FROM emp; 【训练2】 求有佣金的雇员人数。执行以下查询：1SELECT COUNT(comm) FROM emp; 【训练3】 求部门10的雇员的平均工资。执行以下查询：1SELECT AVG(sal) FROM emp WHERE deptno=10; 【训练4】 求最晚和最早雇佣的雇员的雇佣日期。执行以下查询：1SELECT MAX(hiredate),MIN(hiredate) FROM emp; 【训练5】 求雇员表中不同职务的个数。执行以下查询： 1SELECT COUNT( DISTINCT job) FROM emp; 分组统计通过下面的训练，我们来了解分组的用法。【训练6】 按职务统计工资总和。 步骤1：执行以下查询： 1SELECT SUM(sal) FROM emp GROUP BY job; 步骤2：执行以下查询： 1SELECT job,SUM(sal) FROM emp GROUP BY job; 【练习2】查看以下查询的显示结果，并解释原因。 1SELECT ename,job,SUM(sal) FROM emp GROUP BY sal; 多列分组统计 【训练7】 按部门和职务分组统计工资总和。 123SELECT deptno, job, sum(sal) FROM emp GROUP BY deptno, job; 分组统计结果限定 对分组查询的结果进行过滤，要使用HAVING从句。HAVING从句过滤分组后的结果，它只能出现在GROUP BY从句之后，而WHERE从句要出现在GROUP BY从句之前。 【训练8】 统计各部门的最高工资，排除最高工资小于3000的部门。执行以下查询：123SELECT deptno, max(sal) FROM empGROUP BY deptnoHAVING max(sal)&gt;=3000; 【训练8】 统计各部门的最高工资，排除最高工资小于3000的部门。执行以下查询：123SELECT deptno, max(sal) FROM empGROUP BY deptnoHAVING max(sal)&gt;=3000; 分组统计结果排序 可以使用ORDER BY从句对统计的结果进行排序，ORDER BY从句要出现在语句的最后。例如【训练9】 按职务统计工资总和并排序。执行以下查询：123SELECT job 职务, SUM(sal) 工资总和 FROM emp GROUP BY jobORDER BY SUM(sal); 组函数的嵌套使用 在如下训练中，使用了组函数的嵌套。【训练10】 求各部门平均工资的最高值。执行以下查询： 1SELECT max(avg(sal)) FROM emp GROUP BY deptno; 注意：虽然在查询中有分组列，但在查询字段中不能出现分组列。如下的查询是错误的： 1SELECT deptno,max(avg(sal)) FROM emp GROUP BY deptno; 因为各部门平均工资的最高值不应该属于某个部门。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jar的加入(转)]]></title>
    <url>%2F2017%2F11%2F27%2Fjar%E7%9A%84%E5%8A%A0%E5%85%A5%2F</url>
    <content type="text"><![CDATA[现在的项目基本上都是java web项目,所以导入jar包会出现问题,主要介绍一下java项目与javaweb项目的区别: java项目: 在classLoader加载jar和class的时候,是分开加载的,一般jar导入分两种: 1.在web-inf下的lib中直接引入 2.在user library上引入 无论以上哪种引入,jar包都能加载并且运行,classLoader会智能加载(本地JRE运行) javaweb项目; 不是通过本地的JRE运行的，而是部署到web服务器(比如tomcat,jetty)，这些服务器都实现了自身的类加载器. 以tomcat为例: 1.common CommonClassLoader 2.server CatalinaClassLoader 3.shared SharedClassLoader 4.webapps webappClassLoader(加载WEB-INF下的jar) 简单来说,如果做javaweb项目引入jar包的时候,需要将jar包导入到WEB-INF下,这样服务器就能够加载并且项目跑起来的时候,项目的方法也可以调用,如果放入到user library中是不可以的,因为这样只能本地运行,服务器是加载不到的.所以项目本地调用方法的时候没有问题,但是服务器跑起来就会报出找不到相应的jar. 转链地址 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习六]]></title>
    <url>%2F2017%2F11%2F27%2Foracle%E5%AD%A6%E4%B9%A0%E5%85%AD%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第六章，主要是用来复习和巩固在课堂学习的知识！ 笔记 相等连接（内连接） 123select ename,job,sal,comm,emp.deptno,dnamefrom emp,deptwhere emp.deptno = dept.deptno 注意：如果两个表有同名列，那么前面必须接表名 如： emp.deptno ,如果不是同名字段则表名可以省略 inner join 的写法: 例如123select ename,job,sal,comm,emp.deptno,dname from emp inner join dept on emp.deptno = dept.deptno 三表或三表以上的写法 123select 字段1，字段2 , 字段3 。。。。from 表1，表2，表3.。。where 表1.外键 = 表2.主键 and 表1.外键 = 表3.主键 and 。。。 注意：两个表有一个条件 ，三个表有两个条件 ，四个表有三个条件 以此类推 外连接(不等连接) 左外连接即在内连接的基础上，左边表中有但右边表中没有的记录也以null的形式显示出来，右外连接则反之 1.写法1 例如(右外连接) 123select ename,d.deptno,dnamefrom emp e,dept dwhere e.deptno(+) = d.deptno (左外连接)123select ename,d.deptno,dnamefrom emp e,dept dwhere d.deptno = e.deptno(+) 2.写法2123select ename,d.deptno,dname from emp e right join dept d on e.deptno = d.deptno 高级查询 多表联合查询 A.通过连接可以建立多表查询，多表查询的数据可以来自多个表，但是表之间必须有适当的连接条件。 B.一般N个表进行连接，需要至少N-1个连接条件，才能够正确连接。两个表连接是最常见的情况，只需要说明一个连接条件。 C.两个表的连接有四种连接方式： 相等连接。 不等连接。 外连接。 自连接。 相等连接通过两个表具有相同意义的列，可以建立相等连接条件。 【训练1】 显示雇员的名称和所在的部门的编号和名称。执行以下查询： 123456789101112SELECT emp.ename,emp.deptno,dept.dname FROM emp,dept WHERE emp.deptno=dept.deptno;```sql【训练2】 使用表别名。执行以下查询：```sqlSELECT ename,e.deptno,dname FROM emp e,dept d WHERE e.deptno=d.deptno; 外连接 A.在以上的例子中，相等连接有一个问题：如果某个雇员的部门还没有填写，即保留为空，那么该雇员在查询中就不会出现；或者某个部门还没有雇员，该部门在查询中也不会出现。 B.为了解决这个问题可以用外连，即除了显示满足相等连接条件的记录外，还显示那些不满足连接条件的行。外连操作符为(+)，它可以出现在相等连接条件的左侧或右侧。 【训练4】 使用外连显示不满足相等条件的记录。步骤1：显示雇员的名称、工资和所在的部门名称及没有任何雇员的部门。执行以下查询： 123SELECT ename,sal,dname FROM emp,dept WHERE emp.deptno(+)=dept.deptno; 外连接123SELECT ename,sal,dname FROM emp right outer join dept on emp.deptno = dept.deptno; 步骤2：显示雇员的名称、工资和所在的部门名称及没有属于任何部门的雇员。执行以下查询： 123SELECT ename,sal,dname FROM emp,dept WHERE emp.deptno=dept.deptno(+); 123SELECT ename,sal,dname FROM emp left outer join dept on emp.deptno = dept.deptno; 不等连接还可以进行不等的连接。 【训练5】 显示雇员名称，工资和所属工资等级执行以下查询： 123SELECT e.ename, e.sal, s.grade FROM emp e,salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal 自连接最后是一个自连接的训练实例，自连接就是一个表，同本身进行连接。对于自连接可以想像存在两个相同的表(表和表的副本)，可以通过不同的别名区别两个相同的表。 【训练6】 显示雇员名称和雇员的经理名称执行以下查询： 123SELECT worker.ename||' 的经理是 '||manager.ename AS 雇员经理 FROM emp worker, emp manager WHERE worker.mgr = manager.empno; 统计查询Oracle提供了一些函数来完成统计工作，这些函数称为组函数，组函数不同于前面介绍和使用的函数(单行函数)。组函数可以对分组的数据进行求和、求平均值等运算。 组函数只能应用于SELECT子句、HAVING子句或ORDER BY子句中。组函数也可以称为统计函数。 组函数忽略列的空值。对组可以应用组函数。在组函数中可使用DISTINCT或ALL关键字。ALL表示对所有非NULL值(可重复)进行运算。DISTINCT 表示对每一个非NULL值，如果存在重复值，则组函数只运算一次。如果不指明上述关键字，默认为ALL。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习五]]></title>
    <url>%2F2017%2F11%2F26%2Foracle%E5%AD%A6%E4%B9%A0%E4%BA%94%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第五章，主要是用来复习和巩固在课堂学习的知识！ 函数专项 数值型函数 字符型函数 字符型函数包括大小写转换和字符串操作函数。大小写转换函数有3个. 日期型函数 A.Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。 B.SYSDATE是返回系统日期和时间的虚列函数 【训练1】 返回系统的当前日期。输入并执行查询：1SELECT sysdate FROM dual; 【训练2】 返回2003年2月的最后一天。输入并执行查询：1SELECT last_day('08-2月-03') FROM dual; 【训练3】 假定当前的系统日期是2003年2月6日，求再过1000天的日期。输入并执行查询：1SELECT sysdate+1000 AS "NEW DATE" FROM dual; 【训练4】 假定当前的系统日期是2003年2月6日，显示部门10雇员的雇佣天数。输入并执行查询：123SELECT ename, round(sysdate-hiredate) DAYSFROM empWHERE deptno = 10; 转换函数 Oracle的类型转换分为自动类型转换和强制类型转换。常用的类型转换函数有TO_CHAR、TO_DATE或TO_NUMBER 自动类型转换Oracle可以自动根据具体情况进行如下的转换： 字符串到数值。 字符串到日期。 数值到字符串。 日期到字符串。 【训练1】 自动转换字符型数据到数值型。输入并执行查询：1SELECT '12.5'+11 FROM dual; 【训练2】 自动转换数值型数据到字符型。执行以下查询：1SELECT '12.5'||11 FROM dual; 日期类型转换将日期型转换成字符串时，可以按新的格式显示。如格式YYYY-MM-DD HH24:MI:SS表示“年-月-日 小时:分钟:秒”。Oracle的日期类型是包含时间在内的。 【训练3】 将日期转换成带时间和星期的字符串并显示。执行以下查询：1SELECT TO_CHAR(sysdate,'YYYY-MM-DD HH24:MI:SS AM DY') FROM dual; 【训练4】 将日期显示转换成中文的年月日。输入并执行查询：1SELECT TO_CHAR(sysdate,'YYYY"年"MM"月"DD"日"') FROM dual; 【训练5】 将雇佣日期转换成字符串并按新格式显示。输入并执行查询：12SELECT ename, to_char(hiredate, 'DD Month YYYY') HIREDATEFROM emp; 【训练6】 以全拼和序列显示时间。执行以下查询：12SELECT SYSDATE,to_char(SYSDATE,'yyyysp'),to_char(SYSDATE,'mmspth'),to_char(SYSDATE,'ddth') FROM dual; 【训练7】 时间显示的大小写。步骤1：执行以下查询：1SELECT SYSDATE,to_char(SYSDATE,'yyyysp') FROM dual; 步骤2：执行以下查询：1SELECT to_char(SYSDATE,'Yyyysp') FROM dual; 步骤3：执行以下查询：1SELECT SYSDATE,to_char(SYSDATE,'YYyysp') FROM dual; 数字类型转换 将数字型转换成字符串时，也可以按新的格式显示 【训练8】 将数值转换成字符串并按新格式显示。执行以下查询：1SELECT TO_CHAR(123.45,’9999.99'), TO_CHAR(12345,'L9.9EEEE') FROM dual; 【训练9】 将数值转换成字符串并按新格式显示。执行以下查询：12SELECT TO_CHAR(sal,'$99,999') SALARY FROM empWHERE ename = 'SCOTT'; 其他函数 Oracle还有一些函数，如decode和nvl，这些函数也很有用 空值的转换: 如果对空值NULL不能很好的处理，就会在查询中出现一些问题。在一个空值上进行算术运算的结果都是NULL。最典型的例子是，在查询雇员表时，将工资sal字段和津贴字段comm进行相加，如果津贴为空，则相加结果也为空，这样容易引起误解。 使用nvl函数，可以转换NULL为实际值。该函数判断字段的内容，如果不为空，返回原值；为空，则返回给定的值。 如下3个函数，分别用新内容代替字段的空值： nvl(comm, 0)：用0代替空的Comm值。nvl(hiredate, ‘01-1月-97’)：用1997年1月1日代替空的雇佣日期。nvl(job, ‘无’)：用“无”代替空的职务 decode函数: decode函数可以通过比较进行内容的转换，完成的功能相当于分支语句。在参数的最后位置上可以存在单独的参数，如果以上比较过程没有找到匹配值，则返回该参数的值，如果不存在该参数，则返回NULL。 【训练1】 使用nvl函数转换空值。执行以下查询：1SELECT ename,nvl(job,'无'),nvl(hiredate,'01-1月-97'),nvl(comm,0) FROM emp; 【训练2】 将职务转换成中文显示。执行以下查询：1SELECT ename,decode(job, 'MANAGER', '经理', 'CLERK','职员', 'SALESMAN','推销员', 'ANALYST','系统分析员','未知') FROM emp; 最大、最小值函数1greatest返回参数列表中的最大值，least返回参数列表中的最小值。 如果表达式中有NULL，则返回NULL。 练习【练习1】显示雇员名称和雇佣的星期数。1Select ename,round((sysdate-hiredate)/7) from emp; 【练习2】显示从本年1月1日开始到现在经过的天数(当前时间取SYSDATE的值)。1Select sysdate - to_date(‘2017-1-1’,’YYYY-MM-DD’ )from dual; 【练习3】显示2008年的8月8日为星期几。1Select to_char(‘8-8月-2008’,’DY’) from dual; 【练习4】对部门表的部门名称和城市名进行转换。1234select * from dept;select decode(dname,'ACCOUNTING','统计部','RESEARCH','研发部','SALES','销售部','OPERATIONS','其它部门') 部门,decode(loc,'NEW YORK','纽约','DALLAS','达拉斯','CHICAGO','芝加哥','BOSTON','波士顿') 城市 from dept; 【练习5】判断用户的角色是否为SYSDBA。1Select userenv(‘ISDBA’) from dual;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习四]]></title>
    <url>%2F2017%2F11%2F25%2Foracle%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第四章，主要是用来复习和巩固在课堂学习的知识！ 条件查询 模糊查询(between、in、like)1.between:在某某之间显示工资在1000～2000之间的雇员信息。输入并执行查询： 1SELECT * FROM emp WHERE sal BETWEEN 1000 AND 2000; 2.in: 在某某之内显示职务为“SALESMAN’，“CLERK”和“MANAGER”的雇员信息。输入并执行查询： 1SELECT * FROM emp WHERE job IN ('SALESMAN','CLERK','MANAGER'); 3.like:与通配符合用通配符： %：代表0个或任意个字符 _:代表1个字符 显示姓名以“S”开头的雇员信息。输入并执行查询：1SELECT * FROM emp WHERE ename LIKE 'S%'; 显示姓名第二个字符为“A”的雇员信息。执行查询： 1SELECT * FROM emp WHERE ename LIKE '_A%'; 4.空值查询 123空：is null&lt;br/&gt; 非空：is not null&lt;br/&gt;如：查询奖金为空的雇员信息&lt;br/&gt; 1select * from emp where comm is null 函数 数学函数 函 数 功 能 实 例 结 果 abs 求绝对值函数 abs(-5) 5 sqrt 求平方根函数 sqrt(2) 1.41421356 power 求幂函数 power(2,3) 8 【训练1】 使用数值型函数练习。 步骤1：使用求绝对值函数abs。 1SELECT abs(-5) FROM dual; 步骤2：使用求平方根函数sqrt。 1SELECT sqrt(2) FROM dual; 步骤3：使用ceil函数。 1SELECT ceil(2.35) FROM dual; 步骤4：使用floor函数。 1SELECT floor(2.35) FROM dual; 使用四舍五入函数round 格式: round(数字，保留的位数) 1SELECT round(45.923,2), round(45.923,0), round(45.923,-1) FROM dual; 字符型函数 函数名称 功 能 实 例 结 果 ascii 获得字符的ASCII码 Ascii(‘A’) 65 chr 返回与ASCII码相应的字符 Chr(65) A lower 将字符串转换成小写 lower (‘SQL Course’) sql course upper 将字符串转换成大写 upper(‘SQL Course’) SQL COURSE initcap 将字符串转换成每个单词以大写开头 initcap(‘SQL course’) Sql Course concat 连接两个字符串 concat(‘SQL’, ‘ Course’) SQL Course substr 给出起始位置和长度，返回子字符串 substr(‘String’,1,3) Str length 求字符串的长度 length(‘Wellcom’) 7 trim 在一个字符串中去除另一个字符串 trim(‘S’ FROM ‘SSMITH’) MITH replace 用一个字符串替换另一个字符串中的子字符串 replace(‘ABC’, ‘B’, ‘D’) ADC 【训练1】 如果不知道表的字段内容是大写还是小写，可以转换后比较。输入并执行查询： 123456789SELECT empno, ename, deptno FROM empWHERE lower(ename) ='blake';```sql【训练2】 显示名称以“W”开头的雇员，并将名称转换成以大写开头。输入并执行查询： ```sqlSELECT empno,initcap(ename),job FROM emp WHERE substr(ename,1,1)='W'; 【训练3】 显示雇员名称中包含“S”的雇员名称及名称长度。输入并执行查询： 12SELECT empno,ename,length(ename) FROM empWHERE instr(ename, 'S', 1, 1)&gt;0; 日期型函数 A.Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。 B.SYSDATE是返回系统日期和时间的虚列函数。 显示1982年以后雇佣的雇员姓名和雇佣时间。 输入并执行查询：1SELECT ename,hiredate FROM emp WHERE hiredate&gt;='1-1月-82'; 显示部门10以外的其他部门的雇员。输入并执行查询： 1SELECT * FROM emp WHERE NOT deptno=10; 显示姓名第二个字符为“A”的雇员信息。执行查询： 1SELECT * FROM emp WHERE ename LIKE '_A%'; 显示经理编号没有填写的雇员。输入并执行查询： 1SELECT ename, mgr FROM emp WHERE mgr IS NULL; 如果不知道表的字段内容是大写还是小写，可以转换后比较。输入并执行查询： 12SELECT empno, ename, deptno FROM empWHERE lower(ename) ='blake'; 显示名称以“W”开头的雇员，并将名称转换成以大写开头。输入并执行查询： 1SELECT empno,initcap(ename),job FROM emp WHERE substr(ename,1,1)='W'; 【训练15】 显示雇员名称中包含“S”的雇员名称及名称长度。输入并执行查询：12SELECT empno,ename,length(ename) FROM empWHERE instr(ename, 'S', 1, 1)&gt;0; 在Oracle/PLSQL中，instr函数返回要截取的字符串在源字符串中的位置。只检索一次，就是说从字符的开始到字符的结尾就结束。语法如下：sql instr( string1, string2 [, start_position [, nth_appearance ] ] )sql参数分析： string1:源字符串，要在此字符串中查找。 string2:要在string1中查找的字符串. start_position:代表string1 的哪个位置开始查找。此参数可选，如果省略默认为1. 字符串索引从1开始。如果此参数为正，从左到右开始检索，如果此参数为负，从右到左检索，返回要查找的字符串在源字符串中的开始索引。 nth_appearance:代表要查找第几次出现的string2. 此参数可选，如果省略，默认为 1.如果为负数系统会报错。 注意： 如果String2在String1中没有找到，instr函数返回0.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习三]]></title>
    <url>%2F2017%2F11%2F24%2Foracle%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第三章，主要是用来复习和巩固在课堂学习的知识！ 创建表空间 完整版 1234567create tablespace epet_tablespacedatafile 'c:epet.dbf'size 100Mautoextend on next 32M maxsize unlimitedloggingextent management localsegment space mamgement auto; 简化版 123create tablespace epet_tablespacedatafile 'c:epet.dbf'size 100M 数据查询 查询格式： 12345select 列名 from 表名 where 查询条件 group by 分组列 having 分组后条件 order by 排序列 简单查询（查询加条件） 如：查询部门10的雇员。 输入并执行查询：1SELECT * FROM emp WHERE deptno=10; 行号 每个表都有一个虚列ROWNUM，它用来显示结果中记录的行号。我们在查询中也可以显示这个列。【任务1】 显示EMP表的行号。 输入并执行查询： 1SELECT rownum,ename FROM emp; 查询时进行计算 1、显示雇员工资上浮20%的结果。输入并执行查询: 1SELECT ename,sal,sal*(1+20/100) FROM emp; 2、显示每一个雇员的总收入(工资+奖金) 12update emp set comm = 0 where comm is null; --将工资为null的改为0select ename,sal+comm as 总收入 from emp; 使用别名 在查询中使用列别名。输入并执行： 1SELECT ename AS 名称, sal 工资 FROM emp; 注意：建议大家省略AS 在列别名上使用双引号。（当你的别名为关键字或别名中有特殊符号时需要加双引号）输入并执行查询： 1SELECT ename AS "select", sal*12+5000 AS "年度工资(加年终奖)" FROM emp; 连接运算符 连接运算符是双竖线“||”。通过连接运算可以将两个字符串连接在一起。如： 123456789101112131415SELECT ename||job AS "雇员和职务表" FROM emp;‘5’+ 5 结果为 10 ‘5’|| 5 结果为 '55' ```sql- 查询结果的排序ASC 表示升序 (可省略) Desc 表示降序(不可省略)1.升序排序【训练1】 查询雇员姓名和工资，并按工资从小到大排序。输入并执行查询：```sqlSELECT ename, sal FROM emp ORDER BY sal; 2．降序排序【训练2】 查询雇员姓名和雇佣日期，并按雇佣日期排序，后雇佣的先显示。输入并执行查询： 1SELECT ename,hiredate FROM emp ORDER BY hiredate DESC; 3.多列排序【训练3】 查询雇员信息，先按部门从小到大排序，再按雇佣时间的先后排序。输入并执行查询： 1SELECT ename,deptno,hiredate FROM emp ORDER BY deptno,hiredate; 消除重复行 如果在显示结果中存在重复行，可以使用的关键字DISTINCT消除重复显示。如：使用DISTINCT消除重复行显示。输入并执行查询： 1SELECT DISTINCT job FROM emp; 练习【练习1】显示当前的账户名，显示当前账户的EMP表的结构，显示EMP表中的数据。 123Show user;Desc emp;Select * from emp; 【练习2】根据EMP表和DEPT表的显示结果，说出雇员ADAMS的雇员编号、职务、经理名字、雇佣日期、工资、津贴和部门编号以及该雇员所在的部门名称和所在城市。 12Select * from emp where ename = ‘ADAMS’Select dname,loc from dept where deptno = (select deptno from emp where ename =’ADAMS’) 【练习3】说出职务为CLERK的工资最高的雇员是哪一位？职务为CLERK、部门在NEW YORK的雇员是哪一位? 12select * from emp where sal = (Select max(sal) from emp where job = ‘CLERK’)Select * from emp where job = ‘CLERK’ and deptno in (select deptno from dept where loc = ‘NEW YORK’) 【练习4】显示DEPT表的内容，按以下的形式: 部门ACCOUNTING所在的城市为NEW YORK 1Select ‘部门’||dname||’所在的城市为’||loc from dept]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习二]]></title>
    <url>%2F2017%2F11%2F23%2Foracle%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第二章，主要是用来复习和巩固在课堂学习的知识！ 创建用户说明：创建新用户user1，口令为123，口令需要以字母开头。 登录SCOTT账户 1create user user1 identified by 123 -- 创建新用户user1 授权 1234grant connect to user1; -- 授予user1连接数据库权限grant create table to user1; -- 授予user1创建表的权限grant create proedure to user1; -- 授予user1创建存储过程的权限grant unlimited tablespace to user1; -- 授予user1表空间使用权限 创建表说明：以创建表的方式复制数据到新账户。 123create table emp as select * from scott.emp;create table dept as select * from scott.dept;create table salgrades as select * from scott.salgrade; 在USER1账户下复制了SCOTT账户的三个表：EMP、DEPT和SALGRADES。 给用户授权 方式一：授予角色 123connect : 登录resource: 普通权限，用于操作DBA: 管理员权限 （慎用） 例如： 12grant connect to user1 grant connect,resource to user1 方式二：授予单个权限 例如： 12grant create table to user1 授予user1建表的权限grant drop table to user1 授予user1删表的权限 方式三：将某个对象的权限授予用户 例如： 12grant select on scott.emp to user1 -- 将scott用户的emp表的查询权限授予user1grant all on scott.emp to user1 将scott用户的emp表的所有权限授予user1 收回权限 revoke 权限 from 用户 例如： 12revoke connect from user1 收回user1的connect权限revoke select on scott.emp from user1 收回user1对emp表的查询权限]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库命令名规范]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[良好的命名习惯是一种美德 数据库命令名规范是十分必要的，一个好的命名可以让人清楚的知道这是什么，一目了然！ 总体命名规范 名称的长度不超过32个字符 名称采用英文单词、英文单词缩写和数字，单词之间用“_”分隔 数据库对象名称首字母必须小写。 不得采用“_”作为名称的起始字母和终止字母。 名称必须望文知意。 名称不得与数据库管理系统保留字冲突。 不要在对象名的字符之间留空格。 数据库名 数据库名定义为系统名+模块名，或直接采用系统名 数据库名全部采用小写。 数据库文件 数据文件命名采用数据库名+_+文件类型+［文件序号］.文件后缀，文件序号为1、2、3…9等数值，当数据库中某一文件类型的文件有多个时加上文件序号以区别。只有一个时可不加。 文件后缀：主数据文件为.mdf，其它数据文件为.ndf,日志文件为.ldf。 文件名全部采用小写。 表 表命名要遵循以下原则：采用“系统名+_+t_+模块名+_+表义名”格式构成。 若数据库中只含有单个模块，命名可采用“系统名+t_+表义名”格式构成。 整个表名的长度不要超过30个字符。系统名、模块名均采用小写字符。 模块名或表义名均以其英文单词命名，且字符间不加分割符；表义名中单词的首字符大写，其它字符小写，多个单词间也不加任何分割符，单词全部采用单数形式。 表别名命名规则：取表义名的前3个字符加最后一个字符。如果存在冲突，适当增加字符（如取表义名的前4个字符加最后一个字符等）。 关联表命名为Re_表A_表B,Re是Relative的缩写，表A和表B均采用其表义名或缩写形式。 数据库设计规范 数据库中不论是表名还是字段名，都一律用英文，不准出现其它语言； 为了不增加数据库当中的表名的长度，一般不允许出现如Form或者Table的字样，如：记录表：应为Record,而不是RecordTable 数据库当中的表名的命名，不允许出现空格，假如有几个单词出现的话，每个单词之间用 ”_” 隔开如人事信息表：应为Human_Info，而不是Human Info； 每个单词的第一个字母必须大写；如果太长，为了不增加编程的难度可采用缩写的方式，每个单词可取三到四个字母表示，也可根据实际情况，实际习惯进行缩写 属性（列或字段） 采用有意义的列名，为实际含义的英文单词，且字符间不加任何分割符。 属性名前不要加表名等作为前缀。属性后不加任何类型标识作为后缀。不要使用“ID”等与系统保留关键字冲突的单词作为列名。 主键 任何表都必须定义主键。 表主键命名为：“pk++表名(或缩写)++主键标识”。 外键 表外键命名为：“fk++表名(或缩写)+主表名(或缩写)+_+主键标识”。 索引 索引的命名为：“表名（或缩写）+_+列名+_idx”。 其中多单词组成的属性列列名取前几个单词首字符，加末单词组成。 Default标识 由“df+_+&lt;default标识名&gt;”组成。 Rule标识 由“ru+_+&lt;Rule标识名&gt;”组成。 自定义数据类型 自定义数据类型由“ud++&lt;自定义数据类型标识&gt;++&lt;数据类型&gt;”组成 触发器 AFTER型触发器：系统名+tr_+&lt;表名&gt;_+&lt;i,u,d的任意组合&gt;，其中i，u，d分别表示insert、update和delete。 INSTEADOF型触发器： 系统名+ti_+&lt;表名&gt;+_+&lt;i,u,d的任意组合&gt;，其中i，u，d分别表示insert、update和delete。 视图 视图命名以系统名+v_+模块名作为前缀，其他命名规则和表的命名类似。 存储过程命名 “系统名+sp+_+存储过程标识(缩写)”组成。 存储过程标识要以实际含义的英文单词构成，并用下划线分割各个组成部分. 函数 函数命名由“系统名+f+_+函数标识”组成。 变量名 参数变量命名采用“i(o或io)+_+名称”形式，前缀i或o表示输入还是输出参数。 过程变量命名采用“l+_+名称”形式。 变量名采用小写，若属于词组形式，用下划线分隔每个单词。 ##角色 全部使用小写字符命名。 由“系统名称++role++名词(或缩写)或名词短语(或缩写)”组成。 ##用户 全部使用小写字符命名。 由“系统名称++user++名词(或缩写)或名词短语(或缩写)”组成。 Transact-SQL编程基本规范 一般性注释: 注释可以包含在批处理中。在触发器、存储过程中包含描述性注释将会大大增加文本的可读性和可维护性。 注释尽可能详细、全面。 创建每一个数据对象前，应具体描述该对象的功能和用途。 传入参数的含义应该有所说明。如果取值范围确定，也应该一并说明。取值有特定含义的变量（如boolean类型变量），应给出每个值的含义。 注释语法包含两种情况：单行注释、多行注释。 单行注释：注释前有两个连字符（–），最后以换行符结束。一般对变量、条件子句可以采用该类注释。 多行注释：符号/和/之间的内容为注释内容。对某项完整的操作建议使用该类注释。 注释应当简洁，同时应描述清晰。 函数文本注释 编写函数文本–如视图、函数、触发器、存储过程以及其他数据对象时，必须为每个函数增加适当注释。该注释以多行注释为主，主要结构如下： / 参考资源 参考1]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql五种约束]]></title>
    <url>%2F2017%2F11%2F23%2Fsql%E4%BA%94%E7%A7%8D%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[SQL server的五种约束： 主键约束（Primay Key Coustraint） 外键约束（Foreign Key Counstraint） 唯一约束（Unique Counstraint） 检查约束（Check Counstraint） 默认约束（Default Counstraint） 主键约束（Primay Key Coustraint） 直接添加： create table 表名 ( 字段名 数据类型 primary key ); 联合主键： create table 表名 ( 字段名1 数据类型1 字段名2 数据类型2 constraint PK_字段名1_字段名2 可以省略此行（约束名称） primary key(字段名1,字段名2) ); alter添加: 1.alter table 表名1 modify 字段名1 类型名1 primary key; 2.alter table 表名2 add primary key(字段名2); 3.alter table 表名3 add constrain 约束名 primary key(字段名3); 删除主键约束 alter table 表名 drop primary key; 默认约束（Default Counstraint） 直接添加： create table 表名 ( 字段名 类型名 default(条件) ) alter添加: alter table 表名1 modify 字段名1 类型名1 default 条件1; alter table 表名2 add constarint 字段名2 类型名 default 条件2 ; 改变默认约束： alter table 表名1 change 字段名1 字段名1 类型名1 default 条件1; 删除默认约束： alter table 表名1 modify 字段名1 类型名1; alter table 表名2 change 字段名2 字段名2 类型名2 唯一约束（Unique Counstraint） 直接添加： create table 表名1 （字段名1 类型名1 unique）; create table 表名2 （字段名2 类型名2，unique key(字段2)）; alter添加: alter table 表名1 modify 字段名1 类型名1 unique; alter table 表名2 add unique(字段名2); alter table 表名3 add unique key (字段名3); alter table 表名4 add constarint 约束名4 unique (字段名4); alter table 表名5 add constarint 约束名5 unique key (字段名5); 改变唯一约束： alter table 表名1 change 字段名1 字段名1 类型名1 unique; 删除唯一约束： alter table 表名1 drop index 字段名1; 检查约束（Check Counstraint） 直接添加： create table 表名1 ( 字段名1 类型名1 check (条件） ); alter添加: alter table 表名1 add constarint 约束名1 default （字段名1条件）; 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL serve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习一]]></title>
    <url>%2F2017%2F11%2F22%2Foracle%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第一章，主要是用来复习和巩固在课堂学习的知识！ 首先在学习之前，我们应该得安装一个oracle数据库，本人推荐oracle 11g（注意：oracle安装最好一次到位，请细心处理！） 准备 打开oracle主服务 找到pc上的计算机右击，找到管理打开，找到并打开服务和应用程序，打开服务并找到OracleServiceORCL【ORCL为你数据库服务的名字，一般默认为ORCL】 打开监听器 OracleOraDb11g_home1TNSListener 监听器一般就在oracle主服务上面，如果没有监听器就需要重新配置一个 配置监听器 开始菜单中找到net configration assistant添加一个监听器（不详细解释） 第三方工具（plsqldev）【需要注册】PL/SQL Developer是一个集成开发环境，由Allround Automations公司开发，专门面向Oracle数据库存储的程序单元的开发。如今，有越来越多的商业逻辑和应用逻辑转向了Oracle Server，因此，PL/SQL编程也成了整个开发过程的一个重要组成部分。PL/SQL Developer侧重于易用性、代码品质和生产力，充分发挥Oracle应用程序开发过程中的主要优势的。 解锁SCOTT用户 登录system用户 新建一个sql命令栏 输入下例命令： 12alter user scott account unlock; -- 解锁scott用户alter user scott identified by tiger; -- 修改scott密码 数据库知识扩展【了解】 数据库应用系统 典型的数据库应用有C/S(客户/服务器)和B/S(浏览器/服务器)两种模式 三个规范化设计规则 第一范式(1NF)：实体的所有属性必须是单值的并且不允许重复。第二范式(2NF)：实体的所有属性必须依赖于实体的惟一标识。第三范式(3NF)：一个非惟一标识属性不允许依赖于另一个非惟一标识属性。 CONNECT命令 1CONNECT SCOTT/TIGER@MYDB -- 重新连接数据库 环境设置命令 在SQLPlus环境下，可以通过SHOW ALL命令可以查看SQLPlus的环境参数。 显示当前用户【注意：使用SELECT USER FROM dual命令也可以取得用户名】 1show user]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达语法]]></title>
    <url>%2F2017%2F11%2F22%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。 在线正则匹配工具 http://www.regexpal.com/ http://rubular.com/ 正则字符 元字符 /.../ -- 代表一个模式的开始和结束 ^ -- 匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置 $ -- 匹配行或字符串的结尾、 \b -- 不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中&quot;This is Regex&quot;匹配单独的单词 &quot;is&quot; 正则就要写成 &quot;\bis\b（\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界） \d -- 匹配数字,等价[0-9] \w -- 匹配字母，数字，下划线 ,等价[a-zA-Z0-9] \s -- 匹配空格(例如字符 &quot;a b c&quot; 正则：&quot;\w\s\w\s\w&quot; 一个字符后跟一个空格，如有字符间有多个空格直接把&quot;\s&quot; 写成 &quot;\s+&quot; 让空格重复) . -- 匹配除了换行符以外的任何字符 [abc] -- 字符组 匹配包含括号内元素的字符 反义元字符： \W -- 匹配任意不是字母，数字，下划线 的字符 \S -- 匹配任意不是空白符的字符 \D -- 匹配任意非数字的字符 \B -- 匹配不是单词开头或结束的位置 [^abc] -- 匹配除了abc以外的任意字符 量词： * -- 重复零次或更多（例如&quot;aaaaaaaa&quot; 匹配字符串中所有的a 正则： &quot;a*&quot; 会出到所有的字符&quot;a&quot;） + -- 重复一次或更多次（例如&quot;aaaaaaaa&quot; 匹配字符串中所有的a 正则： &quot;a+&quot; 会取到字符中所有的a字符， &quot;a+&quot;与&quot;a*&quot;不同在于&quot;+&quot;至少是一次而&quot;*&quot; 可以是0次，） ? -- 重复零次或一次（例如&quot;aaaaaaaa&quot; 匹配字符串中的a 正则 ： &quot;a?&quot; 只会匹配一次，也就是结果只是单个字符a） {n} -- 重复n次（例如从&quot;aaaaaaaa&quot; 匹配字符串的a 并重复3次 正则： &quot;a{3}&quot; 结果就是取到3个a字符 &quot;aaa&quot;;） {n,m} -- 重复n到m次例如正则 &quot;a{3,4}&quot; 将a重复匹配3次或者4次 所以供匹配的字符可以是三个&quot;aaa&quot;也可以是四个&quot;aaaa&quot; 正则都可以匹配到 {n,} -- 重复n次或更多次（与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则&quot;a{3,}&quot; a至少要重复3次） 限定符： +? -- 重复1次或更多次，但尽可能少重复 ?? -- 重复0次或1次，但尽可能少重复（如 &quot;aaacb&quot; 正则 &quot;a.??b&quot; 只会取到最后的三个字符&quot;acb&quot;） {n,m}? -- 重复n到m次，但尽可能少重复（ 如 &quot;aaaaaaaa&quot; 正则 &quot;a{0,m}&quot; 因为最少是0次所以取到结果为空） {n,}? -- 重复n次以上，但尽可能少重复（如 &quot;aaaaaaa&quot; 正则 &quot;a{1,}&quot; 最少是1次所以取到结果为 &quot;a&quot;） 捕获分组：（暂时看不懂） (exp) -- 匹配exp,并捕获文本到自动命名的组里 (?&lt;name&gt;exp) -- 匹配exp,并捕获文本到名称为name的组里 (?:exp) -- 匹配exp,不捕获匹配的文本，也不给此分组分配组号以下为零宽断言 (?=exp) -- 匹配exp前面的位置（如 &quot;How are you doing&quot; 正则&quot;(?&lt;txt&gt;.+(?=ing))&quot; 这里取ing前所有的字符，并定义了一个捕获分组名字为 &quot;txt&quot; 而&quot;txt&quot;这个组里的值为&quot;How are you do&quot;;） (?&lt;=exp) -- 匹配exp后面的位置（如 &quot;How are you doing&quot; 正则&quot;(?&lt;txt&gt;(?&lt;=How).+)&quot; 这里取&quot;How&quot;之后所有的字符，并定义了一个捕获分组名字为 &quot;txt&quot; 而&quot;txt&quot;这个组里的值为&quot; are you doing&quot;;） (?!exp) -- 匹配后面跟的不是exp的位置（如 &quot;123abc&quot; 正则 &quot;\d{3}(?!\d)&quot;匹配3位数字后非数字的结果） (?&lt;!exp) -- 匹配前面不是exp的位置（如 &quot;abc123 &quot; 正则 &quot;(?&lt;![0-9])123&quot; 匹配&quot;123&quot;前面是非数字的结果也可写成&quot;(?!&lt;\d)123&quot;） 说明：本章未完全将正则字符列出! 正则表达式全集 参考资源 参考1 参考2 参考3 参考4]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>regexpal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uml用例图]]></title>
    <url>%2F2017%2F11%2F22%2Fuml%E7%94%A8%E4%BE%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[希望通过此加深对uml用例图的理解！ 用例图(Use Case Diagram) 定义： 用例图是指由参与者、用例以及它们之间的关系构成的用于描述系统功能的静态视图。用例图是被称为参与者的外部用户所能观察到的系统功能的模型图，呈现了一些参与者和一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行建模。 深入理解： 用例图是从用户角度描述系统功能，根据用户提出的需求描述系统的行为及各种功能之间的关系，通过用例图可以知道一个系统能够做什么，它要实现什么功能。用例图用于开发人员与用户之间的交流，以便开发人员很好的理解用户需求。 用例图的基本组成元素 参与者：参与者是与系统进行交互的用户或外部系统，是用例的启动者，在用例图中用小人表示。 用例：一系列可完成系统功能的动作，如机房收费系统中的“注册”、“充值”、“退卡”等，也可以理解为外部可见的系统功能，对系统提供的服务进行描述，用椭圆表示。 关系：描述参与者与用例之间的联系，用不同的连线表示。 UML用例图关系 关联(Association) 表示参与者与用例之间的通信，任何一方都可发送或接受消息。 包含(include) 使用包含（Inclusion）用例来封装一组跨越多个用例的相似动作（行为片断），以便多个基（Base）用例复用。基用例控制与包含用例的 关系，以及被包含用例的事件流是否会插入到基用例的事件流中。基用例可以依赖包含用例执行的结果，但是双方都不能访问对方的属性 扩展(extend) 将基用例中一段相对独立并且可选的动作，用扩展（Extension）用例加以封装，再让它从基用例中声明的扩展点（Extension Point）上进行扩展，从而使基用例行为更简练和目标更集中。扩展用例为基用例添加新的行为。扩展用例可以访问基用例的属性，因此它能根据基用例中扩展点的当前状态来判断是否执行自己。但是扩展用例对基用例不可见。 泛化(generalization) 子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。在实际应用中很少使用泛化关系，子用例中的特殊行为都可以作为父用例中的备选流存在。 关系图 注释(Comment)【不多说有图有真相！】 uml用例图新加关系 关联、泛化、包含、扩展4种关系，是UML定义的标准关系。 VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示 表示源用例依赖于目标用例 说明：此外vs2010中还引入了“项目(Artifact)”的元素 参考1 参考2 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>uml</tag>
        <tag>uml用例图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uml类图关系]]></title>
    <url>%2F2017%2F11%2F22%2Fuml%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[今天在上机课上，在制作uml类图中总感觉对uml类图中的关系不是太清楚，希望通过这一篇文章可以有一个深入的了解和学习！ 1.基本概念 类图（Class Diagram）: 类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。 类图的3个基本组件：类名、属性、方法。 2.UML类图关系 泛化（Generalization）： 表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 （Realization）: 在类图中就是接口和实现的关系,在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口 依赖(Dependency): 代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系,在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。 关联(Association): 在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 聚合(Aggregation): 表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。 组合(Composition): 表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。 多重性(Multiplicity) : 通常在关联、聚合、组合中使用。就是代表有多少个关联对象存在。使用数字..星号（数字）表示。 实现（Realization）: 是一种类与接口的关系, 表示类是接口所有特征和行为的实现,带三角箭头的虚线，箭头指向接口 UML类间关系的种类图 参考1 参考2]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>uml</tag>
        <tag>uml类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F11%2F20%2Fgit%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次 !@#!@#%!@# 什么的，你懂的哈 就是贼厉害！ Git的诞生同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许上千个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统。 安装Git(只介绍winn7系统) git下载官网 一路next安装即可 安装完成，在开始菜单里找到“Git”-&gt;“Git Bash”，出现类似命令行窗口的东西，即Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： git config –global user.name “Your Name”（Your Name是你github上的用户名，如：aqqje） git config –global user.email “email@example.com“ 创建版本库说明： 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： mkdir learngit -- 新建一个名叫learngit的文件夹 cd learngit -- 进入learngit文件夹 pwd -- 显示当前目录 初始化仓库 git init -- 初始化learngi文件夹为仓库 初始化仓库后会出现一个 .git 目录(默认隐藏)，使用ls -ah命令就可以看见。 git指令说明: 在讲解git指令之前，我们必须先了解git的分区： 工作区（working directory） 暂缓区（stage index） 历史记录区（history） 三个区域关系：工作区是我们能看到的区域，我们在工作区修改增加代码；完成编辑后，我们用git add 将工作区文件添加到暂存区；然后利用git commit 提交文件到我们自己的分支。 增删改查:git add &lt;文件名&gt; -- 工作区文件添加到暂存区 git add . -- 工作区所有修改动态添加到暂存区 git commit -m &quot;提交说明&quot; -- 提交git add后的文件到我们自己的分支 git status -- 掌握仓库当前的状态(*红色*代表未add未commit,*绿色*代表未commit) git diff &lt;文件名&gt; -- 能查看该文件具体修改了什么内容 git checkout --&lt;文件名&gt; -- 使该文件在工作区的修改全部撤销(这有两种情况:1.该文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 2.该文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态) git reset HEAD &lt;文件名&gt; -- 可以把暂存区的修改撤销掉（unstage） git rm &lt;文件名&gt; 版本:git log -- 显示从最近到最远的提交日志 git log --pretty=oneline -- 显示从最近到最远*简化*的提交日志 git reset --hard HEAD^ -- 显示当前版本 cat &lt;文件名&gt; -- 显示当前文件的内容 git reset --hard &lt;commit id&gt; -- 退回commit id 时的版本 git reflog -- 记录你的每一次reset和commit的命令 git diff HEAD -- &lt;文件名&gt; -- 查看该文件工作区和版本库里面最新版本的区别 -- 从版本库中删除该文件 远程仓库:git remote add origin &lt;远程仓库地址&gt; -- 添加一个仓库地址的别名,即origin git remote -v -- 可以查看对应的*别名*和*远程仓库地址* git push -u origin master -- 把本地仓库push到远程仓库上 git pull origin master -- 把远程仓库pull到本地仓库 git clone &lt;远程仓库地址&gt; -- 把对应的远程仓库地址的内容clone到本地 分支:git checkout dev -- 创建dev分支 git checkout -b dev -- 创建dev分支并切换到dev分支上 git branch -- 查看所有分支(绿色代表当前分支) git checkout &lt;分支名&gt; -- 切换到对应的分支上 git merge &lt;分支名&gt; -- 把对应分支合并到当前分支上 git brand -d &lt;分支名&gt; -- 删除对应的分支 分支图:git log --graph -- 查看分支合并图 分支管理：说明： Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 git merge --no-ff -m &quot;说明修改&quot; &lt;分支名&gt; -- --no-ff参数，表示禁用Fast forward -m &quot;说明修改&quot; 代表一个commit bug分支：情境：当你接到在master主分支上有修复bug的任务代号:bug_001,想创建一个分支bug_001来修复它，但当前正在dev上进行的工作还没有提交： git stash -- 把当前工作现场“储藏”起来，等以后bug_001修复好后继续工作 git checkout master -- 回到master主分支 git ckeckout -b bug_001 -- 创建bug_001分支并切换到bug_001分支上 git add . -- 添加修复 git commit -m &quot;修复bug_001&quot; -- 提交bug_001修复 git checkout master -- 回到master主分支 git merge --no-ff -m &quot;merged bug_001&quot; bug_001 -- 合并bug_001分支到master主分支上并commit&quot;merged bug_001&quot;日志 git checkout dev -- 切换到dev分支上 git stash list -- 查看“储藏”起来工作现场 【*git stash apply -- 修复储藏”起来工作现场（但是恢复后，stash内容并不删除，你需要用git stash drop来删除） git stash pop -- 修复储藏”起来工作现场（恢复的同时把stash内容也删了）*】 git stash apply stash@{0} -- 恢复指定的stash feature分支：情境：软件开发过程中，添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。现在，有一个新的功能需要实现，代号为newfunction。 git checkout -b feature_newfc -- 创建feature_newfc分支并切换到feature_newfc准备开发 git add newfunction.py -- 开发完成并添加到暂存区 git commit -m &quot;add newfunction&quot; -- 提交到feature_newfc上 git chekout master -- 切换到master主分支上，准备合并分支 git merge feature_newfc -- 合并feature_newfc分支到master主分支 新情境： 刚刚开发的新功能，因经费不足，新功能必须取消！（没有开发完成！还没有合并到master主分支）如何就地销毁呢？ git bracnch -d feature_newfc -- 准备销毁feature_newfc分支，但因为还没有合并报错，就地销毁失败！ git bracnch -d feature_newfc -- 强行销毁，销毁成功！ 标签管理说明： Git中打标签非常简单，首先，切换到需要打标签的分支上， 创建的标签都只存储在本地，不会自动推送到远程，所以，打错的标签可以在本地安全删除。 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除。删除命令也是push git branch -- 查看所有分支（带绿色*的是当前分支） git checkout master -- 切换到master主分支上 git tag &lt;新建标签名&gt; -- 新建一个标签 git tag -- 查看所有标签 git log --pretty=oneline --abbrev-commit -- 查询历史提交的commit id git tag &lt;tag commit id&gt; -- 回到指定的tag git show &lt;tagname&gt; -- 查看标签信息 git tag -a v0.1 -m &quot;version 0.1 released&quot; -- 创建带有说明的标签，用-a指定标签名，-m指定说明文字 git tag -s v0.2 -m &quot;signed version 0.2 released&quot; -- 通过-s用私钥签名一个标签（签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错！如果报错，请参考GnuPG帮助文档配置Key！） git tag -d &lt;tagname&gt; -- 删除标签 git push origin &lt;tagname&gt; -- 推送某个标签到远程 git push origin --tags -- 一次性推送全部尚未推送到远程的本地标签 【*git tag -d &lt;tagname&gt; -- 标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除 git push origin :refs/tags/&lt;tagname&gt; --然后，从远程删除。也是push*】 自定义Gitgit config --global color.ui true -- 让Git显示颜色，会让命令输出看起来更醒目(一般默认不用自己再配置！) 其它配置指令请百度，这里不一一指出！ 别名git config --global alias.co checkout -- 等同 git co dev git config --global alias.ci commit -- 等同 git ci -m &quot;提交说明&quot; git config --global alias.br branch -- 等同 git br ... 注意：所有的尖括号皆可以省略！ 参考1 参考2 参考3 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github博客绑定域名]]></title>
    <url>%2F2017%2F11%2F20%2Fgithub%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在github上成功搭建了一个属于自己的小空间后，是不是感到十分的开心，就差没跳舞了！- -，可是感觉还是不够完美！还得有一个自己的域名才好！SEE! 绑定域名… 1.添加CNAME文件向 yourname.github.io/source 目录添加一个CNAME(一定要大写且文件名没有后缀名)文件文件中增加一个域名 如: aqqje.com 2.向你的 DNS 配置中添加 3 条记录 @ A 192.30.252.153 @ A 192.30.252.154 www CNAME username.github.io用你自己的 Github 用户名替换 username我是在万网注册的域名，解析是阿里云解析配置 DNS 推荐使用 DNSPOD 的服务，使用国外的 DNS 解析服务可能有被墙的风险至于如何使用 DNSPOD 解析域名参考 等待你的 DNS 配置生效对DNS的配置不是立即生效的，过10分钟再去访问你的域名看看有没有配置成功 说明：此篇文章解析工具是阿里云，其实工具是否适用概不负责。 参考作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建博客]]></title>
    <url>%2F2017%2F11%2F19%2Fgithub-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[通过几天的努力终于把hexo+github形式的博客搭建好了！正文：hexo搭建博客还是很容易的！更换主题也很简单！ 配置环境 安装Node(必须)一路安装即可作用：用于生成静态页面。Node.js官网https://nodejs.org/en/ 安装Git(必须)大部分按默认安装，一路安装即可作用：把本地的hexo内容提交到github上去(博客备份地址不是你的网站地址) 验证软件正确安装 git –version node -v npm -v 申请GitHub 点击-&gt;GitHub进入官网注册帐号 分别输入用户名、邮箱、密码，然后点击注册 “New repository”新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 安装Hexo 因为有“墙”，安装hexo为了避免出现类似情况，使用淘宝NPM镜像,输入以下命令等待安装完成 $ npm install -g cnpm –registry=https://registry.npm.taobao.org 使用淘宝NPM安装Hexo cnpm install -g hexo-cli 与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成 继续输入以下命令安装 cnpm install hexo –save 验证hexo是否安装成功 hexo -v 本地运行hexo 新建一个文件夹做为你的博客的文件 进入你的博客文件，使用 Git Bash 进行初始化hexo hexo init 安装生成器 cnpm install 运行hexo,以后要在本地运行博客只要输入该命令即可 打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了 停止运行(按住Ctrl+C键即可停止) 管理博客 配置信息打开您博客根目录下的_config.yml文件，进行配置 {％blockquote％}博客名称title: 我的博客副标题subtitle: 一天进步一点简介description: 记录生活点滴博客作者author: John Doe博客语言language: zh-CN时区timezone:博客地址,与申请的GitHub一致url: http://elfwalk.github.ioroot: /博客链接格式permalink: :year/:month/:day/:title/permalink_defaults:source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:default_category: uncategorizedcategory_map:tag_map:日期格式date_format: YYYY-MM-DDtime_format: HH:mm:ss分页，每页文章数量per_page: 10pagination_dir: page博客主题theme: landscape发布设置deploy: type: git elfwalk改为你的github用户名 repository: https://github.com/elfwalk/elfwalk.github.io.git branch: master{％endblockquote％} 写一篇文章输入创建文章命令，生成一个md文件(/blog/source/_posts/) hexo new “hello” 用编辑器打开hello.md文件,编写完后保存{％blockquote％}title: hellodate: 2015-07-01 22:37:23categories: 日志 二级目录tags: hello 摘要:正文:{％endblockquote％} 发布博客 设置git身份信息 git config –global user.name “你的用户名” git config –global user.email “你的邮箱” 安装hexo git插件 cnpm install hexo-deployer-git –save 发布更新博客 hexo d -g 发布成功后，访问yourname.github.io看下成果 参考：http://hifor.net/2015/07/01/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-hexo-github作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再别康桥]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%86%8D%E5%88%AB%E5%BA%B7%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[正文： 再别康桥作者: 徐志摩 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 1928.11.6 中国上海 参考资源 徐志摩_百度百科徐志摩诗集]]></content>
      <categories>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2017%2F11%2F16%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 1.斜体和粗体代码： 1.*斜体* 或 _斜体_ 2.**粗体** 3.***加粗斜体*** 4.~~删除线~~ 显示效果: 这是一段体 或 这是一段体 这是一段粗体 这是一段加粗斜体 这是一段删除 2.分组标题第一种写法：1.这是一个一级标题 2.============================ 3. 4.这是一个二级标题 5.-------------------------------------------------- 第二种写法：1.# 一级标题 2.## 二级标题 3.### 三级标题 4.#### 四级标题 5.##### 五级标题 6.###### 六级标题 3.超链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1. 行内式语法说明： []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。链接文字’这样的形式。链接地址与链接标题前有一个空格。 1.梦不若星辰[aqqje](https://github.com/aqqje) 2.梦不若星辰[aqqje](https://github.com/aqqje &quot;aqqje&quot;) 显示效果:梦不若星辰aqqje 梦不若星辰aqqje 3.2. 参考式语法说明：参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行 1.[小米][1] [华为][2] [vivo][3] [oppo][4] 3.[1]:https://www.mi.com 4.[2]:https://www.huawei.com 5.[3]:https://www.vivo.com.cn/ 6.[4]:https://www.oppo.com/ 显示效果:小米 华为 vivo oppo 3.3. 自动链接语法说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 1.&lt;https:www.baibu.com/&gt; 2.&lt;1042136232@qq.com&gt; 显示效果:https://www.baibu.com/ &#x31;&#x30;&#52;&#x32;&#49;&#51;&#54;&#50;&#51;&#x32;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109; 4. 锚点5. 列表语法说明：使用 *，+，- 表示无序列表。 1. - 无序列表项 一 2. - 无序列表项 二 3. - 无序列表项 三 显示效果: 无序列表项 一 无序列表项 二 无序列表项 三 5.2. 有序列表语法说明：有序列表则使用数字接着一个英文句点。 1. 1. 有序列表项 一 2. 2. 有序列表项 二 3. 3. 有序列表项 三 显示效果: 有序列表项 一 有序列表项 二 有序列表项 三 5.3. 定义型列表语法说明：定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab) 1.梦不若星辰1 2.： 相见亦无事，不遇长相思（左侧有一个可见的冒号和四个不可见的空格） 3.代码2 4.: 梦不若星辰2（左侧有一个可见的冒号和四个不可见的空格） 5 梦不若星辰3（左侧有八个不可见的空格） 显示效果:梦不若星辰1 ： 相见亦无事，不遇长相思（左侧有一个可见的冒号和四个不可见的空格） 代码2 : 梦不若星辰2（左侧有一个可见的冒号和四个不可见的空格） 梦不若星辰3（左侧有八个不可见的空格） 5.3. 列表缩进语法说明：列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符 1.* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 2.* 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 3.* 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 3.* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 显示效果: 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 5.4. 包含段落的列表语法说明：列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符 1.* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 2. 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 3. 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 3. 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 显示效果: 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 5.5. 包含引用的列表语法说明：如果要在列表项目内放进引用，那 &gt; 就需要缩进 1.* 阅读的方法 2. 3. &gt;打开书本 4. &gt;打开电灯 显示效果: 阅读的方法 打开书本 打开电灯 5.6. 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符。 一列表项包含一个列表区块 &lt;1.代码写在这&gt; 5.7. 一个特殊情况在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法： 1.2017.Hello world! 显示效果: Hello world! 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠 1.2017.Hello world! 显示效果:2017.Hello world! 6. 引用语法说明：引用需要在被引用的文本前加上&gt;符号 &gt; 这是一个有两段文字的引用, &gt; 无意义的占行文字1. &gt; 无意义的占行文字2. &gt; &gt; 无意义的占行文字3. &gt; 无意义的占行文字4. 显示效果: 这是一个有两段文字的引用.无意义的占行文字1.无意义的占行文字2. 无意义的占行文字3.无意义的占行文字4 Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; 这是一个有两段文字的引用. 无意义的占行文字1. 无意义的占行文字2. 无意义的占行文字3. 无意义的占行文字4 6.1. 引用的多层嵌套语法说明：区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; 1.&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白 2.&gt; 3.&gt;&gt; 自己看教程！ - 愤青 4.&gt; 5.&gt; 教程在哪？ - 小白 显示效果: 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 6.2. 引用其它要素语法说明：引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。 1.&gt; 1. 这是第一行列表项。 2.&gt; 2. 这是第二行列表项。 3.&gt; 4.&gt; 给出一些例子代码： 5.&gt; 6.&gt; return shell_exec(&quot;echo $input | 7.7.$markdown_script&quot;); 显示效果: 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 7. 插入图像图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 7.1. 行内式语法说明： 1.![神界传说](https://github.com/aqqje/images/raw/master/markdown_test/0.jpeg &quot;神界传说&quot;) 显示效果: 7.2. 参考式语法说明： 1.![神界传说][神界传说] 2. 3.[神界传说]:https://github.com/aqqje/images/raw/master/markdown_test/0.jpeg &quot;神界传说&quot; 显示效果: 8. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 9. 注脚语法说明：在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。 使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果:使用 Markdown^1 可以效率的书写文档, 直接转换成 HTML[^2],你可以使用 Leanote^3 编辑器进行书写。 [^2]:HyperText Markup Language 超文本标记语言 10. LaTeX 公式10.1. $ 表示行内公式1.质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 显示效果:质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 10.2 $$ 表示整行公式1.$$\sum_{i=1}^n a_i=0$$ 2.$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ 3.$$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$ 显示效果:$$\sum_{i=1}^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法 11. 流程图1.flow 2.st=&gt;start: Start:&gt;https://www.zybuluo.com 3.io=&gt;inputoutput: verification 4.op=&gt;operation: Your Operation 5.cond=&gt;condition: Yes or No? 6.sub=&gt;subroutine: Your Subroutine 7.e=&gt;end 8. 9.st-&gt;io-&gt;op-&gt;cond 10.cond(yes)-&gt;e 11.cond(no)-&gt;sub-&gt;io 显示效果：flowst=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考 12 .表格语法说明：1.不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。2.列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。3.第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。 简单方式写表格： 1学号|姓名|分数 2.-|-|- 3.小明|男|75 4.小红|女|79 5.小陆|男|92 显示效果： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 原生方式写表格： 1.|学号|姓名|分数| 2.|-|-|-| 3.|小明|男|75| 4.|小红|女|79| 5.|小陆|男|92| 显示效果： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 为表格第二列指定方向： 1.产品|价格 2.-|-: 3.Leanote 高级账号|60元/年 4.Leanote 超级账号|120元/年 显示效果： 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 13. 分隔线语法说明：在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线。 1.* * * 2. 3.*** 4. 5.***** 6. 7.- - - 8. 9.--------------------------------------- 显示效果： 14. 代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用””符号（一般在ESC键下方）包裹代码 语法说明：&lt;br/&gt; 1.插入行内代码，即插入一个单词或者一句代码的情况，使用code这样的形式插入。 2.插入多行代码，可以使用缩进或者“ code “` 1.C语言里的函数 `scanf()` 怎么使用？ 显示效果：C语言里的函数scanf()怎么使用？ 8.2. 缩进式多行代码缩进 4 个空格或是 1 个制表符 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world\n&quot;); } 显示效果： #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world\n&quot;); } 8.3. 用六个`包裹多行代码12345678 #include &lt;stdio.h&gt; int main(void) &#123; printf(&quot;Hello world\n&quot;); &#125; 、、、###### 显示效果： #include &lt;stdio.h&gt;int main(void){ printf(“Hello world\n”);}` 8.4. HTML 原始码在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理 &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 显示效果： 值班人员 星期一 星期二 星期三 李强 张明 王平 参考1 参考2 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2017%2F11%2F16%2Fhello%2F</url>
    <content type="text"><![CDATA[摘要:正文:欢迎来到我的个人博客！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>

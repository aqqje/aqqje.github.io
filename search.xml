<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql-error:1366-incorrect string value:xxxx]]></title>
    <url>%2F2019%2F04%2F03%2Fmysql-error-1366-incorrect-string-value-xxxx%2F</url>
    <content type="text"><![CDATA[问题:mysql-error:1366-incorrect string value:xxxx?1.解决: ALTER TABLE user CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; 2.拓展1234567891011121314151617181920212223242526-- 检查当前表中字段的字符集设置show full fields from user;-- 检查当前表中字段的字符集设置show create table table;-- 修改数据库的默认字符集ALTER DATABASE user DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;-- 修改表的默认字符集ALTER TABLE user DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;-- 修改表和所有字符列（CHAR,VARCHAR,TEXT）默认的字符集ALTER TABLE user CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;-- 修改字段的字符集ALTER TABLE user CHANGE title title VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci;-- 查看数据库编码SHOW CREATE DATABASE dome;-- 查看表编码SHOW CREATE TABLE user;-- 查看字段编码SHOW FULL COLUMNS FROM user; 参考:在一个字段输入中文是出现错误1366-incorrect string value:\xE7\x8E\x8B for column fi]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP笔记]]></title>
    <url>%2F2019%2F04%2F03%2Fjsp%2F</url>
    <content type="text"><![CDATA[JSP笔记1.概念:java server pages: java服务器端页面 可以理解为:一个特殊的页面,其中即可以指定定义html标签,又可以定义java代码 用于简化书写!!! 2.原理:JSP本质上就是一个Servlet 3.JSP的脚本: JSP定义java代码的方式&lt;% 代码 %&gt;:定义的java代码,在service方法中,service方法可以定义什么,该脚本中就可以定义什么. &lt;%! 代码 %&gt;定义的java代码,在jsp转换后的java类的成员位置 &lt;%= 代码 %&gt;定义的java代码,会出到页面,输出语句中可以定义什么,该脚本就可以定义什么. 4.JSP的内置对象在jsp页面中不需要获取和创建,可以直接使用的对象 jsp一共有9个内置对象 request response out:字符输出流对象可以将数据输出到页面上.和response.getWriter()类似 response.getWriter().write()和out.write()的区别 在tomcat服务器真正给客户端做出之间,会先找response缓冲区数据,再找out缓冲区数据 response.getWirter()数据输出永远在out.write()之间 5.指令12345678910111213141516171819202122232425A.作用：用于配置JSP页面，导入资源文件B.格式： &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;C.分类： a. page:配置JSP页面 i. contentType：等同于response.setContentType() 1. 设置响应体的mime类型以及字符集 2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） ii. import：导包 iii. errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 iv. isErrorPage：标识当前也是是否是错误页面。 1. true：是，可以使用内置对象exception 2. false：否。默认值。不可以使用内置对象exception b. include:页面包含的。导入页面的资源文件 &lt;%@include file=&quot;top.jsp&quot;%&gt; c. taglib：导入资源 &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; prefix：前缀，自定义的 6.注释:12345678910111213141516171819A. html注释： &lt;!-- --&gt;:只能注释html代码片段B. jsp注释：推荐使用 &lt;%-- --%&gt;：可以注释所有C. 内置对象 在jsp页面中不需要创建，直接使用的对象 一共有9个： 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[el&jstl笔记]]></title>
    <url>%2F2019%2F04%2F03%2FEL%26JSTL%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[el&amp;jstl笔记1. EL表达式概念：Expression Language 表达式语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748A. 作用：替换和简化jsp页面中java代码的编写B. 语法：$&#123;表达式&#125;C. 注意： jsp默认支持el表达式的。如果要忽略el表达式 1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式 2. $&#123;表达式&#125; ：忽略当前这个el表达式D. 使用： a. 运算： i. 算数运算符： + - * /(div) %(mod) ii. 比较运算符： &gt; &lt; &gt;= &lt;= == != iii. 逻辑运算符： &amp;&amp;(and) ||(or) !(not) iv. 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 $&#123;empty list&#125;:判断字符串、集合、数组对象是否为null或者长度为0 $&#123;not empty str&#125;:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 2. 获取值 a. el表达式只能从域对象中获取值 b. 语法： 1. $&#123;域名称.键名&#125;：从指定域中获取指定键的值 域名称： 1. pageScope --&gt; pageContext 2. requestScope --&gt; request 3. sessionScope --&gt; session 4. applicationScope --&gt; application（ServletContext） 举例：在request域中存储了name=张三 获取：$&#123;requestScope.name&#125; 2. $&#123;键名&#125;：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 3. 获取对象、List集合、Map集合的值 1. 对象：$&#123;域名称.键名.属性名&#125; * 本质上会去调用对象的getter方法 2. List集合：$&#123;域名称.键名[索引]&#125; 3. Map集合： * $&#123;域名称.键名.key名称&#125; * $&#123;域名称.键名[&quot;key名称&quot;]&#125;E. 隐式对象： a.el表达式中有11个隐式对象 b.pageContext： 获取jsp其他八个内置对象 $&#123;pageContext.request.contextPath&#125;：动态获取虚拟目录 JSTL概念：JavaServer Pages Tag Library JSP标准标签库;是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445A. 作用：用于简化和替换jsp页面上的java代码 B. 使用步骤： 1. 导入jstl相关jar包 2. 引入标签库：taglib指令： &lt;%@ taglib %&gt; 3. 使用标签C. 常用的JSTL标签 a. if:相当于java代码的if语句 1. 属性： test 必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 2. 注意： c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 b. choose:相当于java代码的switch语句 1. 使用choose标签声明 相当于switch声明 2. 使用when标签做判断 相当于case 3. 使用otherwise标签做其他情况的声明 相当于default c. foreach:相当于java代码的for语句 1. 完成重复的操作 for(int i = 0; i &lt; 10; i ++)&#123; ... &#125; 属性： begin：开始值 end：结束值 var：临时变量 step：步长 varStatus:循环状态对象 index:容器中元素的索引，从0开始 count:循环次数，从1开始 2. 遍历容器 List&lt;User&gt; list; for(User user : list)&#123; &#125; 属性： items:容器对象 var:容器中元素的临时变量 varStatus:循环状态对象 index:容器中元素的索引，从0开始 count:循环次数，从1开始 案例：用户信息列表展示123456789101112131415161718192021222324A. 需求：用户信息的增删改查操作B. 设计： 1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat 2. 数据库设计： create database dome; -- 创建数据库 use dome; -- 使用数据库 create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50) );C. 开发： 1. 环境搭建 1. 创建数据库环境 2. 创建项目，导入需要的jar包 2. 编码D. 测试E. 部署运维 el隐式对象 隐含对象 类型 说明 PageContext javax.servlet.ServletContext 表示此JSP的PageContext PageScope java.util.Map 取得Page范围的属性名称所对应的值 RequestScope java.util.Map 取得Request范围的属性名称所对应的值 sessionScope java.util.Map 取得Session范围的属性名称所对应的值 applicationScope java.util.Map 取得Application范围的属性名称所对应的值 param java.util.Map 如同ServletRequest.getParameter(String name)。回传String类型的值 paramValues java.util.Map 如同ServletRequest.getParameterValues(String name)。回传String[]类型的值 header java.util.Map 如同ServletRequest.getHeader(String name)。回传String类型的值 headerValues java.util.Map 如同ServletRequest.getHeaders(String name)。回传String[]类型的值 cookie java.util.Map 如同HttpServletRequest.getCookies() initParam java.util.Map 如同ServletContext.getInitParameter(String name)。回传String类型的值]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie&&Session笔记]]></title>
    <url>%2F2019%2F04%2F03%2Fcookie%26session%2F</url>
    <content type="text"><![CDATA[Cookie&amp;&amp;Session笔记1.会话技术123456A.会话: 一次会话中包含多次请求和响应. a.一次会话:浏览器第一次给服务器资源发送请求,会话建立,直到有一方断开为止B.功能: 在一次会话的范围内的多次请求间,共享数据C.方式: a.客户端会话技术 cookie b.服务器端会话技术: session 2.cookie12345678910111213141516171819202122232425262728293031323334353637383940414243A.概念:客户端会话技术,将数据保存到客户端B.快速入门: 使用步骤: a.创建cookie对象,绑定数据 new Cookie(String name, String value) b.发送cookie response.addCookie(Cookie cookie) c.获取Cookie,拿到数据 Cookie[] request.getCookies() C.实现原理 基于响应头set-cookie和请求头cookie实现 D.cookie的细节 a.一次可不可以发送多个cookie? 可以:可以创建多个Cookie对象,使用response调用多次addCookie方法发送cookie即可. b.cookie在浏览器中保存多长时间? 1.默认情况下,当浏览器关闭后,cookie数据被销毁 2.持久化存储: setMaxAge(int seconds) i.正数:将Cookie数据写到硬盘的文件中,持久化存储,cookie存活时间 ii.负数:默认值 iii.零:删除cookie信息 c.cookie能不能存中文? 在tomcat8之前cookie中不能直接存储中文数据. 需要将中文数据转码, 一般采用URL编码($E3) 在tomcat8之后,cookie支持中文数据.特殊字符还是不支持,建议使用URL编码存储,URL解码 d.cookie获取范围多大? 1.假设在一个tomcat服务器中,部署了多个web项目,那么在这些web项目中cookie能不能共享? 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围.默认情况下,设置当前的虚拟目录 如果要共享,即可以将path设置为&quot;/&quot; 2.不同的tomcat服务器间cookie共享问题? setDomain(String path):如果设置一级域名,那么多个服务器之间cookie可以共享 setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中的cookie可以共享 E.cookie的特点和作用 a.cookie存储数据在客户端浏览器 b.浏览器对于单个cookie的大小有限制(4kb)以及对同一个域名下的总cookie数量也有限制(20个) 作用: i.cookie一般用于存储少量的不太敏感的数据 ii.在不登录的情况下,完成服务器对客户端的身份识别 案例:记住上一次访问时间1234567891011A.需求: a.访问一个Servlet,如果是第一次访问,则提示:您好,欢迎您首次访问 b.如果不是第一次访问,则提示:欢迎回来,您上次访问时间为:显示时间字符串B.分析: a.可以采用cookie来完成 b.在服务器上的Servlet判断是否有一个名为lastTime的cookie i.有: 不是第一次访问 1.响应数据:欢迎回来,您上次访问时间为:2019年04月3日 13:04:55 ii.没有: 是第一次访问 1.响应数据:您好,欢迎您首次访问 2.写回cookie:lastTime=2019年04月3日 13:04:55 3.session笔记1234567891011121314151617181920212223242526272829303132333435363738394041424344A.概念:服务器端会话技术,在一次会话的多冷请求间共享数据,将数据保存在服务器端的对象中,HttpsessionB.获取HttpSession对象: Httpsession session = request.getSession(); C.使用HttpSession对象: Object getAttribute(String name) void setAttribute(String name,Object value) void removeAttribute(String name) D.原理 session的实现是依赖于cookie的 E.细节: a.当客户端关闭后,服务器不关闭,两次获取session是否为同一个? 默认情况下,不是 如果需要相同,则可以创建cookie,键为SESSIONID,设置最大存活时间,让cookie持久化保存. Cookie c = new Cookie(&quot;JSESSION&quot;, session.getId()); c.setMaxAge(60*60); response.addCookie(c); b.客户端不关闭,服务器关闭后,两次获取的session是同一个吗? 1.不是同一个,但是要确保数据不丢失 i.session的纯化 在服务器正常关闭之前,将session对系列化到硬盘上 ii.session的活化: 在服务器启动后,将session文件转化这内存中的session对象即可. 3.session什么时候被销毁? a.服务器关闭 b.session对象调用invalidate(). c.session默认失效时间 30分钟 tomcat配置 &lt;session config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session config&gt; F.session的特点 a.session用于存储一次会话的多冷请求的数据,存在服务器端 b.sessions可以存储任意类型,任意大小的数据 c.session与cookie的区别: 1.session存储数据在服务器端,cookie在客户端 2.session没有数据大小限制,cookie有 3.session数据安全,cookie相对于不安全 案例:验证码123456A.需求 a.访问带验证码的登录login.jsp b.用户输入用户名,密码以及验证码 如果用户和密码输入有误,跳转登录页面,提示:用户名或密码错误 如果验证码输入有有误,跳转登录页面提示:验证码错误 如果全部输入正确,则跳转到主页success.jsp显示:用户名,欢迎您]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC笔记]]></title>
    <url>%2F2019%2F04%2F03%2Fmvc%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MVC笔记1. jsp演变历史12345A. 早期只有servlet，只能使用response输出标签数据，非常麻烦B. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 C. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 2. MVC：12345678910111213141516A. M：Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象B. V：View，视图。JSP 展示数据C. C：Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示D. 优缺点： a. 优点： 1. 耦合性低，方便维护，可以利于分工协作 2. 重用性高 b. 缺点： 1. 使得项目架构变得复杂，对开发人员要求高 3. 三层架构：软件设计架构12345A. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互B. 业务逻辑层：处理业务逻辑的。C. 数据访问层：操作数据存储文件。]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP：Request 笔记]]></title>
    <url>%2F2019%2F03%2F14%2FHTTP-Request%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.HTTP：Request1.1 概念 Hyper Text Transfer Protocol 超文本传输协议 1.2 传输协议： 定义了，客户端和服务器端通信时，发送数据的格式 特点： 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 1.3 历史版本：1231.0：每一次请求响应都会建立新的连接1.1：复用连接 1.4 请求消息数据格式123456789101112131415161718192021222324252627282930313233343536373839404142434445A. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 请求方式： HTTP协议有7中请求方式，常用的有2种 GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全B. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html 告诉服务器，我(当前请求)从哪里来？ 作用： 1. 防盗链： 2. 统计工作：C. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。D. 请求体(正文)： 封装POST请求消息的请求参数的E 字符串格式： POST /login.html HTTP/1.1 Host: localhost Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: en,zh-CN;q=0.9,zh;q=0.8 Connection: keep-alive Cookie: 略 Host: localhost:8080 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36 name = zhangshan F 响应消息数据格式 2. Request：2.1. request对象和response对象的原理12A. request和response对象是由服务器创建的。我们来使用它们B. request对象是来获取请求消息，response对象是来设置响应消息 2.2. request对象继承体系结构：12345ServletRequest -- 接口 | 继承HttpServletRequest -- 接口 | 实现org.apache.catalina.connector.RequestFacade 类(tomcat) 2.3. request功能：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475A. 获取请求消息数据 a. 获取请求行数据 * GET /aqqje/demo?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET String getMethod() 2. (*)获取虚拟目录：/dome String getContextPath() 3. 获取Servlet路径: /dome String getServletPath() 4. 获取get方式请求参数：name=zhangsan String getQueryString() 5. (*)获取请求URI：/aqqje/demo String getRequestURI(): /aqqje/dome StringBuffer getRequestURL() :http://localhost/aqqje/dome URL:统一资源定位符 ： http://localhost/aqqje/demo 中华人民共和国 URI：统一资源标识符 : /aqqje/demo 共和国 6. 获取协议及版本：HTTP/1.1 String getProtocol() 7. 获取客户机的IP地址： String getRemoteAddr() b. 获取请求头数据 方法： (*)String getHeader(String name):通过请求头的名称获取请求头的值 Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 c. 获取请求体数据: 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 1. 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 在文件上传知识点后讲解 2. 再从流对象中拿数据 B. 其他功能： a. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 中文乱码问题： get方式：tomcat 8 已经将get方式乱码问题解决了 post方式：会乱码 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); b. 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 c. 共享数据： 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 e. 获取ServletContext： ServletContext getServletContext() 4.用户登录(示例)123456789101112131415161718192021222324252627282930313233* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 Properties ps = new Properties(); InputStream resource = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); ps.load(resource); ds = DruidDataSourceFactory.createDataSource(ps); 3.使用JdbcTemplate技术封装JDBC return jdbcTemplate.queryForObject(&quot;select * from user where name = ? and password = ?&quot;, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getName(), loginUser.getPassword()); 4.使用commons下的BeanUtils工具类(需导入jar)封装成loginUser对象 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); User loginUser = new User(); try &#123; BeanUtils.populate(loginUser, parameterMap); System.out.println(loginUser); &#125; catch&#123; .... &#125; 5.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 UserDao dao = new UserDao(); User user = dao.login(loginUser); if(user != null)&#123; request.setAttribute(&quot;login&quot;, user); request.getRequestDispatcher(&quot;/user/loginSuccess&quot;).forward(request, response); &#125;else&#123; request.getRequestDispatcher(&quot;/user/loginError&quot;).forward(request, response); &#125;]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试题I 后端问答题1、说说 JDBC 的具体流程？ 答：1、注册数据库驱动。 ​ 2、建立数据连接。 ​ 3、创建一个Statement。 ​ 4、执行 SQL 语句。 ​ 5、处理结果集。 ​ 6、关闭数据库连接。 2、什么是事务？ 答：事务就是把多事件当做一件事来处理，是数据库操作的最小单元，是作为单个 逻辑工作单元执行的一系列操作：这些操作作为一个整体一起向系统，要么都执行，要么都不执行，事务是一组不可再的操作集合（工作逻辑单元）。 3、什么 MVC? 答：mvc 是一种架构模式，分离了表现与交互，核心部件： ​ 模型(model)：表示业务数据，提供数据给视图。 ​ 视图(view)：用户看到并与之交互的界面。 ​ 控制器(controller)：接受用户的输入并调用模型和视图去完成用户的需求 4、数据库的数据有那类型？ 答： 5、冒泡算法怎样实现的？ 答：将一列数组或集合的相邻元素进行比较并使其顺序或逆序排序，一共需要走 n-1 趟，每趟需要比较 n-1-i 次 6、什么是类方法，什么是实例方法，两者有什么区别？ 答: 类方法：使用 static 关键字修饰的静态方法。 ​ 实例方法：没有 static 关键字修饰，非静态方法 ​ 区别：1、静态方法在程序开始时生成内存，实例方法在程序运行中生成内存，所有静态方法可以直接调用。 ​ 2、实例方法要先生成实例，通过实例调用方法。静态方法可以直接调用。 ​ 3、类方法不用引用和调用实例方法的变量，而实例方法可以引用类方法的变量。 7、JDBC 中的 Statement 和 PreparedStatement 的区别？ 答：1、PrepareStatement 是预编译 sql , 性能要高于 Statement。 ​ 2、PrepareStatement 是可以防止 sql 注入 ,安全要高于 Statement。 ​ 3、PrepareStatement 支持？操作符 ,灵活性要高于 Statement。 8、为什么要有事务？ ​ 1、解决并发情况下保持数据一致性的问题 ​ 2、是数据库维护数据一致性的单位，在每个事务结束时，都能保持一致性。 9、数据库事务的四大特征？ ​ 1、原子性：事务的操作要么全部成功，要么全部回滚。 ​ 2、一致性：事务在执行之前与执行之后都必须处于一致状态。 ​ 3、隔离性：当多个用户并发访问数据库时，数据为每个用户开户事务，不能被其他事务操作据干扰，多个并发事务之间要相互隔离。 ​ 4、持久性：表示事务的提交对数据库的改变是永久性的，在遇到故障情况下也不会丢失提交事务的操作。 10、事务的隔离级别？ （1）Serializable（串行化）：可避免脏读、不可重复读、幻读的发生 （2）Repeatable read（可重复读）：可避免脏读、不可重复读的发生。 （3）Read committed（读已提交）：可避免脏读的发生 （4）Read uncommitted（读未提交）：最低级别，任何情况下都无法保证。 11、简单的概括数据库的三范式？ ​ 1、字段不可分，表示原子性，字段不可再分，否则就不是关系数据库; ​ 2、有主键，非主键字段依赖主键，表示唯一性，一个表只说明一个事物。 ​ 3、非主键字段不能相互依赖，说明每列都与主键有直接关系，不存在传递依赖。 12、在数据库中，什么是视图，以及视图的使用场景有哪些？ ​ 1、视图也是一种表，不过是虚拟的表，具有和物理表相同的功能，可以对视图进行 CRUD ，对视图的操作不会影响物理表。 ​ 2、视图主要把多表查询的结果联合起来，查询者只要从视图中获取数据即可以，不必考虑数据来源于不同物理表所带来的差异。 13、drop、delete与truncate分别在什么场景之下使用？ ​ 1、drop:删除一个表的所有包含其数据 ​ 2、delete:删除部分指定（使用 where）的数据，也可以删除所有数据（不使用 where）。(可以应用 table 与 view) ​ 3、truncate: 保留表而删除所有数据。（只用应用 table） ​ 注意：1、速度 drop&gt; truncate &gt; delete。 ​ 2、和事务有关、或者想触发 trigger ，还是用 delete。 14、java 有那些基本数据类型，String 是不是基本数据类型，他们有何区别？ ​ 答：六种数字类型 byte 8位， short 16 位， int 32 位，float 32位， long 64 位， double 64 位， 一种字符类型 char 8 位， 一种尔类型 boolean 8 位 String 本身就是一个对象而不是基本数据类型，String 的变量是对 String 类的引用 15、编码转换，怎样实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串？ ​ 答： String str = new String(“字符串”.getBytes(“GB2312”).”ISO-8859-1”); 16、使用StringBuffer类与String类进行字符串连接时有何区别？ ​ 答：String 类提供的数值不可改变，StringBuffer 提供的数值是可以改变的。 17、谈谈final, finally, finalize的区别。 ​ 答：final 用于声明 属性、方法、类，表示属性不可变，方法不可覆盖，类不可继承。 ​ finally 是异常处理语句结构的一部分，表示总是执行 ​ finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用对象的此方法。 18、String s = new String(“xyz”);创建了几个String Object? ​ 答：两个，一个是 String s,另一个是 “xyz” 19、是否可以继承**String类?* ​ 答：String 类是 final 类故不可以继承。 20、abstract class 和 interface 有什么区别 ​ 答：Interface 只能有成员常量，只能是方法的声明。 ​ abstract 只能有成员变量，可以声明普通方法和抽象方法。 21、作用域 public , private , protected, default 的区别 访问 Public Protected 缺省（default） Private 同类 √ √ √ √ 同包 √ √ √ × 子类 √ √ × × 通用性 √ × × × 22、short s1 =1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? ​ 答：short s1 = 1; s1 = s1 + 1;(s1+1运算结果是 int 型， 需要强转)， short s1 = 1; s1 += 1; 可以正常运算。 23、Error 与 Exception 有什么区别？ ​ 答：Error 表示恢复不是不可能的，但很困难的情况下的一种严重总是 ​ Exception 表示一种设计或实现总是，也就是说，它表示如果程序运行正常，就不会发生的情况。 24、float型float f=3.4是否正确? ​ 答：不正确，没有小数点默认是 int 类型， 有小数点 默认为 double 类型，因此此声明需要进行强转 float f = (float)3.4; 25、int 和 integer 有什么区别？ ​ 答： int 是 java 的基本数据类型 ​ integer 是 java 为 int 提供的封装类 26、集合，IO 选择题1、当你编译和运行下面的代码时，会出现下面选项中的哪种情况？ 123456public class Pvf&#123; static boolean Paddy; public static void main(String args[])&#123; System.out.println(Paddy); &#125;&#125; A、编译时错误 B、编译通过并输出结果false C、编译通过并输出结果true D、编译通过并输出结果null 答案：B 解析： 2、 数据类型 初始值 byte 0 short 0 int 0 long 0L char ‘u0000’ float 0.0f double 0 boolean false 所有引用类型 null II前端一、表单1、在html中，除了text外还有几种种新增的表单元素？ 答：]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 数据类型 笔记]]></title>
    <url>%2F2019%2F02%2F12%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[MySQL 数据类型一、数值类型 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 二、日期和时间类型 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 ### 三、字符类型 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 ENUM 单选字符串数据类型（可为””或NULL） 适合存储表单界面中的“单选值”。 SET 多选字符串数据类型 适合存储表单界面的“多选值” 四、注意点1、DECIMAL(M,D)，其中M表示十进制数字总的个数，D表示小数点后面数字的位数，用于精确几位小数值。 2、TIMESTAMP，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。 3、ENUM的选项都会对应一个数字，依次是1，2，3，4，5…，最多有65535个选项,关于 ENUM 的使用可以参考此文 传送门。 4、SET的每个选项值也对应一个数字，依次是1，2，4，8，16…，最多有64个选项,关于 ENUM 的使用可以参考此文 传送门 五、参考 MySQL数据类型 MySQL数据类型 六、更多菜鸟教程]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[response �ʼ�]]></title>
    <url>%2F2019%2F02%2F12%2FCAS-note%2F</url>
    <content type="text"><![CDATA[CAS-note1.ʲô�ǵ����¼2.ʲô��CAS3.CAS����˲���3.1 cas-server.war CAS����˾���һ��war��(\cas\cas-server-x.x.x-release\cas-server-x.x.x\modules\cas-server-webapp-x.x.x.war) 3.2 tomcat���� �� cas-server.war ����һ�������� tomcat �� \apache-tomcat-CAS\webappsĿ¼�£����� tomcat ���ɡ� 3.3 ���в��� http://localhost:8080/cas/login 3.4 �޸������ļ� �޸� tomcat �˿� Ϊ 9100 \apache-tomcat-CAS\conf 123&lt;Connector port="9100" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; �޸�CAS�����ļ�\apache-tomcat-CAS\webapps\cas\WEB-INF\cas.properties 1server.name=http://localhost:9100 ȥ��https��֤CASĬ��ʹ�õ���HTTPSЭ�飬���ʹ��HTTPSЭ����ҪSSL��ȫ֤�飨�����ض��Ļ�������͹��� ������԰�ȫҪ�󲻸߻����ڿ������Խ׶Σ���ʹ��HTTPЭ�顣�������ｲ��ͨ���޸����ã���CASʹ��HTTPЭ�顣 \apache-tomcat-CAS\webapps\cas\WEB-INF\deployerConfigContext.xml 12&lt;bean class="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler"p:httpClient-ref="httpClient"/&gt; ������Ҫ���Ӳ���p:requireSecure=”false”��requireSecure������˼Ϊ�Ƿ���Ҫ��ȫ��֤����HTTPS��falseΪ������ �޸�cas��/WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml 12345&lt;bean id="ticketGrantingTicketCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator" p:cookieSecure="true" p:cookieMaxAge="-1" p:cookieName="CASTGC" p:cookiePath="/cas" /&gt; ����p:cookieSecure=”true”��ͬ��ΪHTTPS��֤��أ�TRUEΪ����HTTPS��֤��FALSEΪ������https��֤������p:cookieMaxAge=”-1”����COOKIE������������ڣ�-1Ϊ���������ڣ���ֻ�ڵ�ǰ�򿪵Ĵ�����Ч���رջ����´��������ڣ��Ի�Ҫ����֤�����Ը�����Ҫ�޸�Ϊ����0�����֣�����3600�ȣ���˼����3600���ڣ������ⴰ�ڣ�������Ҫ��֤���������ｫcookieSecure��Ϊfalse , cookieMaxAge ��Ϊ3600 �޸�cas��WEB-INF/spring-configuration/warnCookieGenerator.xml 12345&lt;bean id="warnCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator"p:cookieSecure="true"p:cookieMaxAge="-1"p:cookieName="CASPRIVACY"p:cookiePath="/cas" /&gt; �������ｫcookieSecure��Ϊfalse , cookieMaxAge ��Ϊ3600 �޸�Ĭ���û����� apache-tomcat-CAS\webapps\cas\WEB-INF\deployerConfigContext.xml 12345678&lt;bean id="primaryAuthenticationHandler" class="org.jasig.cas.authentication.AcceptUsersAuthenticationHandler"&gt; &lt;property name="users"&gt; &lt;map&gt; &lt;entry key="casuser" value="Mellon"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 3.5 �����˳���¼��,��ת��ָ��ҳ�棬�޸�casϵͳ�������ļ�cas-servlet.xml�µ� cas.logout.followServiceRedirects �� false Ϊ true123&lt;bean id="logoutAction" class="org.jasig.cas.web.flow.LogoutAction" p:servicesManager-ref="servicesManager" p:followServiceRedirects="$&#123;cas.logout.followServiceRedirects:true&#125;"/&gt; 4 CAS-DOME4.1 ����һ��maven(war)���� cas-client-dome14.2 ��������123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.aqqje.dome&lt;/groupId&gt; &lt;artifactId&gt;cas-client-dome1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- cas --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- ָ���˿� --&gt; &lt;port&gt;9001&lt;/port&gt; &lt;!-- ����·�� --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 4.3 ����web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;!-- ���ڵ����˳����ù���������ʵ�ֵ���ǳ����ܣ���ѡ���� --&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- �ù���������ʵ�ֵ���ǳ����ܣ���ѡ���á� --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- �ù����������û�����֤���������������� --&gt; &lt;filter&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;http://localhost:9100/cas/login&lt;/param-value&gt; &lt;!--�����server�Ƿ���˵�IP --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:9001&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- �ù����������Ticket��У�鹤�������������� --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;http://localhost:9100/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:9001&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- �ù���������ʵ��HttpServletRequest����İ����� ������������ͨ��HttpServletRequest��getRemoteUser()�������SSO��¼�û��ĵ�¼������ѡ���á� --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- �ù�����ʹ�ÿ����߿���ͨ��org.jasig.cas.client.util.AssertionHolder����ȡ�û��ĵ�¼���� ����AssertionHolder.getAssertion().getPrincipal().getName()�� --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 4.4 ��дindex.jsp1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;&lt;title&gt;cas-client-dome1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ==== cas-client-dome1 ==== &lt;%=request.getRemoteUser()%&gt; &lt;a href="http://localhost:9100/cas/logout?service=http://www.aqqje.com"&gt;�˳���¼&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; request.getRemoteUser()Ϊ��ȡԶ�̵�¼���� http://localhost:9100/cas/logout Ϊ����ǳ���ַ�� 4.5 �ٴ���һ��maven���̣�����ͬ�ϣ��˿�Ϊ90025.CAS-Clinet��SpringSecutiy����6.ʵս6.1 CASʹ�� user ��������֤���޸�cas�������web-inf��deployerConfigContext.xml �������������1234567891011121314&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" p:driverClass="com.mysql.jdbc.Driver" p:jdbcUrl="jdbc:mysql://127.0.0.1:3306/pinyougoudb?characterEncoding=utf8" p:user="root" p:password="123456" /&gt; &lt;bean id="passwordEncoder" class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder" c:encodingAlgorithm="MD5" p:characterEncoding="UTF-8" /&gt; &lt;bean id="dbAuthHandler" class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler" p:dataSource-ref="dataSource" p:sql="select password from tb_user where username = ?" p:passwordEncoder-ref="passwordEncoder"/&gt; Ȼ���������ļ���ʼ�����ҵ��������� 1234567891011 &lt;bean id="authenticationManager" class="org.jasig.cas.authentication.PolicyBasedAuthenticationManager"&gt; &lt;constructor-arg&gt; &lt;map&gt; &lt;entry key-ref="proxyAuthenticationHandler" value-ref="proxyPrincipalResolver" /&gt; &lt;entry key-ref="primaryAuthenticationHandler" value-ref="primaryPrincipalResolver" /&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;property name="authenticationPolicy"&gt; &lt;bean class="org.jasig.cas.authentication.AnyAuthenticationPolicy" /&gt; &lt;/property&gt;&lt;/bean&gt; ���� 1&lt;entry key-ref="primaryAuthenticationHandler" value-ref="primaryPrincipalResolver" /&gt; һ����ʹ�ù̶����û��������룬������������Կ���������bean ,�������ʹ�����ݿ���֤�û��������룬��Ҫ�����ע�͵� ���������һ������ 1&lt;entry key-ref="dbAuthHandler" value-ref="primaryPrincipalResolver"/&gt; ����������jar������webapps\cas\WEB-INF\lib�� c3p0-0.9.1.2.jar cas-server-support-jdbc-4.0.0.jar mysql-connector-java-5.1.32.jar 6.2 �޸� CAS Ĭ�ϵ�¼���� �༭casLoginView.jsp ����,���ָ�� 123456&lt;%@ page pageEncoding="UTF-8" %&gt;&lt;%@ page contentType="text/html; charset=UTF-8" %&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %&gt;&lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %&gt; �޸�form��ǩ 123&lt;form:form method="post" id="fm1" commandName="$&#123;commandName&#125;" htmlEscape="true" class="sui-form"&gt;......&lt;/form:form&gt; �޸��û����� 123&lt;form:input id="username" tabindex="1" accesskey="$&#123;userNameAccessKey&#125;" path="username" autocomplete="off" htmlEscape="true" placeholder="����/�û���/�ֻ���" class="span2 input-xfat" /&gt; �޸������ 123&lt;form:password id="password" tabindex="2" path="password" accesskey="$&#123;passwordAccessKey&#125;" htmlEscape="true" autocomplete="off" placeholder="����������" class="span2 input-xfat" /&gt; �޸ĵ�½��ť 1234&lt;input type="hidden" name="lt" value="$&#123;loginTicket&#125;" /&gt;&lt;input type="hidden" name="execution" value="$&#123;flowExecutionKey&#125;" /&gt;&lt;input type="hidden" name="_eventId" value="submit" /&gt;&lt;input class="sui-btn btn-block btn-xlarge btn-danger" accesskey="l" value="��½" type="submit" /&gt; 6.3 ������ʾ �ڱ��ڼ��������ʾ�� 12&lt;form:errors path="*" id="msg" cssClass="errors" element="div" htmlEscape="false" /&gt; ���ԣ����������û��������룬��ʾ��Ӣ�ġ������ʾ��Ϣ����WEB-INF\classesĿ¼�µ�messages.properties�ļ��� 12authenticationFailure.AccountNotFoundException=Invalid credentials.authenticationFailure.FailedLoginException=Invalid credentials. ���ù��ʻ�Ϊzn_CN ,�޸�cas-servlet.xml 1&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver" p:defaultLocale="zh_CN" /&gt; ������Ҫ������Ϣ������messages_zh_CN.properties�£�����Ϊ������ʾ��ת�룩 12authenticationFailure.AccountNotFoundException=\u7528\u6237\u4E0D\u5B58\u5728.authenticationFailure.FailedLoginException=\u5BC6\u7801\u9519\u8BEF.]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[response 笔记]]></title>
    <url>%2F2019%2F02%2F12%2FHTTP-Response%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[response 笔记1. HTTP协议：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748A. 请求消息：客户端发送给服务器端的数据 * 数据格式： 1. 请求行 2. 请求头 3. 请求空行 4. 请求体 B. 响应消息：服务器端发送给客户端的数据 * 数据格式： . 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) b. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载 c. 响应空行 d. 响应体:传输的数据 C. 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 2. Response对象1234567891011121314A. 功能：设置响应消息 a. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) b. 设置响应头：setHeader(String name, String value) c. 设置响应体： 使用步骤： 1. 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061B. 重定向: 资源跳转的方式 a. 示例 //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(&quot;/day15/responseDemo2&quot;); b. 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 c. 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 d. 路径写法： 1. 路径分类 i. 相对路径：通过相对路径不可以确定唯一资源 如：./index.html 不以/开头，以.开头路径 规则：找到当前资源和目标资源之间的相对位置关系 ./：当前目录 ../:后退一级目录 ii. 绝对路径：通过绝对路径可以确定唯一资源 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 以/开头的路径 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取：request.getContextPath() &lt;a&gt; , &lt;form&gt; 重定向... 给服务器使用：不需要加虚拟目录 转发路径 2. 服务器输出字符数据到浏览器 步骤： i. 获取字符输出流 ii. 输出数据 注意： 乱码问题： i. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 ii. 设置该流的默认编码 iii. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(&quot;text/html;charset=utf-8&quot;); 3. 服务器输出字节数据到浏览器 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 3.简单的验证码1234567891011121314151617181920212223242526272829303132333435363738394041424344protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置宽和高 int width = 100; int height = 50; // 1.创建图片对象 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // 2.美化图片 // 设置 bg Graphics g = image.getGraphics();// 获取画笔对象 g.setColor(Color.pink);// 设置画笔颜色 g.fillRect(0, 0, width, height); //画边框 g.setColor(Color.blue); g.drawRect(0, 0, width -1, height - 1); // 生成随机字符 String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789"; Random random = new Random(); for (int i = 1; i &lt;= 4 ; i++) &#123; // 生成随机角标 int index = random.nextInt(str.length()); char ch = str.charAt(index); // 写验证码 g.drawString(ch+"",width/5*i, height/2); &#125; g.setColor(Color.green); // 画干扰线 for (int i = 0; i &lt;8 ; i++) &#123; int x1 = random.nextInt(width); int x2 = random.nextInt(width); int y1 = random.nextInt(height); int y2 = random.nextInt(height); g.drawLine(x1, x2, y1, y2); &#125; // 3.输出图片 ImageIO.write(image, "jpg", response.getOutputStream()); &#125; 4. ServletContext对象：1234567891011121314151617181920212223242526272829A. 概念：代表整个web应用，可以和程序的容器(服务器)来通信B. 获取： a. 通过request对象获取 request.getServletContext(); b. 通过HttpServlet获取 this.getServletContext();C. 功能： a. 获取MIME类型： MIME类型:在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 text/html image/jpeg 获取：String getMimeType(String file) b. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) ServletContext对象范围：所有用户所有请求的数据 c. 获取文件的真实(服务器)路径 String getRealPath(String path) String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 System.out.println(b); String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 System.out.println(a); 5.简单的图片下载1234567891011121314151617181920A.分析： a. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 b. 任何资源都必须弹出下载提示框 c. 使用响应头设置资源的打开方式： content-disposition:attachment;filename=xxxB.步骤： a. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename b. 定义Servlet i. 获取文件名称 ii. 使用字节输入流加载文件进内存 iii. 指定response的响应头： content-disposition:attachment;filename=xxx iv. 将数据写出到response输出流C.问题： 中文文件问题 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同 D. 示例12345678910111213141516171819202122232425262728293031323334353637protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.获取下载文件请求的参数 request.setCharacterEncoding("utf-8"); String filename = new String(request.getParameter("filename").getBytes("iso-8859-1"), "utf-8"); System.out.println(filename); // 2.获取文件资源的路径 ServletContext context = request.getServletContext(); String realPath = context.getRealPath("/file/" + filename); System.out.println(realPath); // 3.获取输入流加载文件进行内存 FileInputStream fis = new FileInputStream(realPath); // A.设置响应头 // a.响应头类型 String mimeType = context.getMimeType(filename); response.setHeader("content-type",mimeType); // B.针对不浏览器设置不同的编码方式 String agent = request.getHeader("user-agent"); filename = DownLoadUtils.getFileName(agent, filename); System.out.println(filename); // b.响应头打开方式 response.setHeader("content-disposition", "attachment;filename="+filename); System.out.println(filename); // 4.使用输出流下载文件 ServletOutputStream sos = response.getOutputStream(); byte[] buff = new byte[1024*8]; int len = 0; while( (len = fis.read(buff)) != -1 )&#123; sos.write(buff, 0, len); &#125; // 5.关闭资源 fis.close(); &#125; 6.request.getParament()在get和post的乱码问题12345678910111213141516A.乱码原因: Http请求传输时将url以ISO-8859-1编码，服务器收到字节流后默认会以ISO-8859-1编码来解码成字符流（造成中文乱码）B. doPost(): 方法一: String filename = new String(request.getParameter(&quot;filename&quot;).getBytes(&quot;iso-8859-1&quot;), &quot;utf-8&quot;); 方法二: request.setCharacterEncoding(&quot;utf-8&quot;); String filename = request.getParameter(&quot;filename&quot;); 方法三: 对web服务器的默认编码进行修改:如Tomcat &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8444&quot; useBodyEncodingForURI=&quot;true&quot; URIEncoding=&quot;UTF-8&quot;/&gt;]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet&HTTP&Request笔记]]></title>
    <url>%2F2019%2F02%2F12%2FServet%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Servlet&amp;HTTP&amp;Request笔记1. Servlet1.1 概念： 运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 将来我们自定义一个类，实现Servlet接口，复写方法。 1.2 示例123456789A. 创建JavaEE项目B. 定义一个类，实现Servlet接口 public class ServletDemo1 implements ServletC. 实现接口中的抽象方法D. 配置Servlet 在web.xml中配置： 12345678910&lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 1.3 执行原理：123456789A. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径B. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。C. 如果有，则在找到对应的&lt;servlet-class&gt;全类名D. tomcat会将字节码文件加载进内存，并且创建其对象 E. 调用其方法 1.4 Servlet中的生命周期方法：1234567891011121314151617181920A. 被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 &lt;load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 &lt;load-on-startup&gt;的值为0或正整数 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 B. 提供服务：执行service方法，执行多次 每次访问Servlet时，Service方法都会被调用一次。C. 被销毁：执行destroy方法，只执行一次 a. Servlet被销毁时执行。服务器关闭时，Servlet被销毁 b. 只有服务器正常关闭时，才会执行destroy方法。 c. destroy方法在Servlet被销毁之前执行，一般用于释放资源 2. Servlet3.0 A. 好处： 1a. 支持注解配置。可以不需要web.xml了。 B. 步骤： 12345a. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xmlb. 定义一个类，实现Servlet接口c. 复写方法d. 在类上使用@WebServlet注解，进行配置 @WebServlet(&quot;资源路径&quot;) C. @WebServlet 1234567891011121314@Target(&#123;ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet &#123; String name() default "";//相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; ... &#125; 3. Servlet的体系结构12345678910111213Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可HttpServlet：对http协议的一种封装，简化操作 a. 定义类继承HttpServlet b. 复写doGet/doPost方法 4. Servlet相关配置123456A. urlpartten:Servlet访问路径 a. 一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;) b. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML笔记]]></title>
    <url>%2F2019%2F02%2F12%2Fxml%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[XML笔记1. 什么是XML?1.1 概念Extensible Markup Language 可扩展标记语言 1.可扩展：标签都是自定义的。 &lt;user&gt; &lt;student&gt; 1.2 功能: 存储数据 1. 配置文件 2. 在网络中传输 1.3 xml与html的区别1.xml标签都是自定义的，html标签是预定义。 2. xml的语法严格，html语法松散 3. xml是存储数据的，html是展示数据 2. 语法：2.1 基本语法：1. xml文档的后缀名 .xml 2. xml第一行必须定义为文档声明 3. xml文档中有且仅有一个根标签 4. 属性值必须使用引号(单双都可)引起来 5. 标签必须正确关闭 6. xml标签名称区分大小写 2.2快速入门：123456789101112131415&lt;?xml version='1.0' ?&gt; &lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 2.3 组成部分：A. 文档声明 格式: 1&lt;?xml 属性列表 ?&gt; 属性列表： 123456789101. version：版本号，必须的属性2. encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-13. standalone：是否独立 取值： a. yes：不依赖其他文件 b. no：依赖其他文件 B. 指令：结合css1&lt;?xml-stylesheet type="text/css" href="a.css" ?&gt; C. 标签：标签名称自定义的 规则：12345671. 名称可以包含字母、数字以及其他的字符 2. 名称不能以数字或者标点符号开始 3. 名称不能以字母 xml（或者 XML、Xml 等等）开始 4. 名称不能包含空格 D. 属性： id属性值唯一 E. 文本： CDATA区：在该区域中的数据会被原样展示;格式如下:1&lt;![CDATA[ 数据 ]]&gt; F 约束：规定xml文档的书写规则 作为框架的使用者(程序员)： 1231.能够在xml中引入约束文档2.能够简单的读懂约束文档 分类： 1231. DTD:一种简单的约束技术2. Schema:一种复杂的约束技术 DTD： 12345引入dtd文档到xml文档中 内部dtd：将约束规则定义在xml文档中 外部dtd：将约束的规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; Schema: 12345* 引入： 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; 123&lt;students xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.aqqje.com/xml" xsi:schemaLocation="http://www.aqqje.com/xml student.xsd"&gt; 3. 解析：操作xml文档，将文档中的数据读取到内存中3.1操作xml文档1231. 解析(读取)：将文档中的数据读取到内存中2. 写入：将内存中的数据保存到xml文档中。持久化的存储 3.2解析xml的方式：12345671. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 2. SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 3.3xml常见的解析器：12345671. JAXP：sun公司提供的解析器，支持dom和sax两种思想2. DOM4J：一款非常优秀的解析器3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。4. PULL：Android操作系统内置的解析器，sax方式的。 3.4 Jsoup使用 步骤：12341. 导入jar包2. 获取Document对象3. 获取对应的标签Element对象4. 获取数据 示例 12345678910111213//2.1获取student.xml的pathString path = JsoupDemo1.class.getClassLoader().getResource("student.xml").getPath();//2.2解析xml文档，加载文档进内存，获取dom树---&gt;DocumentDocument document = Jsoup.parse(new File(path), "utf-8");//3.获取元素对象 ElementElements elements = document.getElementsByTag("name");System.out.println(elements.size());//3.1获取第一个name的Element对象Element element = elements.get(0);//3.2获取数据String name = element.text();System.out.println(name); 对象说明: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 1.Jsoup：工具类，可以解析html或xml文档，返回Document a. parse：解析html或xml文档，返回Document parse​(File in, String charsetName)：解析xml或html文件的。 parse​(String html)：解析xml或html字符串 parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2.Document：文档对象。代表内存中的dom树 a. 获取Element对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合3.Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 4.Element：元素对象 a.获取子元素对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 b.获取属性值 String attr(String key)：根据属性名称获取属性值 c.获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容)5.Node：节点对象 a. Document和Element的父类 6. 快捷查询方式： a. selector:选择器 使用的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 b. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 代码： //1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.获取Document对象 Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); &#125;]]></content>
      <categories>
        <category>xml</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java����ţ��ʮ��ر���վ �ʼ�]]></title>
    <url>%2F2019%2F02%2F12%2Fjava%20%E5%8D%81%E5%A4%A7%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Java����ţ��ʮ��ر���վ: https://www.programcreek.com/ http://stackoverflow.com/ http://www.dzone.com/ http://leetcode.com/ http://docs.oracle.com/javase/ https://github.com/ https://www.coursera.org/ http://www.javaworld.com/ http://www.ibm.com/developerworks/java/ 10.http://en.wikipedia.org/wiki/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat & Servlet 笔记]]></title>
    <url>%2F2019%2F02%2F12%2FTomcat%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Tomcat &amp; Servlet 笔记1. 软件架构123A. C/S：客户端/服务器端B. B/S：浏览器/服务器端 2.资源分类12345 A. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析如： html,css,JavaScript B. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器如：servlet/jsp,php,asp.... 3. 网络通信三要素12345678A. IP：电子设备(计算机)在网络中的唯一标识。B. 端口：应用程序在计算机中的唯一标识。 0~65536 C. 传输协议：规定了数据传输的规则 基础协议： a. tcp:安全协议，三次握手。 速度稍慢 b. udp：不安全协议。 速度快 4. web服务器软件：123456 A. 服务器：安装了服务器软件的计算机 B. 服务器软件：接收用户的请求，处理请求，做出响应 C. web服务器软件：接收用户的请求，处理请求，做出响应。a. 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目web容器 4.1 常见的java相关的web服务器软件：1234A. webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。B. webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。C. JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。D. Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 5. Tomcat5.1 下载： http://tomcat.apache.org/ 5.2 安装： 解压压缩包即可。 注意：安装目录建议不要有中文和空格 5.3 卸载： 删除目录就行了 5.4 启动： bin/startup.bat ,双击运行该文件即可 访问：浏览器输入： http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 5.5 关闭： 正常关闭： 123bin/shutdown.batctrl+c 强制关闭： 1点击启动窗口的× 5.6 配置: 部署项目的方式： 123456789101112A. 直接将项目放到webapps目录下即可。 a. /hello：项目的访问路径--&gt;虚拟目录 b. 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 _**war包会自动解压缩**_B. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt; docBase:项目存放的路径 path：虚拟目录C. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=&quot;D:\hello&quot; /&gt; 虚拟目录：xml文件的名称 静态项目和动态项目： 1234567目录结构 java动态项目的目录结构： -- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 5.7 * 可能遇到的问题：1234567891011121314A. 黑窗口一闪而过： 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 B. 启动报错： a. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 netstat -ano b. 温柔：修改自身的端口号 conf/server.xml &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 好处：在访问时，就不用输入端口号 6. Servlet6.1 概念： 运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 将来我们自定义一个类，实现Servlet接口，复写方法。 6.2 示例123456789A. 创建JavaEE项目B. 定义一个类，实现Servlet接口 public class ServletDemo1 implements ServletC. 实现接口中的抽象方法D. 配置Servlet 在web.xml中配置： 12345678910&lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 6.3 执行原理：123456789A. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径B. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。C. 如果有，则在找到对应的&lt;servlet-class&gt;全类名D. tomcat会将字节码文件加载进内存，并且创建其对象 E. 调用其方法 6.4 Servlet中的生命周期方法：1234567891011121314151617181920A. 被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 &lt;load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 &lt;load-on-startup&gt;的值为0或正整数 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 B. 提供服务：执行service方法，执行多次 每次访问Servlet时，Service方法都会被调用一次。C. 被销毁：执行destroy方法，只执行一次 a. Servlet被销毁时执行。服务器关闭时，Servlet被销毁 b. 只有服务器正常关闭时，才会执行destroy方法。 c. destroy方法在Servlet被销毁之前执行，一般用于释放资源 7. Servlet3.0 A. 好处： 1a. 支持注解配置。可以不需要web.xml了。 B. 步骤： 12345a. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xmlb. 定义一个类，实现Servlet接口c. 复写方法d. 在类上使用@WebServlet注解，进行配置 @WebServlet(&quot;资源路径&quot;) C. @WebServlet 1234567891011121314@Target(&#123;ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet &#123; String name() default "";//相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; ... &#125; 8. IDEA与tomcat的相关配置12345678 A. IDEA会为每一个 tomcat 部署的项目单独建立一份配置文件查看控制台的 log：Using CATALINA_BASE: &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot; B. 工作空间项目和 tomcat 部署的web项目tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源WEB-INF目录下的资源不能被浏览器直接访问。 C. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要重写equals()与hashCode()方法？]]></title>
    <url>%2F2019%2F01%2F12%2Fequals%E4%B8%8Ehashcode%2F</url>
    <content type="text"><![CDATA[为什么要重写equals()与hashCode()方法？一、两者的职能是什么？ equals 很明显，该方法就是用来判断两个对象是否是同一个对象。在Object类源码中，其底层是使用了“==”来实现，也就是说通过比较两个对象的内存地址是否相同判断是否是同一个对象。 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 实际应用中，该方法不能满足的我们的需求。因为我们认为两个对象即使不是指向的同一块内存，只要这两个对象的各个字段属性值都相同，那么就认为这两个对象是同一个对象。所以就需要重写equals（）方法，即如果两个对象指向内存地址相同或者两个对象各个字段值相同，那么就是同一个对象。 hashcod Object类源码中，hashCode()是一个native方法，哈希值的计算利用的是内存地址。 1public native int hashCode(); 利用哈希表也能起到一定的判重的作用，但是现实是可能存在哈希冲突,哈希表具有优越的查询性能，并且存在哈希冲突。** 二、两者之间有什么联系？ 如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同！！！！； 如果两个对象不同（即用equals比较返回true），那么它们的hashCode值可能相同也可能不同； 如果两个对象的hashCode相同（存在哈希冲突），那么它们可能相同也可能不同(即equals比较可能是false也可能是true) 如果两个对象的hashCode不同，那么他们肯定不同(即用equals比较返回false)三、为什么要重写？ 对于对象集合的判重，如果一个集合含有10000个对象实例，仅仅使用equals()方法的话，那么对于一个对象判重就需要比较10000次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的hashCode不相同，也不再需要调用equals（）方法，从而大大减少了equals()比较次数。所以从程序实现原理上来讲的话，既需要equals()方法，也需要hashCode()方法。那么既然重写了equals（），那么也要重写hashCode()方法，以保证两者之间的配合关系。 基于以上分析，我们可以在Java集合框架中得到验证。由于HashSet是基于HashMap来实现的，所以这里只看HashMap的put方法即可。源码如下 12345678910111213141516171819202122232425public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); //这里通过哈希值定位到对象的大概存储位置 int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //if语句中，先比较hashcode，再调用equals()比较 //由于“&amp;&amp;”具有短路的功能，只要hashcode不同，也无需再调用equals方法 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125; 我们在实际应用过程中，如果仅仅重写了equals（），而没有重写hashCode()方法，会出现什么情况？字段属性值完全相同的两个对象因为hashCode不同，所以在hashmap中的table数组的下标不同，从而这两个对象就会同时存在于集合中，所以重写equals()就一定要重写hashCode()方法。 对于“为什么重写equals()就一定要重写hashCode()方法？”这个问题应该是有个前提，就是你需要用到HashMap,HashSet等Java集合。用不到哈希表的话，其实仅仅重写equals()方法也可以吧。而工作中的场景是常常用到Java集合，所以Java官方建议 重写equals()就一定要重写hashCode()方法。 原文：为什么重写equals()就一定要重写hashCode()方法？ 四、==与equals的区别 ==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。 equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。 参考: Java的==与equals之辨，简单解释，很清楚.]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-learn]]></title>
    <url>%2F2018%2F09%2F09%2Fspringboot-learn%2F</url>
    <content type="text"><![CDATA[一、Spring Boot 入门1、 Spring Boot 简介 简化Spring应用开发框架 整个Spring技术栈大整合 J2EE开发一站式解决方案 2. 微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备 jdk1.8： Spring Boot 推荐jdk1.7及以上版本; maven3.x: maven 3.3 以上版本 IntelliJIDEA2017 及 STS Spring Boot 1.5.9.RELEASE及以上版本 4、Spring Boot HelloWorld 实现功能： 浏览器发送hello请求， 服务器接受请求并处理，响应 Hello World 字符串 A、 创建一个maven工程(jar) 省略… B、导入Spring Boot 相关的依赖1234567891011121314&lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; C、写一个主程序；启动Spring Boot应用123456789101112/** * SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125; D、编写相关的Controller、Service12345678@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(name = "/hello") public String hello()&#123; return "Hello World"; &#125;&#125; E、运行主程序测试 省略… F、简化部署123456789&lt;!-- 将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Maven Projects -&gt; spring-boot-helloworld -&gt; Lifecycle -&gt; package 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究A、POM文件a、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） b、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web： 1spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 B、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； 12345标注在某个类上，表示这是一个Spring Boot的配置类；@**Configuration**:配置类上来标注这个注解； 配置类 ----- 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； 1以前我们需要配置的东西，Spring Boot帮我们自动配置；@**EnableAutoConfiguration**告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; 12345 @**AutoConfigurationPackage**：自动配置包@**Import**(AutoConfigurationPackages.Registrar.class)：Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== 123456789@**Import**(EnableAutoConfigurationImportSelector.class)； 给容器中导入组件？ **EnableAutoConfigurationImportSelector**：导入哪些组件的选择器； 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； 1SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； 6、使用Spring Initializer快速创建Spring Boot项目A、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； B、STS使用 Spring Starter Project快速创建项目 省略… 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） 123YAML A Markup Language：是一个标记语言YAML isn&apos;t Markup Language：不是一个标记语言； 标记语言： 12345以前的配置文件；大多都使用的是 **xxxx.xml**文件；YAML：**以数据为中心**，比json、xml等更适合做配置文件；YAML：配置例子 12server: port: 8081 1XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：A、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； B、值的写法a、字面量：普通的值（数字，字符串，布尔）1234567891011k: v：字面直接来写； 字符串默认不用加上单引号或者双引号； &quot;&quot;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: &quot;zhangsan \n lisi&quot;：输出；zhangsan 换行 lisi &apos;&apos;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi b、对象、Map（属性和值）（键值对）：123k: v：在下一行来写对象的属性和值的关系；注意缩进 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; c、数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] d、yaml参考语法3、配置文件值注入 配置文件 12345678910person: name: aqqje age: 20 boss: true data: 2018/7/29 map: &#123;k1: v1, k2: v2&#125; list: [AQQJE, LIULI, WLN] dog: name: xq age: 2 javaBean 12345678910111213141516171819/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String name; private Integer age; private Boolean boss; private Date data; private Map map; private List list; private Dog dog; 导入配置文件处理器，编写配置提示 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; A、 properties配置文件在idea中默认utf-8可能会乱码 调整 settings -&gt; File Encodings -&gt; Default encoding for properties files: UTF-8 &amp;&amp; √ Transparent native-to-ascii conversion B、配置文件注入值数据校验1234567891011121314151617181920212223@Component//@ConfigurationProperties(prefix = "person")@Validated //@Validated 开启JSR303数据校验public class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ // @Value("刘明") //lastName必须是邮箱格式 @Email @Value("$&#123;person.name&#125;") private String name; // @Value("#&#123;11 * 2&#125;") private Integer age; private Boolean boss; private Date data; //@Value("$&#123;person.map&#125;") private Map map; private List list; private Dog dog; C、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； D、@PropertySource&amp;@ImportResource&amp;@Bean @PropertySource：加载指定的配置文件 1@PropertySource(value = &#123;"classpath:person.properties"&#125;) @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效 1、Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 2、想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类(主程序类、主入口类)上 3、@ImportResource(locations = {“classpath:beans.xml”})导入Spring的配置文件让其生效 SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 myConfig.java: 123456789101112131415/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class myConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; 4、配置文件占位符A、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; B、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.name=刘明$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.boss=falseperson.data=2018/7/29person.map.k1=v1person.map..k2=v2person.list=a, b, cperson.dog.name=$&#123;person.hello: hello&#125;_dogperson.dog.age=3 5、ProfileA、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； B、yml支持多文档块方式123456789101112131415server: port: 8081spring: profiles: active: dev---server: port: 11spring: profiles: dev---server: port: 7021spring: profiles: prod C、激活指定profile 1、在配置文件中指定 spring.profiles.active=dev 2、命令行： 12345&gt; java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar -- spring.profiles.active=dev；&gt; &gt; 可以直接在测试的时候，配置传入命令行参数&gt; &gt; 3、虚拟机参数； 123&gt; -Dspring.profiles.active=dev&gt; &gt; 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar demo-0.0.1-SNAPSHOT.jar –spring.config.location=C:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找，优先加载带profile 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 A、自动配置原理：a、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==b、@EnableAutoConfiguration 作用：** 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； b、每一个自动配置类进行自动配置功能；c、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； d、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); B、 精髓：a、SpringBoot启动会加载大量的自动配置类b、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类c、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）d、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值 1、xxxxAutoConfigurartion：自动配置类； 2、给容器中添加组件； 3、xxxxProperties:封装配置文件中相关属性； C、细节A、@Conditional派生注解（Spring注解版原生的@Conditional作用）1作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； 5、JDBC—数据库驱动； 12345&gt; 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；&gt; &gt; 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；&gt; &gt; 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ 1**SpringBoot选用 SLF4j和logback** 2、SLF4j使用A、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； B、遗留问题a、（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx1***统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？*** b、如何让系统中所有的日志都统一到slf4j 1、将系统中其他日志框架先排除出去 2、用中间包来替换原有的日志框架 3、我们导入slf4j其他的实现 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;s SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 总结： 123451）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录2）、SpringBoot也把其他的日志都替换成了slf4j；3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); 1234）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 123456789 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.aqqje=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== 1webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== 1localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； A、引入thymeleaf；123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6&lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; B、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： a、导入thymeleaf的名称空间1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; b、使用thymeleaf语法；123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; C、语法规则a、th:text；改变当前元素里面的文本内容；1th：任意html属性；来替换原生属性的值 b、表达式？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications A. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; 1==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. B、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /aqqje 请求来到 success registry.addViewController("/aqqje").setViewName("success"); &#125;&#125; 原理： 1231）、WebMvcAutoConfiguration是SpringMVC的自动配置类2）、在做其他自动配置时会导入；@Import(**EnableWebMvcConfiguration**.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; 123453）、容器中所有的WebMvcConfigurer都会一起起作用；4）、我们的配置类也会被调用；效果：SpringMVC的自动配置和我们的扩展配置都会起作用； C、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 12345678910111213141516/** * WebMvcConfigurerAdapter 过时 * 使用1、WebMvcConfigurationSupport 2、WebMvcConfigurer可以来扩展SpringMVC的功能 * @EnableWebMvc 不要接管SpringMVC */@Configurationpublic class MyMvcConfig extends WebMvcConfigurationSupport &#123; @Override protected void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /aqqje 请求来到 success super.addViewControllers(registry); registry.addViewController("/aqqje").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； a、@EnableWebMvc的核心12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; b、WebMvcConfigurationSupport12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; c、WebMvcConfigurationSupport 问题12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; d、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；e、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；5、如何修改SpringBoot的默认配置模式： 123451）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUDA、默认访问首页12345678910111213141516171819202122232425//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /aqqje 请求来到 success registry.addViewController("/aqqje").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; B、国际化a、编写国际化配置文件； b、使用ResourceBundleMessageSource管理国际化资源文件 c、在页面使用fmt:message取出国际化内容 步骤： a、编写国际化配置文件，抽取页面需要显示的国际化消息 b、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; c、配置 application.properties 1spring.messages.basename=i18n.login.login d、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： 1国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 e、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; C、登陆开发期间模板引擎页面修改以后，要实时生效 a、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false b、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; D、拦截器进行登陆检查a、编写拦截器 1234567891011121314151617181920212223242526272829/** * 登录检查拦截器 */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null )&#123; // 未登录，返回登录 request.setAttribute("msg", "没权限，请登录！"); request.getRequestDispatcher("index.html").forward(request, response); return false; &#125;else&#123; // 放行 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; b、注册拦截器 1234567891011121314151617181920212223242526272829303132333435363738@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/", "login.html", "/index.html", "/user/login"); &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/aqqje").setViewName("success"); &#125; @Bean public WebMvcConfigurer webMvcConfigurer()&#123; WebMvcConfigurer config = new WebMvcConfigurer()&#123; /** * 第一种：配置 templates 首页【抑制spring boot的自动加载index页面为首页】, * 必须加载到Spring Boot 容器中才可以生效 */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/login.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; &#125;; return config; &#125; // 注册国际化解析器 @Bean public LocaleResolver localeResolver()&#123; return new MyLocalResolver(); &#125;&#125; c、配置静态资源（默认路径不用配置） 方式一：application.properties 123456#spring.mvc.static-path-pattern=/**表示所有的访问都经过静态资源路径；spring.mvc.static-path-pattern=/**#web.upload-path=D:/temp/study13/#spring.resources.static-locations配置静态资源路径spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,\ classpath:/static/,classpath:/public/ 方式二：MyMvcConfig.java 12345//注册其他静态资源路径 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/my/**").addResourceLocations("classpath:/my/"); &#125; E、CRUD-员工列表实验要求： a、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE b、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE c、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 1234567891011121314151617&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; F、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@aqqje.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； G、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@aqqje.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; H、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制A、SpringBoot默认的错误处理机制默认效果： 11）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： 12）、如果是其他客户端，默认响应一个json数据 原理： 1可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 11、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; 12、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; 13、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） 14、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; 12345步骤： 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被**BasicErrorController**处理； 1）响应页面；去哪个页面是由**DefaultErrorViewResolver**解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; B、如果定制错误响应：a、如何定制错误的页面；**123456789101112131415161718192021**1）、有模板引擎的情况下；error/状态码;** 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面；我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； 页面能获取的信息； timestamp：时间戳 status：状态码 error：错误提示 exception：异常对象 message：异常消息 errors：JSR303数据校验的错误都在这里2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； b、如何定制错误的json数据；11）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... 12）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; c、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； 123451、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","aqqje"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ A、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; B、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； C、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; D、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); 1从ioc容器中获取EmbeddedServletContainerFactory 组件；**TomcatEmbeddedServletContainerFactory**创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar 123优点：简单、便携；缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； A、步骤a、必须创建一个war项目；（利用idea创建好目录结构）b、将嵌入式的Tomcat指定为provided；12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; c、必须编写一个SpringBootServletInitializer的子类，并调用configure方法123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; d、启动服务器就可以使用；B、原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： 服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1、启动Tomcat 2、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer-、 3、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4、每一个WebApplicationInitializer都调用自己的onStartup； 5、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念 1、docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； 2、docker客户端(Client)：连接docker主机进行操作； 3、docker仓库(Registry)：用来保存各种打包好的软件镜像； 4、docker镜像(Images)：软件打包好的镜像；放在docker仓库中； 5、docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装DockerA、安装linux虚拟机a、VMWare、VirtualBox（安装）；b、导入虚拟机文件centos7-aqqje.ova；c、双击启动linux虚拟机;使用 root/ 123456登陆d、使用客户端连接linux服务器进行命令操作；e、设置虚拟机网络；1桥接网络===选好网卡====接入网线； f、设置好网络以后使用命令重启虚拟机的网络1service network restart g、查看linux的ip地址1ip addr h、使用客户端连接linux；B、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作A、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ B、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 C、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql &quot;docker-entrypoint.sh&quot; 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql &quot;docker-entrypoint.sh&quot; 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql &quot;docker-entrypoint.sh&quot; 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： 123默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： A、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；B、SpringBoot默认可以支持；1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 C、自定义数据源类型1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; D、DataSourceInitializer：ApplicationListener； 作用： 1、runSchemaScripts();运行建表语句； 2、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 E、操作数据库：自动配置了JdbcTemplate操作数据库2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： 1、配置数据源相关属性（见上一节Druid） 2、给数据库建表 3、创建JavaBean A、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = "com.aqqje.springboot.mapper")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; B、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPAA、SpringData简介 B、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理 几个重要的事件回调机制 1、配置在META-INF/spring.factories ApplicationContextInitializer *SpringApplicationRunListener** 2、只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println("SpringApplicationRunListener...starting..."); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextPrepared..."); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextLoaded..."); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println("SpringApplicationRunListener...finished..."); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\com.aqqje.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\com.aqqje.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println("ApplicationRunner...run...."); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： 1231、这个场景需要使用到的依赖是什么？2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ 13、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.aqqje.starter&lt;/groupId&gt; &lt;artifactId&gt;aqqje-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aqqje.starter&lt;/groupId&gt; &lt;artifactId&gt;aqqje-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.aqqje.starter&lt;/groupId&gt; &lt;artifactId&gt;aqqje-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;aqqje-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.aqqje.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "aqqje.hello")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.aqqje.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellaqqje(String name)&#123; return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.aqqje.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 九、Spring Boot与缓存1、简介 1、Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； 2、Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； 3、Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； 2、几个重要概念&amp;缓存注解 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 3、Cache SpEL available metadata 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache #root.caches[0].name argument name evaluation context 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引； #iban 、 #a0 、 #p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache put’的表达式 ’cache evict’的表达式beforeInvocation=false） #result 4.初体验 1、引入spring-boot-starter-cache模块 2、@EnableCaching开启缓存 3、使用缓存注解 4、切换为其他缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172 ===============SpringBootCacheApplication.java============@MapperScan("com.aqqje.cache.mapper")@EnableCaching // 开启缓存@SpringBootApplicationpublic class SpringBootCacheApplication &#123; ================EmployeeService.java===================package com.aqqje.cache.service;import com.aqqje.cache.bean.Employee;import com.aqqje.cache.mapper.EmployeeMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.*;import org.springframework.stereotype.Service;@Service@CacheConfig(cacheNames="emp"/*,cacheManager = "employeeCacheManager"*/) //抽取缓存的公共配置public class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; // 查询 /** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； * * * 原理： * 1、自动配置类；CacheAutoConfiguration * 2、缓存的配置类 * org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration * org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration * org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration * org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration * org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration * org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration * org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration * org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】 * org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration * 3、哪个配置类默认生效：SimpleCacheConfiguration； * * 4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager * 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； * * 运行流程： * @Cacheable： * 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； * （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 * 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； * key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； * SimpleKeyGenerator生成key的默认策略； * 如果没有参数；key=new SimpleKey()； * 如果有一个参数：key=参数的值 * 如果有多个参数：key=new SimpleKey(params)； * 3、没有查到缓存就调用目标方法； * 4、将目标方法返回的结果，放进缓存中 * * @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， * 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； * * 核心： * 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 * 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator * * * 几个属性： * cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； * * key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 * 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] * getEmp[2] * * keyGenerator：key的生成器；可以自己指定key的生成器的组件id * key/keyGenerator：二选一使用; * * * cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 * * condition：指定符合条件的情况下才缓存； * ,condition = "#id&gt;0" * condition = "#a0&gt;1"：第一个参数的值》1的时候才进行缓存 * * unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 * unless = "#result == null" * unless = "#a0==2":如果第一个参数的值是2，结果不缓存； * sync：是否使用异步模式 * @param id * @return * */ @Cacheable(/*cacheNames = &#123;"emp"&#125;*/, key = "#a0"/*,keyGenerator = "myKeyGenerator",condition = "#a0&gt;1",unless = "#a0==2"*/) // 根据方法的请求参数对其结果进行缓存 public Employee findById(Integer id)&#123; System.out.println("查询" + id + "号员工"); return employeeMapper.findById(id); &#125; //更新 /** * @CachePut：既调用方法，又更新缓存数据；同步更新缓存 * 修改了数据库的某个数据，同时更新缓存； * 运行时机： * 1、先调用目标方法 * 2、将目标方法的结果缓存起来 * * 测试步骤： * 1、查询1号员工；查到的结果会放在缓存中； * key：1 value：lastName：张三 * 2、以后查询还是之前的结果 * 3、更新1号员工；【lastName:zhangsan；gender:0】 * 将方法的返回值也放进缓存了； * key：传入的employee对象 值：返回的employee对象； * 4、查询1号员工？ * 应该是更新后的员工； * key = "#employee.id":使用传入的参数的员工id； * key = "#result.id"：使用返回后的id * @Cacheable的key是不能用#result * 为什么是没更新前的？【1号员工没有在缓存中更新】 * */ @CachePut(/*value="emp"*/ key = "#a0.id") public boolean updateById(Employee employee)&#123; return 0 != employeeMapper.updateById(employee); &#125; //删除 /** * @CacheEvict：缓存清除 * key：指定要清除的数据 * allEntries = true：指定清除这个缓存中所有的数据 * beforeInvocation = false：缓存的清除是否在方法之前执行 * 默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 * * beforeInvocation = true： * 代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 * * */ @CacheEvict(/*value="emp"*/ key="#id" /* allEntries=true*/) public boolean deleteById(Integer id)&#123; return 0 != employeeMapper.deleteById(id); &#125; //添加 @CachePut(/*value = "emp"*/, key = "#a0.id") public boolean insertEmp(Employee employee)&#123; return 0 != employeeMapper.insertEmp(employee); &#125; // @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value="emp",*/key = "#lastName") &#125;, put = &#123; @CachePut(/*value="emp",*/key = "#result.id"), @CachePut(/*value="emp",*/key = "#result.email") &#125; ) public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName); &#125;&#125; KeyGenerator: key 生成器 1234567891011121314151617181920212223242526package com.aqqje.cache.config;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.lang.reflect.Method;import java.util.Arrays;@Configurationpublic class CacheCofing &#123; // 自定义key生成器 @Bean("mykeyGenerator") public KeyGenerator keyGenerator()&#123; return new KeyGenerator()&#123; @Override public Object generate(Object o, Method method, Object... objects) &#123; return method.getName()+ "[" + Arrays.asList(objects).toString() + "]"; &#125; &#125;; &#125;&#125;// 如何使用@Cacheable(cacheNames = &#123;"emp"&#125;,keyGenerator = "myKeyGenerator") 5、整合RedisA、引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; B、配置 IP 和端口123#配置redis的 Ip 和 端口spring.redis.host=127.0.0.1spring.redis.port=6379 C、使用Redis123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899====================================MyRedisConfig================= package com.aqqje.cache.config;import com.aqqje.cache.bean.Employee;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import java.net.UnknownHostException;@Configurationpublic class MyRedisConfig &#123; /* * json序列化器 * */ @Bean public RedisTemplate&lt;Object, Employee&gt; jsonRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(jackson2JsonRedisSerializer); return template; &#125;&#125;=========================SpringBootCacheApplicationTests=================package com.aqqje.cache;import com.aqqje.cache.bean.Employee;import com.aqqje.cache.mapper.EmployeeMapper;import com.aqqje.cache.service.EmployeeService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.test.context.junit4.SpringRunner;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootCacheApplicationTests &#123; @Autowired DataSource dataSource; @Autowired EmployeeService employeeService; @Autowired RedisTemplate redisTemplate;//k-v都是对象的 @Autowired StringRedisTemplate stringRedisTemplate; //操作k-v都是字符串的 @Autowired RedisTemplate&lt;Object, Employee&gt; jsonRedisTemplate; /** * Redis常见的五大数据类型 * String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合） * stringRedisTemplate.opsForValue()[String（字符串）] * stringRedisTemplate.opsForList()[List（列表）] * stringRedisTemplate.opsForSet()[Set（集合）] * stringRedisTemplate.opsForHash()[Hash（散列）] * stringRedisTemplate.opsForZSet()[ZSet（有序集合）] */ @Test public void testStringRedisTemplate()&#123; // 给redis保存数据 //stringRedisTemplate.opsForValue().append("msg", "aqqje"); //String msg = stringRedisTemplate.opsForValue().get("msg"); //System.out.println(msg); //stringRedisTemplate.opsForList().leftPush("mylist", "1"); stringRedisTemplate.opsForList().leftPush("mylist", "2"); &#125; // 测试保存对象 @Test public void testRedisTemplate()&#123; Employee id = employeeService.findById(4); //redisTemplate.opsForValue().set("emp-01", id); //默认如果保存对象，使用jdk序列化机制，序列化后的数据保存到redis中 //redisTemplate.opsForValue().set("emp-01",empById); //1、将数据以json的方式保存 //(1)自己将对象转为json //(2)redisTemplate默认的序列化规则；改变默认的序列化规则； jsonRedisTemplate.opsForValue().set("emp-01", id); &#125; D、自定义RedesCacheManager123456789101112131415====================================MyRedisConfig================= @Bean public RedisCacheManager empCacheManger(RedisConnectionFactory redisConnectionFactory)&#123; //初始化一个RedisCacheWriter RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory); //设置CacheManager的值序列化方式为Jackson2JsonRedisSerializer Jackson2JsonRedisSerializer&lt;Employee&gt; employeeJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); RedisSerializationContext.SerializationPair&lt;Employee&gt; pair = RedisSerializationContext.SerializationPair.fromSerializer(employeeJackson2JsonRedisSerializer); RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(pair); //设置默认超过期时间是30秒 defaultCacheConfig.entryTtl(Duration.ofSeconds(30)); //初始化RedisCacheManager RedisCacheManager cacheManager = new RedisCacheManager(redisCacheWriter, defaultCacheConfig); return cacheManager; &#125; E、多个CacheManager使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990==========================myRedisConfig.java============================ /* * json序列化器 * */ @Bean public RedisTemplate&lt;Object, Employee&gt; empJsonRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Employee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(jackson2JsonRedisSerializer); return template; &#125; /** * employee json 序列化器 * * @Primary：有多个序列化器必须指定其中一个这首要序列化器 * @param redisConnectionFactory * @return */ @Primary @Bean public RedisCacheManager empCacheManager(RedisConnectionFactory redisConnectionFactory)&#123; //初始化一个RedisCacheWriter RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory); //设置CacheManager的值序列化方式为Jackson2JsonRedisSerializer Jackson2JsonRedisSerializer&lt;Employee&gt; Jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); RedisSerializationContext.SerializationPair&lt;Employee&gt; pair = RedisSerializationContext.SerializationPair.fromSerializer(Jackson2JsonRedisSerializer); RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(pair); //设置默认超过期时间是30秒 defaultCacheConfig.entryTtl(Duration.ofSeconds(30)); //初始化RedisCacheManager RedisCacheManager cacheManager = new RedisCacheManager(redisCacheWriter, defaultCacheConfig); return cacheManager; &#125; @Bean public RedisTemplate&lt;Object, Department&gt; deptJsonRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Department&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class); template.setDefaultSerializer(jackson2JsonRedisSerializer); return template; &#125; /** * department json 序列化器 * * @param redisConnectionFactory * @return */ @Bean public RedisCacheManager deptCacheManager(RedisConnectionFactory redisConnectionFactory)&#123; //初始化一个RedisCacheWriter RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory); //设置CacheManager的值序列化方式为Jackson2JsonRedisSerializer Jackson2JsonRedisSerializer&lt;Department&gt; Jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Department&gt;(Department.class); RedisSerializationContext.SerializationPair&lt;Department&gt; pair = RedisSerializationContext.SerializationPair.fromSerializer(Jackson2JsonRedisSerializer); RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(pair); //设置默认超过期时间是30秒 defaultCacheConfig.entryTtl(Duration.ofSeconds(30)); //初始化RedisCacheManager RedisCacheManager cacheManager = new RedisCacheManager(redisCacheWriter, defaultCacheConfig); return cacheManager; &#125;==================DepartmentService.java&amp;&amp;EmployeeService.java==================== // 分别指定对应的 xxxCacheManager @CacheConfig(cacheNames = &#123;"dept"&#125;, cacheManager = "deptCacheManager" ) @CacheConfig(cacheNames="emp",cacheManager = "empCacheManager") //抽取缓存的公共配置 ==================SpringBootCacheApplicationTests.java=================== // 使用 xxxCacheManager 对缓存进行操作 @Qualifier("deptCacheManager") @Autowired RedisCacheManager deptCacheManager; @Test public void test1()&#123; Cache cache = deptCacheManager.getCache("dept"); Object nativeCache = cache.getNativeCache(); System.out.println(cache.getName()); &#125; 十、Spring Boot与消息1、消息服务简介A、提升系统异步通信、扩展解耦能力B、消息服务中两个重要概念：C、消息代理（message broker）D、目的地（destination）E、消息队列主要有两种形式的目的地： 1.队列（queue）：点对点消息通信（point-to-point） 2.主题（topic）：发布（publish）/订阅（subscribe）消息通信 F、使用场景 异步处理 应用解耦 流量削峰 G、点对点式: 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 消息只有唯一的发送者和接受者，但并不是说只能有一个接收者 H、发布订阅式: –发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息 I、JMS（Java Message Service）JAVA消息服务： –基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 J、AMQP（Advanced Message Queuing Protocol） 高级消息队列协议，也是一个消息代理的规范，兼容JMS RabbitMQ是AMQP的实现 JMS与AMQP对比 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 Model 提供两种消息模型： （1）、Peer-2-Peer （2）、Pub/sub 提供了五种消息模型： （1）、direct exchange （2）、fanout exchange （3）、topic change （4）、headers exchange （5）、system exchange 本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分； 支持消息类型 多种消息类型： TextMessage MapMessage BytesMessage StreamMessage ObjectMessage Message （只有消息头和属性） byte[] 当实际应用时，有复杂的消息，可以将消息序列化后发送。 综合评价 JMS 定义了JAVA API层面的标准；在java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差； AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。 L、Spring支持 spring-jms提供了对JMS的支持 spring-rabbit提供了对AMQP的支持 需要ConnectionFactory的实现来连接消息代理 提供JmsTemplate、RabbitTemplate来发送消息 @JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息 @EnableJms、@EnableRabbit开启支持 M、Spring Boot自动配置 JmsAutoConfiguration RabbitAutoConfiguration 2、RabbitMQ简介A、RabbitMQ1是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。 B、核心概念 Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别 Queue 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。 Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 Exchange 和Queue的绑定可以是多对多的关系。 Connection 网络连接，比如一个TCP连接。 Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。 Consumer 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 。 Broker 表示消息队列服务器实体 C、RabbitMQ运行机制a、MQP 中消息路由 AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角 色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。 b、Exchange类型 Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型： direct Exchange : 一对一 fanout Exchange：对所有 topic Exchange：对匹配 D、RabbitMq安装测试(docker 容器) 下载运行 123docker pull registry.docker-cn.com/library/rabbitmq:3-management // 下载rabbitmq镜像docker run --name rabbit -d -p 5672:5672 -p 15672:15672 rabbitmq:3-management // 运行rabbitmq 其中 【5672为消息通信端口】 【15672为rabbit web 界面端口】 消息测试图 创建交换器 创建消息队列 为交换器绑定消息队列 测试 3、SpringBoot整合rabbitMQA、引入jar包1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; B、基于注解开启rabbit模式1234567891011/** * rabbitMq自动配置类：RabbitAutoConfiguration * 1.CachingConnectionFactory：自动配置的连接工厂 * 2.RabbitTemplate：关于 rabbitMq 消息的发送和接收 * 3.AmqpAdmin：RabbitMQ系统管理功能组件; * 创建和删除 Queue，Exchange，Binding */@EnableRabbit // 基于注解开启rabbit模式@SpringBootApplicationpublic class SpringbootRabbitmqApplication C、配置rabbitMQ并使用 application.properties: 12345# 配置连接端口spring.rabbitmq.host=192.168.99.100 # 配置 rabbitMq 用户和密码spring.rabbitmq.username=guestspring.rabbitmq.password=guest SpringbootRabbitmqApplicationTests： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.aqqje.rabbitmq;import com.aqqje.rabbitmq.comfig.bean.Book;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.HashMap;import java.util.Map;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootRabbitmqApplicationTests &#123; @Autowired RabbitTemplate rabbitTemplate; /** * 单播(点对点) */ @Test public void contextLoads() &#123; //Message需要自己构造一个;定义消息体内容和消息头 //rabbitTemplate.send(exchage,routeKey,message); //object默认当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq； //rabbitTemplate.convertAndSend(exchage,routeKey,object); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("msg", "This first messages"); map.put("data", "Hello Word"); map.put("flag", true); rabbitTemplate.convertAndSend("exchange.direct","aqqje.news", map); &#125; /** * 接收消息 */ @Test public void receive()&#123; Object book = rabbitTemplate.receiveAndConvert("aqqje"); System.out.println(book.getClass()); System.out.println(book); &#125; /** * 广播 */ @Test public void fanout()&#123; rabbitTemplate.convertAndSend("exchange.fanout", "", new Book("aqqje", 100)); &#125;&#125; D、配置json序列化器123456789101112131415161718package com.aqqje.rabbitmq.comfig;import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;import org.springframework.amqp.support.converter.MessageConverter;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 为rabbitMq配置json序列化器 */@Configurationpublic class MyAmqpConfig &#123; @Bean public MessageConverter messageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125;&#125; E、rabbitmq监听器及amqpadmin对exchanges, queues, binding 的操作（删除与创建）1234567891011121314151617181920212223242526@EnableRabbit + @RabbitListener = rabbitmq监听器=============================SpringbootRabbitmqApplication============@EnableRabbit // 基于注解开启rabbit模式@SpringBootApplicationpublic class SpringbootRabbitmqApplication &#123;==============================BookService=============================package com.aqqje.rabbitmq.service;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Service;@Servicepublic class BookService &#123; @RabbitListener(queues = "aqqje.emps") public void reciver(Message message)&#123; System.out.println(message.getBody()); System.out.println(message.toString()); &#125;&#125; 123456789101112131415161718192021222324@Test public void testamqpAdmin()&#123; // 创建一个交换器 //amqpAdmin.declareExchange(new DirectExchange("aqqje.direct", true, false)); //amqpAdmin.declareExchange(new FanoutExchange("aqqje.fanout", true, false)); //amqpAdmin.declareExchange(new TopicExchange("aqqje.topic", true, false)); // 创建消息队列 //amqpAdmin.declareQueue(new Queue("aqqje.emps", true)); //amqpAdmin.declareQueue(new Queue("aqqje.news", true)); //amqpAdmin.declareQueue(new Queue("aqqje", true)); // 为交换器绑定消息队列 //amqpAdmin.declareBinding(new Binding("aqqje.emps", Binding.DestinationType.QUEUE, "aqqje.direct", "aqqje.emps", null)); //amqpAdmin.declareBinding(new Binding("aqqje.news", Binding.DestinationType.QUEUE, "aqqje.fanout", "aqqje.news", null)); //amqpAdmin.declareBinding(new Binding("aqqje", Binding.DestinationType.QUEUE, "aqqje.topic", "aqqje.#", null)); //amqpAdmin.declareBinding(new Binding("aqqje.emps", Binding.DestinationType.QUEUE, "aqqje.topic", "aqqje.#", null)); //amqpAdmin.declareBinding(new Binding("aqqje.news", Binding.DestinationType.QUEUE, "aqqje.topic", "aqqje.#", null)); //amqpAdmin.declareBinding(new Binding("aqqje.news", Binding.DestinationType.QUEUE, "aqqje.topic", "*.aqqje", null)); //System.out.println("创建完成！"); // 删除指定的交换器和消息队列 //amqpAdmin.deleteExchange("aqqje.fanout"); //amqpAdmin.deleteQueue("aqqje.news"); &#125; 十一、SpringBoot整合ElasticSearch1、docker安装ElasticSearch12345678# 搜索elasticsearch镜像docker search elasticsearch# 下载elasticsearch镜像(加速)docker pull registry.docker-cn.com/library/elasticsearch# 运行elasticsearch(9200：web端口，9300：各节点通信端口)docker run -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -d -p 9200:9200 -p 9300:9300 --name ES01 registry.docker-cn.com/library/elasticsearch 2、ElasticSearch入门 官方文档 阮一峰ES教程 3、springboot整合ES(jest) 1234567891011121314151617&gt; /**&gt; * SpringBoot默认支持两种技术来和ES交互；&gt; * 1、Jest（默认不生效）&gt; * 需要导入jest的工具包（io.searchbox.client.JestClient）&gt; * 2、SpringData ElasticSearch【ES版本有可能不合适】&gt; * 版本适配说明：https://github.com/spring-projects/spring-data-elasticsearch&gt; * 如果版本不适配：2.4.6&gt; * 1）、升级SpringBoot版本&gt; * 2）、安装对应版本的ES&gt; *&gt; * 1）、Client 节点信息clusterNodes；clusterName&gt; * 2）、ElasticsearchTemplate 操作es&gt; * 3）、编写一个 ElasticsearchRepository 的子接口来操作ES；&gt; * 两种用法：https://github.com/spring-projects/spring-data-elasticsearch&gt; * 1）、编写一个 ElasticsearchRepository&gt; */&gt; A、引入 jar 包(与ES版本对应)123456&lt;!-- https://mvnrepository.com/artifact/io.searchbox/jest --&gt; &lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;6.3.1&lt;/version&gt; &lt;/dependency&gt; B、添加一定的elastic配置123=====================application.properties=======================spring.elasticsearch.jest.uris=http://192.168.99.100:9200 C、测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.aqqje.eclastic;import com.aqqje.eclastic.bean.Article;import io.searchbox.client.JestClient;import io.searchbox.core.Index;import io.searchbox.core.Search;import io.searchbox.core.SearchResult;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.io.IOException;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootEclasticApplicationTests &#123; @Autowired JestClient jestClient; @Test public void contextLoads() &#123; Article article = new Article(2, "aqqje", "china"); // 创建新的索引 Index index = new Index.Builder(article).index("aqqje").type("news").id("1").build(); try &#123; // 执行 jestClient.execute(index); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 全文搜索 */ @Test public void search()&#123; //查询表达式 String json ="&#123;\n" + " \"query\" : &#123;\n" + " \"match\" : &#123;\n" + " \"type\" : \"china\"\n" + " &#125;\n" + " &#125;\n" + "&#125;"; //更多操作：https://github.com/searchbox-io/Jest/tree/master/jest //构建搜索功能 Search search = new Search.Builder(json).addIndex("aqqje").addType("news").build(); try &#123; SearchResult result = jestClient.execute(search); System.out.println(result.getJsonString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4、springboot整合ES(spring-data) 版本要一定的适配， 官方文档 123==========================application.properties===============================spring.data.elasticsearch.cluster-name=elasticsearchspring.data.elasticsearch.cluster-nodes=192.168.99.100:9300 123456789101112131415161718192021222324252627282930313233343536373839==========================BookRepository.java===============================public interface BookRepository extends ElasticsearchRepository&lt;Book, Integer&gt; &#123; //参照 // https://docs.spring.io/spring-data/elasticsearch/docs/3.0.6.RELEASE/reference/html/ public List&lt;Book&gt; findByBookNameLike(String bookName);&#125;==========================Book.java===============================@Document(indexName = "aqqje", type = "book")public class Book &#123; private Integer id; private String author; private String title;==========================aSpringboot03ElasticApplicationTests.java========================== @RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot03ElasticApplicationTests &#123; @Autowired JestClient jestClient; @Autowired BookRepository bookRepository; @Test public void test02()&#123;// Book book = new Book();// book.setId(1);// book.setTitle("西游记");// book.setAuthor("吴承恩");// bookRepository.index(book); for (Book book : bookRepository.findByBookNameLike("游")) &#123; System.out.println(book); &#125; ; &#125; 十二、SpringBoot与任务1、异步任务1234567891011121314151617181920212223242526272829303132333435363738394041==================SpringbootTaskApplication.java===================@EnableAsync //开启异步任务@SpringBootApplicationpublic class SpringbootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootTaskApplication.class, args); &#125;&#125;=====================AsyncService.java=================@Servicepublic class AsyncService &#123; @Async // 异步加载 public void hello()&#123; try &#123; Thread.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("数据正在加载中...."); &#125;&#125;=====================AsyncController.java===========================@RestControllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @GetMapping("/hello") public String asyncHello()&#123; asyncService.hello(); return "hello async"; &#125;&#125; 2、定时任务123456789101112131415161718192021222324252627282930313233&gt;========================SpringbootTaskApplication.java=====================@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class SpringbootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootTaskApplication.class, args); &#125;&#125;====================ScheduledSerivce.java======================@Servicepublic class ScheduledSerivce &#123; /** * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）. * 0 * * * * MON-FRI * 【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次 * 【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次 * 【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次 * 【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次 * 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次； */ // @Scheduled(cron = "0 * * * * MON-SAT") //@Scheduled(cron = "0,1,2,3,4 * * * * MON-SAT") // @Scheduled(cron = "0-4 * * * * MON-SAT") @Scheduled(cron = "0-4 * * * * 1-5") public void schedule()&#123; System.out.println("hello schedule"); &#125;&#125; 关于 cron 属性的表达式 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 , - * / 星期 0-7或SUN-SAT 0,7是SUN , - * ? / L C # 特殊字符 代表含义 , 枚举 - 区间 * 任意 / 步长 ? 日/星期冲突匹配 L 最后 W 工作日 C 和calendar联系后计算过的值 # 星期，4#2，第2个星期四 3、邮件任务 引入 jar 包 12345================pom.xml===================&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 配置发件邮箱的基本信息 123456789101112===================application.properties====================# 邮箱帐户spring.mail.username=1042136232@qq.com# 授权码spring.mail.password=ysutsphjlltjbcej# 发件端口spring.mail.host=smtp.qq.com# ssl传输spring.mail.properties.mail.smtp.ssl.enable=true#加密连接spring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=true 测试邮箱发件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364==========================SpringbootTaskApplicationTests=============== package com.aqqje.task;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.test.context.junit4.SpringRunner;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import java.io.File;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootTaskApplicationTests &#123; @Autowired JavaMailSenderImpl mailSender; /** * 发送简单的邮件 */ @Test public void contextLoads() &#123; SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setTo("aqqjeqnyh@163.com"); simpleMailMessage.setFrom("1042136232@qq.com"); // 邮件标题 simpleMailMessage.setSubject("spring-boot-mail"); // 邮件内容 simpleMailMessage.setText("====aqqje learning spring-boot-mail====="); mailSender.send(simpleMailMessage); &#125; /** * 发送复杂的邮件 */ @Test public void test02() throws MessagingException &#123; MimeMessage mimeMessage = mailSender.createMimeMessage(); /** * multipart: true * 可发送携带附件的邮件 */ MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setTo("aqqjeqnyh@163.com"); helper.setFrom("1042136232@qq.com"); // 邮件标题 helper.setSubject("&lt;b style='color:red'&gt;spring-boot-mail&lt;b/&gt;"); // 邮件内容 helper.setText("====aqqje learning spring-boot-mail====="); // 添加图片 helper.addAttachment("1.jpg", new File("C:\\wallpaper\\360\\317441.jpg")); helper.addAttachment("1.jpg", new File("C:\\wallpaper\\360\\319354.jpg")); mailSender.send(mimeMessage); &#125;&#125; 十三、SpringBoot与SpringSecurity1234567891011121314151617181920212223242526272829303132package com.aqqje.security;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 1、引入SpringSecurity； * 2、编写SpringSecurity的配置类； * @EnableWebSecurity extends WebSecurityConfigurerAdapter * 3、控制请求的访问权限： * configure(HttpSecurity http) &#123; * http.authorizeRequests().antMatchers("/").permitAll() * .antMatchers("/level1/**").hasRole("VIP1") * &#125; * 4、定义认证规则： * configure(AuthenticationManagerBuilder auth)&#123; * auth.inMemoryAuthentication() * .withUser("zhangsan").password("123456").roles("VIP1","VIP2") * &#125; * 5、开启自动配置的登陆功能： * configure(HttpSecurity http)&#123; * http.formLogin(); * &#125; * 6、注销：http.logout(); * 7、记住我：Remeberme()； */@SpringBootApplicationpublic class SprintbootSecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SprintbootSecurityApplication.class, args); &#125;&#125; 1、引入SpringSecurity123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt;&lt;/dependency&gt; 2、编写PasswordEncoder实现类1234567891011public class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 3、编写SpringSecurity的配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.aqqje.security.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) throws Exception &#123; //super.configure(web); //设置静态资源不要拦截 //web.ignoring().antMatchers("/js/**","/cs/**","/images/**"); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); //定制请求的授权规则 http .authorizeRequests() // 放行 /** 下的所有请求 .antMatchers("/").permitAll() .antMatchers("/level1/**").hasRole("VIP1") .antMatchers("/level2/**").hasRole("VIP2") .antMatchers("/level3/**").hasRole("VIP3"); //开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面 http.formLogin().usernameParameter("user").passwordParameter("pwd").loginPage("/userlogin"); //1、/login来到登陆页 //2、重定向到/login?error表示登陆失败 //3、更多详细规定 //4、默认post形式的 /login代表处理登陆 //5、一但定制loginPage；那么 loginPage的post请求就是登陆 //开启自动配置的注销功能。 http.logout().logoutSuccessUrl("/"); //1、访问 /logout 表示用户注销，清空session //2、注销成功会返回 /login?logout 页面； //开启记住我功能 http.rememberMe().rememberMeParameter("remember"); //登陆成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登录 //点击注销会删除cookie //关闭默认的csrf认证 //http.csrf().disable(); &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() //不加.passwordEncoder(new MyPasswordEncoder()) //就不是以明文的方式进行匹配，会报错 //.withUser("aqqje").password("123456").roles("VIP1", "VIP2") .passwordEncoder(new MyPasswordEncoder()) .withUser("aqqje").password("123456").roles("VIP1", "VIP2") .and() .passwordEncoder(new MyPasswordEncoder()) .withUser("yjgm").password("123456").roles("VIP2", "VIP3") .and() //.passwordEncoder(new MyPasswordEncoder())。 //这样，页面提交时候，密码以明文的方式进行匹配。 .passwordEncoder(new MyPasswordEncoder()) .withUser("tom").password("123456").roles("VIP1", "VIP3"); &#125;&#125; 4、使用thymeleaf操作数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;h1 align="center"&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;&lt;div sec:authorize="!isAuthenticated()"&gt; &lt;h2 align="center"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href="@&#123;/userlogin&#125;"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;hr&gt;&lt;!-- isAuthenticated: 布尔值，指示当前用户是否已通过身份验证（已登录）。--&gt;&lt;div sec:authorize="isAuthenticated()"&gt; &lt;h2&gt; &lt;span sec:authentication="name"&gt;&lt;/span&gt;，您好,您的角色有： &lt;span sec:authentication="principal.authorities"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;form th:action="@&#123;/logout&#125;" th:method="post"&gt; &lt;input th:type="submit" th:value="注销"&gt; &lt;/form&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP1')"&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/1&#125;"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/2&#125;"&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level1/3&#125;"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP2')"&gt; &lt;h3&gt;高级武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/1&#125;"&gt;太极拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/2&#125;"&gt;七伤拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level2/3&#125;"&gt;梯云纵&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP3')"&gt; &lt;h3&gt;绝世武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/1&#125;"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/2&#125;"&gt;龟派气功&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/level3/3&#125;"&gt;独孤九剑&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 十四、SpringBoot与分布式1、springBoot(1.5.15)+zookeeper+dubboA、在运程主机安装 zookerper 注册中心（详情）B、创建一个生产者-服务【provider-ticket】 加入依赖 12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入zookeeper的客户端工具--&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; 创建ticket服务 123456789101112131415161718===========================TicketService====================public interface TicketService &#123; public String ticket();&#125;===============================TicketServiceImpl====================import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Component@Servicepublic class TicketServiceImpl implements TicketService &#123; @Override public String ticket() &#123; return "《厉害了，我的国》"; &#125;&#125; 将服务注册到注册中心 12345dubbo.application.name=provider-ticketdubbo.registry.address=zookeeper://192.168.99.100:2181dubbo.scan.base-packages=com.aqqje.ticket.service C、创建一个消费者-用户【consumer-user】 加入依赖 com.alibaba.boot dubbo-spring-boot-starter 0.1.0 1234567&lt;!--引入zookeeper的客户端工具--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 将ticket服务的接口复制到cousumer-user用户下；即 public interface TicketService ;同名同包 创建用户消费服务 123456789101112131415161718package com.aqqje.user;import com.alibaba.dubbo.config.annotation.Reference;import com.aqqje.ticket.service.TicketService;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; @Reference TicketService ticketService; public void hello()&#123; String ticket = ticketService.ticket(); System.out.println("买到票：" + ticket); &#125;&#125; 注册到注册中心 123dubbo.application.name=consumer-userdubbo.registry.address=zookeeper://192.168.99.100:2181 测试 2、SpringBoot2 + SpringCloud 1.eureka –&gt; 注册中心 2.provider-ticket –&gt; 购票服务 2.concumer-user –&gt; 消费者购票 A、eureka 1.配置eureka信息 12345678910server: port: 8761eureka: instance: hostname: eureka-server client: register-with-eureka: false # 不把自己注册到注册中心 fetch-registry: false # 不获取注册中心的信息 service-url: defaultZone: http://localhost:8761/eureka/ 2.开启eurekao服务: @ EurekaService 123@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; B、provider-ticket 编写服务类 123456@Servicepublic class TicketService &#123; public String getTicket()&#123; return "《厉害了，我的国！》"; &#125;&#125; 1234567891011@RestControllerpublic class TicketController &#123; @Autowired TicketService ticketService; @GetMapping("/ticket") public String getTicket()&#123; return ticketService.getTicket(); &#125;&#125; 将服务注册到注册中心 1234567891011server: port: 8082spring: application: name: provider-ticketeureka: instance: prefer-ip-address: true #注册服务的时候使用服务的ip地址 client: service-url: defaultZone: http://localhost:8761/eureka/ C、concumer-user 开启发现服务功能 123@EnableDiscoveryClient // 开启发现服务功能@SpringBootApplicationpublic class ConsumerUserApplication &#123; 使用 RestTemplate 发送 http 服务请求 12345@LoadBalanced // 开启负载均衡机制 @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; 使用 ticket服务 1234567891011121314151617package com.aqqje.user.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Servicepublic class UserService &#123; @Autowired RestTemplate restTemplate; public String ticket()&#123; String s = restTemplate.getForObject("http://PROVIDER-TICKET/ticket", String.class); return s; &#125;&#125; 十五、SpringBoot与热部署 在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。 1、模板引擎 在Spring Boot中开发情况下禁用模板引擎的cache 页面模板改变ctrl+F9可以重新编译当前页面并生效 2、Spring LoadedSpring官方提供的热部署程序，实现修改类文件的热部署 下载Spring Loaded（项目地址https://github.com/spring-projects/spring-loaded） 添加运行时参数； javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify 3、JRebel 收费的一个热部署软件 安装插件使用即可 4、Spring Boot Devtools（推荐） 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; IDEA使用ctrl+F9 十六、SpringBoot与Spring Actuator【监管】1、文档 官方html文档 官方ptf文档 中文文档 2、Actuator配置1========application.properties======= 12345678910111213141516171819202122232425262728293031323334353637#基于springboot2x# 暴露出指定的端口(*代表所有)#management.endpoints.web.exposure.include=*management.endpoints.web.exposure.include=info,health# 设置所有端口的基础路径management.endpoints.web.base-path=/# info 信息info.app.id=springboot-actuatorinfo.app.version=1.0.0# 单个使用端口 management.endpoint.[endpoint].enabled=truemanagement.endpoint.shutdown.enabled=true# 通过management.endpoints.enabled-by-default来修改全局端口默认配置,以下示例启用info端点并禁用所有其他端点：#management.endpoints.enabled-by-default=falsemanagement.endpoint.info.enabled=truemanagement.endpoint.health.enabled=true#*在YAML中有特殊的含义，所以如果你想包含（或排除）所有的端点，一定要加引号，如下例所示：#management:#endpoints:#web:#exposure:#include: &apos;*&apos;#禁用HTTP端点#management.server.port=-1#自定义管理服务器地址management.server.port=8081management.server.address=localhost#Git提交信息management.info.git.mode=full#端点映射到其他路径management.endpoints.web.path-mapping.info=info11 3、监控和管理端点 端点名 描述 autoconfig 所有自动配置信息 auditevents 审计事件 beans 所有Bean的信息 configprops 所有配置属性 dump 线程状态信息 env 当前环境信息 health 应用健康状况 info 当前应用信息 metrics 应用的各项指标 mappings 应用@RequestMapping映射路径 shutdown 关闭当前应用（默认关闭） trace 追踪信息（最新的http请求） 4、自定义HealthIndicator类12345678910111213import org.springframework.boot.actuate.health.Health;import org.springframework.boot.actuate.health.HealthIndicator;import org.springframework.stereotype.Component;@Componentpublic class MyHealthIndicators implements HealthIndicator &#123; @Override public Health health() &#123; //return Health.up().build(); 正常 return Health.down().withDetail("msg","服务异常").build(); &#125;&#125; 十七、更多SpringBoot整合示例]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 学习笔记.md]]></title>
    <url>%2F2018%2F09%2F06%2FRedis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-md%2F</url>
    <content type="text"><![CDATA[Redis 学习笔记一、简介1、LNoSQL非关系型数据库1not only sql, 是一种非关系型的数据存储，key/value键值对存储。现有Nosql DB 产品： Redis/MongoDB/Memcached/Hbase/Cassandra/ Tokyo Cabinet/Voldemort/Dynomite/Riak/ CouchDB/Hypertable/Flare/Tin/Lightcloud/ KiokuDB/Scalaris/Kai/ThruDB, 等等~~~ 2、为什么需要NoSQL非关系型数据库？12345- High performance - 对数据库高并发读写的需求- Huge Storage - 对海量数据的高效率存储和访问的需求- High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求 3、Redis123456789Redis是一种面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。 这些数据类型支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的，支持各种不同方式的排序。redis 与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改 操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。redis目前提供五种数据类型：String,Hash,List,Set,sorted setRedis的存储分为内存存储、磁盘存储和log文件三部分，配置文件中有三个参数对其进行配置save seconds updates :指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。appendonly yes/no :是否在每次更新操作后进行日志记录。如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据 文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。appendfsync no/always/everysec ：数据缓存同步至磁盘的方式。no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次。 二、安装1、下载 【win7&amp;&amp;win10 】 A、mis文件1一路 next 即可 1测试 123设置为windows下的服务- redis-server --service-install redis.windows-service.conf --loglevel verbose 1观察服务列表 1完成 1234567常用的redis服务命令。卸载服务：redis-server --service-uninstall开启服务：redis-server --service-start停止服务：redis-server --service-stop B、zip文件12345- 直接解压- 手动配置环境变量- 运行 cmd： redis-server.exe redis.windows.conf 1完成 三、参考参考【https://www.cnblogs.com/sunxuchu/p/5463403.html】 参考【https://www.cnblogs.com/lezhifang/p/7027903.html】 参考【https://www.cnblogs.com/sunxuchu/p/5463403.html】]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dockerDocker入门教程]]></title>
    <url>%2F2018%2F09%2F05%2FDocker%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Docker 中国官方镜像加速 https://www.docker-cn.com/registry-mirror 其他教程dockerDocker入门教程 - 阮一峰]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[favorite]]></title>
    <url>%2F2018%2F07%2F28%2Ffavorite%2F</url>
    <content type="text"><![CDATA[收藏夹Typora 的使用手册]]></content>
      <tags>
        <tag>favorite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 问题锦集]]></title>
    <url>%2F2018%2F06%2F06%2FAndroid-%E9%97%AE%E9%A2%98%E9%94%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Android 问题锦集 android studio新建项目时出现Error:Execution failed for task ‘:app:preDebugAndroidTestBuild’.1.在app下的build.gradle文件中的dependences {}中添加如下代码： androidTestCompile(‘com.android.support:support-annotations:26.1.0’) { force = true} 1234567891011121314dependencies &#123; androidTestCompile(&apos;com.android.support:support-annotations:26.1.0&apos;) &#123; force = true &#125; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation&quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot; implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;&#125; 参考 android studio 出现 “Unsupported method: BaseConfig.getApplicationIdSuffix()”找到项目下的 gradle – &gt; build.gradle 修改如下 1234567891011121314buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // 原先错误原因请删除或注释掉 //classpath 'com.android.tools.build:gradle:1.0.0' // 修改如下: classpath 'com.android.tools.build:gradle:2.3.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 参考 Android studio 出现 “Error:Failed to open zip file. Gradle’s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)”]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win7 应用程序图标显示异常]]></title>
    <url>%2F2018%2F05%2F31%2Fwin7-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[描述：有时不知道自己做了什么，突然有一两个应用图标显示总是不正常，让人十分不开心！ 如何解决win键 + R –&gt; cmd –&gt; 输入以下内容： taskkill /im explorer.exe /fcd /d %userprofile%\appdata\localdel iconcache.db /astart explorer.exeexit 成功]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 完全卸载]]></title>
    <url>%2F2018%2F05%2F30%2FMySQL-%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[MySQL 完全卸载 note 卸载程序卸载所有的 MySQL 组件程序 删除 MySQL 安装目录C:\Program Files\MySQLC:\ProgramData\MySQLC:\Users\zhenghaishu\AppData\Roaming\MySQLC:\Users\zhenghaishu\AppData\Local\Temp\MySQL WorkbenchC:\Users\zhenghaishu\AppData\Roaming\Oracle\MySQL Notifier 删除注册表 进入注册表 使用 winq键 + r 输入 regedit 命令 打开注册表 删除注册表 HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/Eventlog/Application/MySQLHKEY_LOCAL_MACHINE/SYSTEM/ControlSet002/Services/Eventlog/Application/MySQLHKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Application/MySQL Win7完全卸载MySQL的步骤]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybaties learn]]></title>
    <url>%2F2018%2F05%2F29%2FMybaties-learn%2F</url>
    <content type="text"><![CDATA[Mybaties learn note mybaties-HelloWord 加入必要 jar 包 log4j.jar： 日志包 与 log4j.xml 文件共同使用 mybatis-3.4.1.jar：mybaties 必要包 mysql-connector-java-5.1.45.jar：mysql 数据库连接包 2.创建 mybaties 全局配置文件 mybaties-config.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///mybaties"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 3.编写 Employee bean 4.创建 EmployyeMapper.xml 文件并注册在 mybaties 全局配置文件中 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace:命令空间,指定为接口的全类名 id: 唯一标识符 resultType:返回值类型 #&#123;id&#125;: 从传递过来的参数中取出id值--&gt;EmployyeMapper.xml：&lt;mapper namespace="com.aqqje.mybaties.mapper"&gt; &lt;select id="selectEmployee" resultType="com.aqqje.mybaties.beans.Employee"&gt; &lt;!-- 若数据库的字段名与 bean 的属性不一致时请使用别名 --&gt; select id, last_name lastName, email, gender from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;mybaties-config.xml： &lt;!-- 注册 EmployyeMapper对应的 sql 映射 --&gt; &lt;mappers&gt; &lt;mapper resource="conf/EmployeeMapper.xml"/&gt; &lt;/mappers&gt; 5.编写测试类 MybatiesTest a. Mybaties 框架主要是围绕 SqlSessionFactory 这个类进行工作的, 创建 SqlSessionFactory 对象 b. 获取 sqlSession 实例 c. 使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查 d. 一个sqlSession就是代表和数据库的一次会话，用完关闭 1234567891011121314151617public SqlSessionFactory getSqlSessionFactory() throws Exception &#123; String resource = "conf/mybaties-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); return sqlSessionFactory; &#125; @Test public void testSelectOne() throws Exception &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); try &#123; Employee employee = session.selectOne("com.aqqje.mybaties.mapper.selectEmployee", 1); System.out.println(employee); &#125; finally &#123; session.close(); &#125; &#125; mybaties-HelloWord基础之上实现接口式编程 新建一个接口 EmployeeMapper 抽象 getEmpById(Integer id) 方法 EmployeeMapper.xml 文件中绑定 EmployeeMapper 接口 和 方法 使用 sqlSession.getMapper(Class var1) 方法获取 EmployyeMapper 对象 调用 getEmpById(Integer id) 123456789101112131415EmployeeMapper.xml:&lt;mapper namespace="com.aqqje.mybaties.dao.EmployeeMapper"&gt; &lt;select id="getEmpById" resultType="com.aqqje.mybaties.beans.Employee"&gt;select id, last_name lastName, email, gender from tbl_employee where id = #&#123;id&#125;&lt;/select&gt;&lt;/mapper&gt;MybatiesTest.java: //获取接口的实现类对象 //会为接口自动的创建一个代理对象，代理对象去执行增删改查方法 EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); Employee employee = employeeMapper.getEmpById(1); System.out.println(employee); properties标签 mybatis可以使用properties来引入外部properties配置文件的内容； resource：引入类路径下的资源 url：引入网络路径或者磁盘路径下的资源 settings 标签 设置 描述 有效值 默认 mapUnderscoreToCamelCase 可以所数据库中以 last_name 命令方式转化为 lastName 的驼峰形式 false, true false typeAliases(类型别名)别名处理器：可以为我们的java类型起别名,别名不区分大小写 1.typeAlias:为某个java类型起别名 type:指定类型,默认别名为类名小写：employee alias:指定新的别名 2.package:为某个包下的所有类批量起别名 name：指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写），） 批量起别名的情况下，使用@Alias注解为某个类型指定新的别名 mybaties 中对于常见Java类型有许多内置类型别名 它们都是大小写不敏感的，注意由于重载名称而对基元的特殊处理。 8大基础类型, 在类型前加 “_”: alias -&gt; _byte, _long, int, …… 引用类, 类型转小写： alias -&gt; string , byte, date, ….. typeHandlers 类型处理器 Mybaties 3.4以前的版本需要我们手动注册这些处理, 以后的版本都是自动注册的 123&lt;typeHandlers&gt; &lt;typeHandler handler="org.apache.ibatis.type.IntegerTypeHandler"/&gt; &lt;/typeHandlers&gt; plugins(插件) Execotor ParamterHandler ResultSetHandler StatementHandler environments：环境们，mybatis可以配置多种环境 ,default指定使用某种环境。可以达到快速切换环境。environment：配置一个具体的环境信息；必须有两个标签；id代表当前环境的唯一标识 transactionManager：事务管理器； type：事务管理器的类型;JDBC(JdbcTransactionFactory)|MANAGED(ManagedTransactionFactory) 自定义事务管理器：实现TransactionFactory接口.type指定为全类名 dataSource：数据源; type:数据源类型;UNPOOLED(UnpooledDataSourceFactory) |POOLED(PooledDataSourceFactory) |JNDI(JndiDataSourceFactory) 自定义数据源：实现DataSourceFactory接口，type是全类名 databaseIdProvider 支持多数据库厂商的 type=”DB_VENDOR”：VendorDatabaseIdProvider 作用就是得到数据库厂商的标识(驱动getDatabaseProductName())，mybatis就能根据数据库厂商标识来执行不同的sql; MySQL，Oracle，SQL Server,xxxx 使用： mybaties-config 切换要配置环境 &amp;&amp; sql映射文件中添加 databaseId=”mysql” 标识使用数据库类型 1234567891011121314151617mybaties-config.xml:&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;!-- 为不同的数据库厂商起别名 --&gt; &lt;property name="MySQL" value="mysql"/&gt; &lt;property name="Oracle" value="oracle"/&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;/databaseIdProvider&gt; EmployeeMapper.xml: &lt;select id="getEmpById" resultType="com.atguigu.mybatis.bean.Employee" databaseId="mysql"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; mappers mapper:注册一个sql映射 注册配置文件 resource：引用类路径下的sql映射文件 mybatis/mapper/EmployeeMapper.xml url：引用网路路径或者磁盘路径下的sql映射文件 file:///var/mappers/AuthorMapper.xml 注册接口 class：引用（注册）接口， 1、有sql映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下； 2、没有sql映射文件，所有的sql都是利用注解写在接口上; 推荐： 比较重要的，复杂的Dao接口我们来写sql映射文件 不重要，简单的Dao接口为了开发快速可以使用注解； 批量注册： 简单的 CRUD 1、mybatis允许增删改直接定义以下类型返回值 Integer、Long、Boolean、void 2、我们需要手动提交数据 sqlSessionFactory.openSession();===》手动提交 sqlSessionFactory.openSession(true);===》自动提交 3.mapper.xml文件中 parameterType 可以省略 123456789101112&lt;select id="getEmpById" resultType="com.aqqje.mybaties.beans.Employee"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertEmp" parameterType="com.aqqje.mybaties.beans.Employee"&gt; insert into tbl_employee(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; &lt;update id="updateEmpById" &gt; update tbl_employee set last_name = #&#123;lastName&#125;, gender = #&#123;gender&#125;, email = #&#123;email&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="deletEmpById"&gt; delete from tbl_employee where id = #&#123;id&#125; &lt;/delete&gt; 参数处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143单个参数：mybatis不会做特殊处理， #&#123;参数名/任意名&#125;：取出参数值。 多个参数：mybatis会做特殊处理。 多个参数会被封装成 一个map， key：param1...paramN,或者参数的索引也可以 value：传入的参数值 #&#123;&#125;就是从map中获取指定的key的值； 异常： org.apache.ibatis.binding.BindingException: Parameter &apos;id&apos; not found. Available parameters are [1, 0, param1, param2] 操作： 方法：public Employee getEmpByIdAndLastName(Integer id,String lastName); 取值：#&#123;id&#125;,#&#123;lastName&#125;【命名参数】：明确指定封装参数时map的key；@Param(&quot;id&quot;) 多个参数会被封装成 一个map， key：使用@Param注解指定的值 value：参数值 #&#123;指定的key&#125;取出对应的参数值POJO：如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo； #&#123;属性名&#125;：取出传入的pojo的属性值 Map：如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map #&#123;key&#125;：取出map中对应的值TO：如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象Page&#123; int index; int size;&#125;========================思考================================ public Employee getEmp(@Param(&quot;id&quot;)Integer id,String lastName); 取值：id==&gt;#&#123;id/param1&#125; lastName==&gt;#&#123;param2&#125;public Employee getEmp(Integer id,@Param(&quot;e&quot;)Employee emp); 取值：id==&gt;#&#123;param1&#125; lastName===&gt;#&#123;param2.lastName/e.lastName&#125;##特别注意：如果是Collection（List、Set）类型或者是数组， 也会特殊处理。也是把传入的list或者数组封装在map中。 key：Collection（collection）,如果是List还可以使用这个key(list) 数组(array)public Employee getEmpById(List&lt;Integer&gt; ids); 取值：取出第一个id的值： #&#123;list[0]&#125; ========================结合源码，mybatis怎么处理参数==========================总结：参数多时会封装map，为了不混乱，我们可以使用@Param来指定封装时使用的key；#&#123;key&#125;就可以取出map中的值；(@Param(&quot;id&quot;)Integer id,@Param(&quot;lastName&quot;)String lastName);ParamNameResolver解析参数封装map的；//1、names：&#123;0=id, 1=lastName&#125;；构造器的时候就确定好了 确定流程： 1.获取每个标了param注解的参数的@Param的值：id，lastName； 赋值给name; 2.每次解析一个参数给map中保存信息：（key：参数索引，value：name的值） name的值： 标注了param注解：注解的值 没有标注： 1.全局配置：useActualParamName（jdk1.8）：name=参数名 2.name=map.size()；相当于当前元素的索引 &#123;0=id, 1=lastName,2=2&#125; args【1，&quot;Tom&quot;,&apos;hello&apos;】:public Object getNamedParams(Object[] args) &#123; final int paramCount = names.size(); //1、参数为null直接返回 if (args == null || paramCount == 0) &#123; return null; //2、如果只有一个元素，并且没有Param注解；args[0]：单个参数直接返回 &#125; else if (!hasParamAnnotation &amp;&amp; paramCount == 1) &#123; return args[names.firstKey()]; //3、多个元素或者有Param标注 &#125; else &#123; final Map&lt;String, Object&gt; param = new ParamMap&lt;Object&gt;(); int i = 0; //4、遍历names集合；&#123;0=id, 1=lastName,2=2&#125; for (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123; //names集合的value作为key; names集合的key又作为取值的参考args[0]:args【1，&quot;Tom&quot;】: //eg:&#123;id=args[0]:1,lastName=args[1]:Tom,2=args[2]&#125; param.put(entry.getValue(), args[entry.getKey()]); // add generic param names (param1, param2, ...)param //额外的将每一个参数也保存到map中，使用新的key：param1...paramN //效果：有Param注解可以#&#123;指定的key&#125;，或者#&#123;param1&#125; final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1); // ensure not to overwrite parameter named with @Param if (!names.containsValue(genericParamName)) &#123; param.put(genericParamName, args[entry.getKey()]); &#125; i++; &#125; return param; &#125; &#125;&#125;===========================参数值的获取======================================#&#123;&#125;：可以获取map中的值或者pojo对象属性的值；$&#123;&#125;：可以获取map中的值或者pojo对象属性的值；select * from tbl_employee where id=$&#123;id&#125; and last_name=#&#123;lastName&#125;Preparing: select * from tbl_employee where id=2 and last_name=? 区别： #&#123;&#125;:是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入 $&#123;&#125;:取出的值直接拼装在sql语句中；会有安全问题； 大多情况下，我们去参数的值都应该去使用#&#123;&#125;； 原生jdbc不支持占位符的地方我们就可以使用$&#123;&#125;进行取值 比如分表、排序。。。；按照年份分表拆分 select * from $&#123;year&#125;_salary where xxx; select * from tbl_employee order by $&#123;f_name&#125; $&#123;order&#125;#&#123;&#125;:更丰富的用法： 规定参数的一些规则： javaType、 jdbcType、 mode（存储过程）、 numericScale、 resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）； jdbcType通常需要在某种特定的条件下被设置： 在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）； JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理; 由于全局配置中：jdbcTypeForNull=OTHER；oracle不支持；两种办法 1、#&#123;email,jdbcType=OTHER&#125;; 2、jdbcTypeForNull=NULL &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;/&gt; 获取自增主键的值：mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGenreatedKeys()； useGeneratedKeys=&quot;true&quot;；使用自增主键获取主键值策略 keyProperty；指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给javaBean的哪个属性 123&lt;insert id="insertEmp" parameterType="com.aqqje.mybaties.beans.Employee" useGeneratedKeys="true" keyProperty="id"&gt; insert into tbl_employee(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; 获取非自增主键的值：Oracle不支持自增；Oracle使用序列来模拟自增； 每次插入的数据的主键是从序列中拿到的值；如何获取到这个值； keyProperty:查出的主键值封装给javaBean的哪个属性 order=&quot;BEFORE&quot;:当前sql在插入sql之前运行 AFTER：当前sql在插入sql之后运行 resultType:查出的数据的返回值类型 BEFORE运行顺序： 先运行selectKey查询id的sql；查出id值封装给javaBean的id属性 在运行插入的sql；就可以取出id属性对应的值 AFTER运行顺序： 先运行插入的sql（从序列中取出新值作为id）； 再运行selectKey查询id的sql； 123456789101112131415&lt;insert id="addEmp" databaseId="oracle"&gt; &lt;selectKey keyProperty="id" order="BEFORE" resultType="Integer"&gt; &lt;!-- BEFORE--&gt; select EMPLOYEES_SEQ.nextval from dual &lt;!-- AFTER： select EMPLOYEES_SEQ.currval from dual --&gt; &lt;/selectKey&gt; &lt;!-- BEFORE:--&gt; insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) values(#&#123;id&#125;,#&#123;lastName&#125;,#&#123;email&lt;!-- ,jdbcType=NULL --&gt;&#125;) &lt;!-- AFTER： insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) values(employees_seq.nextval,#&#123;lastName&#125;,#&#123;email&#125;) --&gt;&lt;/insert&gt; resultMap:自定义结果集映射规则1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!--自定义某个javaBean的封装规则type：自定义规则的Java类型id:唯一id方便引用 --&gt;&lt;resultMap id="myMap" type="com.aqqje.mybaties.beans.Employee"&gt; &lt;!--指定主键列的封装规则 id定义主键会底层有优化； column：指定哪一列 property：指定对应的javaBean属性 --&gt; &lt;id column="id" property="id"/&gt; &lt;!-- 定义普通列封装规则 --&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;!-- 其他不指定的列会自动封装：我们只要写resultMap就把全部的映射规则都写上。 --&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;/resultMap&gt;&lt;!-- 联合查询： 1.支持级联属性封装对象 2.使用 association--&gt;&lt;resultMap id="mydifMap" type="com.aqqje.mybaties.beans.Employee"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;!--&lt;result column="did" property="department.id"/&gt; &lt;result column="name" property="department.name"/&gt;--&gt; &lt;association property="department" javaType="com.aqqje.mybaties.beans.Department"&gt; &lt;id column="did" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;/association&gt;&lt;!-- 使用association进行分步查询： 1、先按照员工id查询员工信息 2、根据查询员工信息中的d_id值去部门表查出部门信息 3、部门设置到员工中；--&gt;&lt;resultMap id="mydifMap" type="com.aqqje.mybaties.beans.Employee"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;!-- association定义关联对象的封装规则 select:表明当前属性是调用select指定的方法查出的结果 column:指定将哪一列的值传给这个方法 流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性 --&gt; &lt;association property="department" select="com.aqqje.mybaties.dao.DepartmentMapper.getDeptById" column="did"/&gt; &lt;/resultMap&gt; 分步延迟加载设置12345&lt;!--显示的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题 --&gt; &lt;!-- 开启加载 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 关闭全加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; collection标签定义关联的集合类型12345678910111213141516171819202122232425262728293031323334353637&lt;!--嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则 --&gt;&lt;resultMap id="deptListMap" type="com.aqqje.mybaties.beans.Department"&gt; &lt;id column="deptid" property="id"/&gt; &lt;result column="deptname" property="name"/&gt; &lt;!-- collection定义关联集合类型的属性的封装规则 ofType:指定集合里面元素的类型 --&gt; &lt;collection property="employeeList" ofType="com.aqqje.mybaties.beans.Employee"&gt; &lt;!-- 定义这个集合中元素的封装规则 --&gt; &lt;id column="empid" property="id"/&gt; &lt;result column="empname" property="lastName"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="getDeptByIdPlus" resultMap="deptListMap"&gt; SELECT d.id deptid, d.id deptname, e.id empid, e.last_name empname, e.email, e.gender FROM tbl_dept d LEFT JOIN tbl_employee e ON e.dept_id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 扩展：多列的值传递过去： 将多列的值封装map传递； column="&#123;key1=column1,key2=column2&#125;" fetchType="lazy"：表示使用延迟加载； - lazy：延迟 - eager：立即 --&gt; &lt;collection property="emps" select="com.atguigu.mybatis.dao.EmployeeMapperPlus.getEmpsByDeptId" column="&#123;deptId=id&#125;" fetchType="lazy"&gt;&lt;/collection&gt; 鉴别器mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为 1234567891011121314151617181920212223242526272829303132&lt;!--封装Employee： 如果查出的是女生：就把部门信息查询出来，否则不查询； 如果是男生，把last_name这一列的值赋值给email; --&gt; &lt;resultMap id="mydifMap" type="com.aqqje.mybaties.beans.Employee"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;!-- column：指定判定的列名 javaType：列值对应的java类型 --&gt; &lt;discriminator column="gender" javaType="string" &gt; &lt;!--女生 resultType:指定封装的结果类型；不能缺少。/resultMap--&gt; &lt;case value="0" resultType="com.aqqje.mybaties.beans.Employee"&gt; &lt;association property="department" select="com.aqqje.mybaties.dao.DepartmentMapper.getDeptById" column="did"/&gt; &lt;/case&gt; &lt;!--男生 ;如果是男生，把last_name这一列的值赋值给email; --&gt; &lt;case value="1" resultType="com.aqqje.mybaties.beans.Employee"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="last_name" property="lastName"/&gt; &lt;result column="last_name" property="email"/&gt; &lt;result column="gender" property="gender"/&gt; &lt;association property="department" select="com.aqqje.mybaties.dao.DepartmentMapper.getDeptById" column="did"/&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; mybaties 动态sqL• if:判断• choose (when, otherwise):分支选择；带了break的swtich-case 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个• trim 字符串截取(where(封装查询条件), set(封装修改条件))• foreach 遍历集合 if:判断 1234567891011121314151617181920212223242526272829303132&lt;!-- 查询员工，要求，携带了哪个字段查询条件就带上这个字段的值 --&gt;&lt;select id="getEmpList" resultMap="mydifMap"&gt; SELECT * FROM tbl_employee &lt;where&gt; &lt;!-- test：判断表达式（OGNL） OGNL参照PPT或者官方文档。 c:if test 从参数中取值进行判断 遇见特殊符号应该去写转义字符： &amp;&amp;： --&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test="lastName !=null and lastName!=''"&gt; and last_name=#&#123;lastName&#125; &lt;/if&gt; &lt;if test="email!=null and email.trim()!=''"&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;!-- ognl会进行字符串与数字的转换判断 "0"==0 --&gt; &lt;if test="gender == 0 or gender ==1"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 查询的时候如果某些条件没带可能sql拼装会有问题 1、给where后面加上1=1，以后的条件都and xxx. 2、mybatis使用where标签来将所有的查询条件包括在内。mybatis就会将where标签中拼装的sql，多出来的and或者or去掉 where只会去掉第一个多出来的and或者or。--&gt; trim 12345678910111213141516171819202122232425262728&lt;!-- 后面多出的and或者or where标签不能解决 prefix="":前缀：trim标签体中是整个字符串拼串 后的结果。 prefix给拼串后的整个字符串加一个前缀 prefixOverrides="": 前缀覆盖： 去掉整个字符串前面多余的字符 suffix="":后缀 suffix给拼串后的整个字符串加一个后缀 suffixOverrides="" 后缀覆盖：去掉整个字符串后面多余的字符 --&gt;&lt;select id="getEmpList" resultMap="mydifMap"&gt; SELECT * FROM tbl_employee &lt;trim prefix="where" suffixOverrides="and"&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test="lastName !=null and lastName!=''"&gt; and last_name=#&#123;lastName&#125; &lt;/if&gt; &lt;if test="email!=null and email.trim()!=''"&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;if test="gender == 0 or gender ==1"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; choose 1234567891011121314151617181920&lt;select id="getEmpList" resultMap="mydifMap"&gt; select * from tbl_employee &lt;where&gt; &lt;!-- 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个 --&gt; &lt;choose&gt; &lt;when test="id!=null"&gt; id=#&#123;id&#125; &lt;/when&gt; &lt;when test="lastName!=null"&gt; last_name like #&#123;lastName&#125; &lt;/when&gt; &lt;when test="email!=null"&gt; email = #&#123;email&#125; &lt;/when&gt; &lt;otherwise&gt; gender = 0 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; Set标签的使用 12345678910111213141516171819&lt;update id="updateEmpSet" &gt; update tbl_employee &lt;set&gt; &lt;if test="lastName !=null and = lastName != ''"&gt; last_name=#&#123;lastName&#125;, &lt;/if&gt; &lt;if test="email!=null and email.trim()!=''"&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test="gender == 0 or gender ==1"&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/set&gt; &lt;where&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;/where&gt; &lt;/update&gt; foreach 12345678910111213141516171819&lt;!-- collection：指定要遍历的集合： list类型的参数会特殊处理封装在map中，map的key就叫list item：将当前遍历出的元素赋值给指定的变量 separator:每个元素之间的分隔符 open：遍历出所有结果拼接一个开始的字符 close:遍历出所有结果拼接一个结束的字符 index:索引。遍历list的时候是index就是索引，item就是当前值 遍历map的时候index表示的就是map的key，item就是map的值 #&#123;变量名&#125;就能取出变量的值也就是当前遍历出的元素--&gt;&lt;select id="getEmpForEach" resultMap="mydifMap"&gt; select id, last_name, email, gender, dept_id did from tbl_employee where id in &lt;foreach collection="ids" separator="," item="emp_id" open="(" close=")"&gt; #&#123;emp_id&#125; &lt;/foreach&gt; &lt;/select&gt; 批量新增 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!-- 批量保存 --&gt; &lt;!--public void addEmps(@Param("emps")List&lt;Employee&gt; emps); --&gt; &lt;!--MySQL下批量保存：可以foreach遍历 mysql支持values(),(),()语法--&gt;&lt;!--&lt;insert id="insertList"&gt; INSERT INTOtbl_employee (last_name, gender, email, dept_id)VALUES&lt;foreach collection="emps" item="emps" separator=","&gt; (#&#123;emps.lastName&#125; ,#&#123;emps.gender&#125;, #&#123;emps.email&#125;, #&#123;emps.department.id&#125;) &lt;/foreach&gt; &lt;/insert&gt;--&gt; &lt;insert id="insertList"&gt; &lt;foreach collection="emps" item="emps" separator=";"&gt; INSERT INTO tbl_employee (last_name, gender, email, dept_id) VALUES (#&#123;emps.lastName&#125; ,#&#123;emps.gender&#125;, #&#123;emps.email&#125;, #&#123;emps.department.id&#125;) &lt;/foreach&gt; &lt;/insert&gt;&lt;!-- 这种方式需要数据库连接属性allowMultiQueries=true； 这种分号分隔多个sql可以用于其他的批量操作（删除，修改） --&gt; &lt;!-- &lt;insert id="addEmps"&gt; &lt;foreach collection="emps" item="emp" separator=";"&gt; insert into tbl_employee(last_name,email,gender,d_id) values(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt; &lt;/insert&gt; --&gt; &lt;!-- Oracle数据库批量保存： Oracle不支持values(),(),() Oracle支持的批量方式 1、多个insert放在begin - end里面 begin insert into employees(employee_id,last_name,email) values(employees_seq.nextval,'test_001','test_001@atguigu.com'); insert into employees(employee_id,last_name,email) values(employees_seq.nextval,'test_002','test_002@atguigu.com'); end; 2、利用中间表： insert into employees(employee_id,last_name,email) select employees_seq.nextval,lastName,email from( select 'test_a_01' lastName,'test_a_e01' email from dual union select 'test_a_02' lastName,'test_a_e02' email from dual union select 'test_a_03' lastName,'test_a_e03' email from dual ) --&gt; &lt;insert id="addEmps" databaseId="oracle"&gt; &lt;!-- oracle第一种批量方式 --&gt; &lt;!-- &lt;foreach collection="emps" item="emp" open="begin" close="end;"&gt; insert into employees(employee_id,last_name,email) values(employees_seq.nextval,#&#123;emp.lastName&#125;,#&#123;emp.email&#125;); &lt;/foreach&gt; --&gt; &lt;!-- oracle第二种批量方式 --&gt; insert into employees( &lt;!-- 引用外部定义的sql --&gt; &lt;include refid="insertColumn"&gt; &lt;property name="testColomn" value="abc"/&gt; &lt;/include&gt; ) &lt;foreach collection="emps" item="emp" separator="union" open="select employees_seq.nextval,lastName,email from(" close=")"&gt; select #&#123;emp.lastName&#125; lastName,#&#123;emp.email&#125; email from dual &lt;/foreach&gt; &lt;/insert&gt; _parameter || _databaseId || bind12345678910111213141516171819202122232425262728&lt;!-- 两个内置参数： 不只是方法传递过来的参数可以被用来判断，取值。。。 mybatis默认还有两个内置参数： _parameter:代表整个参数 单个参数：_parameter就是这个参数 多个参数：参数会被封装为一个map；_parameter就是代表这个map _databaseId:如果配置了databaseIdProvider标签。 _databaseId就是代表当前数据库的别名oracle--&gt;select id="getEmpdatabaseId" resultMap="mydifMap"&gt; &lt;!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值 --&gt; &lt;!-- &lt;bind name="_lastName" value="'%'+lastName+'%'"/&gt; --&gt; &lt;if test="_databaseId == 'mysql'"&gt; select id, last_name, email, gender, dept_id did from tbl_employee &lt;if test="_parameter!=null"&gt; where id = #&#123;_parameter.id&#125; &lt;!-- where last_name = #&#123;_lastName&#125; -&gt; &lt;/if&gt; &lt;/if&gt; &lt;if test="_databaseId == 'oracle'"&gt; select id, last_name, email, gender, dept_id did from tbl_employee &lt;if test="_parameter!=null"&gt; where id = #&#123;_parameter.id&#125; &lt;/if&gt; &lt;/if&gt; &lt;/select&gt; sql 标签 12345678910111213141516171819202122抽取可重用的sql片段。方便后面引用 1、sql抽取：经常将要查询的列名，或者插入用的列名抽取出来方便引用 2、include来引用已经抽取的sql： 3、include还可以自定义一些property，sql标签内部就能使用自定义的属性 include-property：取值的正确方式$&#123;prop&#125;, #&#123;不能使用这种方式&#125; &lt;sql id="selectColumn"&gt; &lt;if test="_databaseId == 'mysql'"&gt; id, last_name, email, gender,$&#123;dept_id&#125; &lt;/if&gt; &lt;/sql&gt; &lt;select id="getEmpdatabaseId" resultMap="mydifMap"&gt; &lt;if test="_databaseId == 'mysql'"&gt; select dept_id did &lt;include refid="selectColumn"&gt; &lt;property name="dept_id" value="did"/&gt; &lt;/include&gt; from tbl_employee &lt;/if&gt; &lt;/select&gt; mybaties 缓存机制 两级缓存： 一级缓存：（本地缓存）：sqlSession级别的缓存。一级缓存是一直开启的；SqlSession级别的一个Map 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库； 一级缓存失效情况（没有使用到当前一级缓存的情况，效果就是，还需要再向数据库发出查询）： 1、sqlSession不同。 2、sqlSession相同，查询条件不同.(当前一级缓存中还没有这个数据) 3、sqlSession相同，两次查询之间执行了增删改操作(这次增删改可能对当前数据有影响) 4、sqlSession相同，手动清除了一级缓存（缓存清空） 二级缓存：（全局缓存）：基于namespace级别的缓存：一个namespace对应一个二级缓存： 工作机制： 1、一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中； 2、如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容； 3、sqlSession===EmployeeMapper==&gt;Employee DepartmentMapper===&gt;Department 不同namespace查出的数据会放在自己对应的缓存中（map） 效果：数据会从二级缓存中获取 查出的数据都会被默认先放在一级缓存中。 只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中 使用： 1）、开启全局二级缓存配置： 2）、去mapper.xml中配置使用二级缓存： 3）、我们的POJO需要实现序列化接口 和缓存有关的设置/属性： 1）、cacheEnabled=true：false：关闭缓存（二级缓存关闭）(一级缓存一直可用的) 2）、每个select标签都有useCache=”true”： false：不使用缓存（一级缓存依然使用，二级缓存不使用） 3）、【每个增删改标签的：flushCache=”true”：（一级二级都会清除）】 增删改执行完成后就会清楚缓存； 测试：flushCache=”true”：一级缓存就清空了；二级也会被清除； 查询标签：flushCache=”false”： 如果flushCache=true;每次查询之后都会清空缓存；缓存是没有被使用的； 4）、sqlSession.clearCache();只是清楚当前session的一级缓存； 5）、localCacheScope：本地缓存作用域：（一级缓存SESSION）；当前会话的所有数据保存在会话缓存中； STATEMENT：可以禁用一级缓存； 第三方缓存整合： 1）、导入第三方缓存包即可； mybatis-ehcache-1.0.3.jar, slf4j-api-1.6.1.jar, slf4j-log4j12-1.6.2.jar 2）、导入与第三方缓存整合的适配包；官方有； 3）、mapper.xml中使用自定义缓存 &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt; 1234567891011121314151617181920&lt;!-- &lt;cache eviction="FIFO" flushInterval="60000" readOnly="false" size="1024"&gt;&lt;/cache&gt; --&gt;&lt;!-- eviction:缓存的回收策略： • LRU – 最近最少使用的：移除最长时间不被使用的对象。 • FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 • SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 • WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 • 默认的是 LRU。flushInterval：缓存刷新间隔 缓存多长时间清空一次，默认不清空，设置一个毫秒值readOnly:是否只读： true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快 false：非只读：mybatis觉得获取的数据可能会被修改。 mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢size：缓存存放多少元素；type=""：指定自定义缓存的全类名； 实现Cache接口即可；--&gt; ssm 整合：web 配置： 1.spring mvc 2.spring IoC 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;MyBatis_06_ssm&lt;/display-name&gt; &lt;!--Spring配置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- SpringMVC配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; springmvc 配置： 1. 扫描控制器 2. 视图解析器 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!--SpringMVC只是控制网站跳转逻辑 --&gt; &lt;!-- 只扫描控制器 --&gt; &lt;context:component-scan base-package="com.atguigu.mybatis" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; mybaties 配置： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;setting name="jdbcTypeForNull" value="NULL"/&gt; &lt;!--显式的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings&gt; &lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MySQL" value="mysql"/&gt; &lt;property name="Oracle" value="oracle"/&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;/databaseIdProvider&gt; &lt;/configuration&gt; spring 配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- Spring希望管理所有的业务逻辑组件，等。。。 --&gt; &lt;context:component-scan base-package="com.atguigu.mybatis"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- 引入数据库的配置文件 --&gt; &lt;context:property-placeholder location="classpath:dbconfig.properties" /&gt; &lt;!-- Spring用来控制业务逻辑。数据源、事务控制、aop --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring事务管理 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启基于注解的事务 --&gt; &lt;tx:annotation-driven transaction-manager="dataSourceTransactionManager"/&gt; &lt;!-- 整合mybatis 目的：1、spring管理所有组件。mapper的实现类。 service==&gt;Dao @Autowired:自动注入mapper； 2、spring用来管理事务，spring声明式事务 --&gt; &lt;!--创建出SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- configLocation指定全局配置文件的位置 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!--mapperLocations: 指定mapper文件的位置--&gt; &lt;property name="mapperLocations" value="classpath:mybatis/mapper/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置一个可以进行批量执行的sqlSession --&gt; &lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactoryBean"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="executorType" value="BATCH"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 扫描所有的mapper接口的实现，让这些mapper能够自动注入； base-package：指定mapper接口的包名 --&gt; &lt;mybatis-spring:scan base-package="com.atguigu.mybatis.dao"/&gt; &lt;!-- &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.atguigu.mybatis.dao"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;/beans&gt; dbconfig.properties: 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=truejdbc.username=rootjdbc.password=123456 测试 mybaties 逆向工程jar包: mybatis-generator-core-1.3.2.jar 编写 mbg 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime="MyBatis3Simple":生成简单版的CRUD MyBatis3:豪华版 --&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;!-- --&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator：指定javaBean的生成策略 targetPackage="test.model"：目标包名 targetProject="\MBGTestProject\src"：目标工程 --&gt; &lt;javaModelGenerator targetPackage="com.aqqje.mybatis.bean" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator：sql映射生成策略： --&gt; &lt;sqlMapGenerator targetPackage="com.aqqje.mybatis.dao" targetProject=".\conf"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.aqqje.mybatis.dao" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表：根据表要创建javaBean --&gt; &lt;table tableName="tbl_dept" domainObjectName="Department"&gt;&lt;/table&gt; &lt;table tableName="tbl_employee" domainObjectName="Employee"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;``` - 测试：```javapackage com.aqqje.mybatis.test;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import com.aqqje.mybatis.bean.Employee;import com.aqqje.mybatis.bean.EmployeeExample;import com.aqqje.mybatis.bean.EmployeeExample.Criteria;import com.aqqje.mybatis.dao.EmployeeMapper;/*import com.aqqje.mybatis.bean.Employee;import com.aqqje.mybatis.dao.EmployeeMapper;*/public class MyBatisTest &#123; public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = "mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testMbg() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("mbg.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; @Test public void testMyBatis3Simple() throws IOException&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try&#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); List&lt;Employee&gt; list = mapper.selectByExample(null); for (Employee employee : list) &#123; System.out.println(employee.getId()); &#125; &#125;finally&#123; openSession.close(); &#125; &#125; @Test public void testMyBatis3() throws IOException&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try&#123; EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); //xxxExample就是封装查询条件的 //1、查询所有 //List&lt;Employee&gt; emps = mapper.selectByExample(null); //2、查询员工名字中有e字母的，和员工性别是1的 //封装员工查询条件的example EmployeeExample example = new EmployeeExample(); //创建一个Criteria，这个Criteria就是拼装查询条件 //select id, last_name, email, gender, d_id from tbl_employee //WHERE ( last_name like ? and gender = ? ) or email like "%e%" Criteria criteria = example.createCriteria(); criteria.andLastNameLike("%e%"); criteria.andGenderEqualTo("1"); Criteria criteria2 = example.createCriteria(); criteria2.andEmailLike("%e%"); example.or(criteria2); List&lt;Employee&gt; list = mapper.selectByExample(example); for (Employee employee : list) &#123; System.out.println(employee.getId()); &#125; &#125;finally&#123; openSession.close(); &#125; &#125;&#125; pageHepler官网详解：pageHepler pageHepler]]></content>
      <tags>
        <tag>mybaties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[ABCCC_VPN]]></title>
    <url>%2F2018%2F05%2F28%2FABCCC-VPN%2F</url>
    <content type="text"><![CDATA[新的一个VPN工具！ 网址：www.abccc.me 流程注册—下载包—配置设置！]]></content>
      <categories>
        <category>VPN</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc]]></title>
    <url>%2F2018%2F05%2F12%2Fspringmvc%2F</url>
    <content type="text"><![CDATA[spring MVC 学习笔记 HelloWorld 配置 web.xml 配置 DispatcherServlet:DispatcherServlet 默认加载 /WEBINF/.xml 的 Spring 配置文件,启动 WEB 层的 Spring 容器 可以通过 contextConfigLocation 初始化参数自定义配置文件的位置和名称 123456789101112131415161718&lt;!--2、springmvc的前端控制器，拦截所有请求 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 使用默认值时可以省略不写 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation 固定参数 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcherServlet-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 创建 Spring MVC 配置文件 dispatcherServlet-servlet.xml 配置自动扫描的包 配置视图解析器12345678 &lt;!--SpringMVC的配置文件，包含网站跳转逻辑的控制，配置 --&gt;&lt;context:component-scan base-package="com.aqqje"&gt;&lt;!--配置视图解析器，方便页面返回 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt; 创建请求处理器类 123456789@Controllerpublic class HelloWord&#123; @RequestMapping("/hellowSpringMVC") public String helloworld()&#123; System.out.println("helloworld..."); return "success"; &#125;&#125; 创建 index.jsp –&gt; HelloWord @RequestMapping 映射请求 注解位置： 1.类定义处：提供初步的请求映射信息。相对于 WEB 应用的根目录 2.方法处：提供进一步的细分映射信息。相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录 @RequestMapping 参数 value:请求 URL –&gt; 注解位置 method:请求方法 PUT GET DELETE POST params:请求参数– param1: 表示请求必须包含名为 param1 的请求参数– !param1: 表示请求不能包含名为 param1 的请求参数– param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1– {“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2的两个请求参数，且 param1 参数的值必须为 value1 heads:请求头的映射条件[支持同 params 参数的简单表达式] 1234567@RequestMapping(value = "testParamsAndHeaders", params = &#123; "username", "age!=10" &#125;, headers = &#123; "Accept-Language=en-US,zh;q=0.8" &#125;) public String testParamsAndHeaders() &#123; System.out.println("testParamsAndHeaders"); return SUCCESS; &#125; Ant 风格资源地址支持 3 种匹配符– ?：匹配文件名中的一个字符– *：匹配文件名中的任意字符– ： 匹配多层路径 Ant 风格的 URL – /user/*/createUser: 匹配/user/aaa/createUser、/user/bbb/createUser 等 URL– /user/**/createUser: 匹配/user/createUser、/user/aaa/bbb/createUser 等 URL– /user/createUser??: 匹配/user/createUseraa、/user/createUserbb 等 URL @PathVariable 映射 URL 绑定的占位符 @PathVariable 可以来映射 URL 中的占位符到目标方法的参数中. 12345@RequestMapping("/testPathVariable/&#123;id&#125;")public String testPathVariable(@PathVariable("id") Integer id) &#123; System.out.println("testPathVariable: " + id); return SUCCESS;&#125; REST (Representational State Transfer)表现层状态转化 具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 1234/order/1 HTTP GET ：得到 id = 1 的 order /order/1 HTTP DELETE：删除 id = 1的 order /order/1 HTTP PUT：更新id = 1的 order /order HTTP POST：新增 order 使用 REST 与 HiddenHttpMethodFilter 过滤器共同使用 1234567891011121314151617&lt;!-- 4、使用Rest风格的URI，将页面普通的post请求转为指定的delete或者put请求 --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;HttpPutFormContentFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HttpPutFormContentFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HttpPutFormContentFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; @RequestParam 绑定请求参数值 使用 @RequestParam 可以把请求参数传递给请求方法– value：参数名– required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常 12345678@RequestMapping(value = "/testRequestParam")public String testRequestParam( @RequestParam(value = "username") String un, @RequestParam(value = "age", required = false, defaultValue = "0") int age) &#123; System.out.println("testRequestParam, username: " + un + ", age: " + age); return SUCCESS;&#125; @RequestHeader 绑定请求报头的属性值123456@RequestMapping("/testRequestHeader")public String testRequestHeader( @RequestHeader(value = "Accept-Language") String al) &#123; System.out.println("testRequestHeader, Accept-Language: " + al); return SUCCESS;&#125; @CookieValue 绑定请求中的 Cookie 值12345@RequestMapping("/testCookieValue")public String testCookieValue(@CookieValue("JSESSIONID") String sessionId) &#123; System.out.println("testCookieValue: sessionId: " + sessionId); return SUCCESS;&#125; POJO 对象绑定请求参数值 Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如：dept.deptId、dept.address.tel 等 123456789101112131415161718192021222324252627282930/** * 1. 有 @ModelAttribute 标记的方法, 会在每个目标方法执行之前被 SpringMVC 调用! * 2. @ModelAttribute 注解也可以来修饰目标方法 POJO 类型的入参, 其 value 属性值有如下的作用: * 1). SpringMVC 会使用 value 属性值在 implicitModel 中查找对应的对象, 若存在则会直接传入到目标方法的入参中. * 2). SpringMVC 会一 value 为 key, POJO 类型的对象为 value, 存入到 request 中. */@ModelAttributepublic void getUser(@RequestParam(value="id",required=false) Integer id, Map&lt;String, Object&gt; map)&#123; System.out.println("modelAttribute method"); if(id != null)&#123; //模拟从数据库中获取对象 User user = new User(1, "Tom", "123456", "tom@atguigu.com", 12); System.out.println("从数据库中获取一个对象: " + user); map.put("user", user); &#125;&#125;/** 运行流程: * 1. 执行 @ModelAttribute 注解修饰的方法: 从数据库中取出对象, 把对象放入到了 Map 中. 键为: user * 2. SpringMVC 从 Map 中取出 User 对象, 并把表单的请求参数赋给该 User 对象的对应属性. * 3. SpringMVC 把上述对象传入目标方法的参数. * * 注意: 在 @ModelAttribute 修饰的方法中, 放入到 Map 时的键需要和目标方法入参类型的第一个字母小写的字符串一致! */@RequestMapping("/testModelAttribute")public String testModelAttribute(@ModelAttribute("user") User user)&#123; return SUCCESS;&#125; ModelAndView 既包含视图信息，也包含模型数据信息。 添加模型数据:– MoelAndView addObject(String attributeName, ObjectattributeValue)– ModelAndView addAllObject(Map&lt;String, ?&gt; modelMap) 设置视图:– void setView(View view)– void setViewName(String viewName) Map 及 Model12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@ModelAttribute("user")public User getUser()&#123; User user = new User(); user.setAge(10); return user;&#125;email: $&#123;requestScope.user.email&#125;@RequestMapping("/handle")public String handle(Map&lt;String, Object&gt; map)&#123; map.put("time", new Date()); User user = (User)map.get("user") user.setEmail("aqqje@123.com"); return "success";&#125;time: $&#123;requestScope.time&#125;## @SessionAttributes- @SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外(实际上使用的是 value 属性值),还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中(实际上使用的是 types 属性值) - 注意: 该注解只能放在类的上面. 而不能修饰放方法. - 避免@SessionAttributes引发的异常```java@SessionAttributes("user")@Controllerpublic class UserController&#123; // 该 方法会往隐含模型中添加一个名为 user 的模型属性 @ModelAttribute("user") public User getUser()&#123; User user = new User(); return user; &#125;&#125;## 希望直接响应通过 SpringMVC 渲染的页面，可以使用 mvc:viewcontroller 标签实现```xml &lt;!-- 配置直接转发的页面 --&gt; &lt;!-- 可以直接相应转发的页面, 而无需再经过 Handler 的方法. --&gt; &lt;mvc:view-controller path="/success" view-name="success"/&gt; 配置国际化资源文件123456789i18n.username=Usernamei18n.password=Password&lt;!-- 配置国际化资源文件 --&gt; &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt; &lt;property name="basename" value="i18n"&gt;&lt;/property&gt; &lt;/bean&gt; 重定向 forward: 或 redirect:– redirect:success.jsp：会完成一个到 success.jsp 的重定向的操作– forward:success.jsp：会完成一个到 success.jsp 的转发操作 处理静态资源可以在 SpringMVC 的配置文件中配置 mvc:default-servlethandler/ 的方式解决静态资源的问题 12345678方法一： &lt;!-- 配置静态资源的请求映射关系 --&gt; &lt;mvc:resources location="/resources/" mapping="/resources/**"&gt;&lt;/mvc:resources&gt;方法二：&lt;!-- 将springmvc不能处理的请求交给tomcat --&gt;&lt;mvc:default-servlet-handler/&gt; 处理 JSON 1加入 jar 包 jackson-annotation-x.x.x.jar jackson-core-x.x.x.jar jackson-databind-2.2.2.jar 2编写目标方法，使其返回 JSON 对应的对象或集合 3在方法上添加 @ResponseBody 注解 字符集编码的过滤器(必须放在所有过渡器之前) 1234567891011121314151617&lt;!-- 字符集编码的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;EncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 文件上传 配置 MultipartResolver 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788Controller: //执行新增动作 @RequestMapping(value="/code", method=RequestMethod.POST) public ModelAndView add(@RequestParam("codefile") MultipartFile codefile, @RequestParam("intro") String intro, HttpServletRequest request, HttpSession session)&#123; ModelAndView mv = new ModelAndView(); User loginUser = (User)session.getAttribute("loginUser"); String path = request.getServletContext().getRealPath("/") + "resources\\codefile\\"; CodeService codeService = new CodeService(); Map&lt;String, Object&gt; result = codeService.addCode(codefile, path, loginUser, intro); Boolean isSuccess = (Boolean)result.get("isSuccess"); String message = (String)result.get("message"); if(isSuccess)&#123; mv.setViewName("redirect:/codes"); &#125;else&#123; mv.setViewName("bizzerror"); mv.addObject("message", message); &#125; return mv; &#125; service: public Map&lt;String, Object&gt; addCode(MultipartFile codefile, String path, User loginUser, String intro) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); //文件上传和新增代码的业务逻辑 //将文件存到服务器的指定位置 //1. 路径存在性 //2. 文件名重复的问题 try &#123; if(codefile.getSize() &gt; 0)&#123; String filename = generateFilename(codefile.getOriginalFilename()); if(filename.endsWith(".zip") || filename.endsWith(".rar"))&#123; File file = new File(path, filename); if(!file.getParentFile().exists())&#123; file.getParentFile().mkdir(); &#125; //将上传的文件保存在服务器上的指定目录 codefile.transferTo(file); //向数据库插入一条新的Code数据 //(id=null, codename="codefile.getname()", // filepath="文件存放好之后的位置", // intro=输入的intro // owner="当前登录用户", // addTime="当前系统时间") Code code = new Code(); code.setCodename(codefile.getOriginalFilename()); code.setFilepath("resources/codefile/" + filename ); code.setIntro(intro); code.setOwner(loginUser); code.setAddTime(new Timestamp(System.currentTimeMillis())); CodeDao codeDao = new CodeDao(); codeDao.add(code); result.put("isSuccess", true); result.put("message", "上传成功！"); &#125;else&#123; //类型错误，报错 result.put("isSuccess", false); result.put("message", "必须上传.zip或者.rar文件"); &#125; &#125;else&#123; //空文件，报错 result.put("isSuccess", false); result.put("message", "文件不可为空"); &#125; return result; &#125; catch (Exception e) &#123; e.printStackTrace(); result.put("isSuccess", false); result.put("message", "上传失败"); return result; &#125; &#125; 拦截器 自定义的拦截器必须实现HandlerInterceptor接口 – preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。 如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true； 如果程序员决定不需要再调用其他的组件去处理请求，则返回false。 – postHandle()：这个方法在业务处理器处理完请求后， 但是DispatcherServlet 向客户端返回响应前被调用， 在该方法中对用户请求request进行处理。 – afterCompletion()：这个方法在 DispatcherServlet 完全处理完请求后被调用， 可以在该方法中进行一些资源清理的操作。 springmvc 配置文件中配置自定义的拦截器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950java:/** * 登录检查拦截器 * @author Administrator * */public class LoginInterceptor extends HandlerInterceptorAdapter&#123; public static List&lt;String&gt; URLS = null; static&#123; URLS = new ArrayList&lt;String&gt;(); URLS.add("/codes"); URLS.add("/admin"); URLS.add("/code"); &#125; /** * 执行请求之前进行拦截 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String url = request.getServletPath(); String method = request.getMethod(); if(method.equalsIgnoreCase("GET") &amp;&amp; URLS.contains(url))&#123; if(request.getSession().getAttribute("loginUser") == null)&#123; //未登录状态 //重定向到未登录错误页面 response.sendRedirect("not_login"); return false; &#125;else&#123; //已登录 return true; &#125; &#125;else&#123; return true; &#125; &#125; &#125;xml: &lt;!-- 配置拦截列表 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 配置单个拦截器 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/*"/&gt; &lt;bean id="loginInterceptor" class="com.javaee.scms.interceptors.LoginInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; 异常处理 Spring MVC 通过 HandlerExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常。 -SpringMVC 提供的 HandlerExceptionResolver 的实现类 12345678910111213141516171819202122232425262728293031 public class ExceptionHandler implements HandlerExceptionResolver&#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception) &#123; ModelAndView mv = new ModelAndView(); if(exception instanceof SystemException)&#123; StringBuilder message = new StringBuilder(); message.append("&lt;p&gt;" + exception.getCause().getMessage() + "&lt;/p&gt;"); message.append("&lt;p&gt;请您与管理员联系，您也可以返回&lt;a href='" + request.getContextPath() + "/home'&gt;首页&lt;/a&gt;&lt;/p&gt;"); mv.addObject("message", message.toString()); mv.setViewName("syserror"); &#125;if(exception instanceof BizzException)&#123; StringBuilder message = new StringBuilder(); message.append("&lt;p&gt;" + exception.getMessage() + "&lt;/p&gt;"); message.append("&lt;p&gt;请您与管理员联系，您也可以返回&lt;a href='" + request.getContextPath() + "/home'&gt;首页&lt;/a&gt;&lt;/p&gt;"); mv.addObject("message", message.toString()); mv.setViewName("bizzerror"); &#125;else&#123; StringBuilder message = new StringBuilder(); message.append("&lt;p&gt;发生了未知的异常&lt;/p&gt;"); message.append("&lt;p&gt;请您与管理员联系，您也可以返回&lt;a href='" + request.getContextPath() + "/home'&gt;首页&lt;/a&gt;&lt;/p&gt;"); mv.addObject("message", message.toString()); mv.setViewName("syserror"); &#125; return mv; &#125;&#125;]]></content>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring learn]]></title>
    <url>%2F2018%2F05%2F07%2Fspring-learn%2F</url>
    <content type="text"><![CDATA[Spring Learn Note Spring 是什么简单描述： Spring 是一个开源框架.= Spring 为简化企业级应用开发而生. 使用 Spring 可以使简单的 JavaBean 实现以前只有 EJB 才能实现的功能. Spring 是一个 IOC(DI) 和 AOP 容器框架. 具体描述 Spring: 轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API 依赖注入(DI — dependency injection、IOC)= 面向切面编程(AOP — aspect oriented programming)= 容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期= 框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC） Spring HelloWord 创建 javaBean 类 123456789101112public class HelloWord &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public void hello() &#123; System.out.println("Hello:" + name); &#125;&#125; 新建 Spring IoC 容器 applicationContext.xml,并配置相应的 Bean 123&lt;bean id="helloWord" class="aqqje.com.beans.HelloWord"&gt; &lt;property name="name" value="aqqje" /&gt;&lt;/bean&gt; 编写测试类 1234567891011// 创建 spring IoC 的容器对象ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");// 从容器中获取 bean// 利用 id 定位容器中的 bean 推荐使用HelloWord hw = (HelloWord)context.getBean("helloWord");// 调用 hello()// 利用 id 定位容器中的 bean 推荐使用//HelloWord hw = (HelloWord)context.getBean("helloWord");// 利用 类型返回容器中的 bean 要求：容器只一个该类型的 bean//HelloWord hw = (HelloWord)context.getBean(HelloWord.class);hw.hello(); Spring IoC 容器 Bean 的配置 id : Bean 的名字 在 IOC 容器中必须是唯一的 若 id 没有指定，Spring 自动将权限定性类名作为 Bean 的名字 id 可以指定多个名字，名字之间可用逗号、分号、或空格分隔 class: Bean 本身的类名 1.必须为全类名 ref: 指向引用 Bean 的名字 1.可以引用外部的 Bean 2.可以创建内部 Bean 3.内部创建的 Bean 只能内部使用, 不能其他外部 Bean 引用 123456789101112&lt;property name="persion"&gt; &amp;lt;!&amp;ndash; 内部Bean, 注意：不能被外部 Bean 引用, 只能在内部使用 &amp;ndash;&amp;gt; &lt;bean class="aqqje.com.beans.Persion"&gt; &lt;constructor-arg value="aqqje" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;男&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="double"&gt; &lt;value&gt;20000.0&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/property&gt; : 构造器注入 1. value 属性为 bean 的构造器的实参值，为值的内容字符形式 2. 定位(index=&quot;0&quot; 或 type=&quot;aqqje.com.beans.Persion&quot; 两者可以混用) ,即指定 value 的类型 字面值：可用字符串表示的值 1.可以使用 &lt;value&gt; 元素标签 或 value 属性进行注入 2.基本数据类型及其封装类, Stirng 等类型都可以采取字面值注入的方式 3.若字面值包含特殊字符，可以使用&lt;![CDATA[]]&gt;把字面值包裹 123456789101112131415&lt;bean id="persion2" class="aqqje.com.beans.Persion"&gt; &lt;constructor-arg value="aqqje" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;男&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="double"&gt; &lt;value&gt;500.0&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;``` - &lt;null/&gt; : 可以使用专用的 &lt;null/&gt; 元素标签为 Bean 的字符串或其它对象类型的属性注入null 值```xml&lt;property name="persion"&gt;&lt;null/&gt;&lt;/property&gt; 级联：spring 支持级联属性: 级联属性赋值 注意：属性需要先初始化，才能级联属性赋值, 否则将抛出异常 1&lt;property name="persion.name" value="love" /&gt; 集合属性 ：List &amp;&amp; Set || Map 1.使用 list 节点为 List 类型属性赋值 123456789&lt;property name="persion"&gt; &lt;!-- Set 类型类似 List --&gt; &lt;list&gt; &lt;ref bean="persion1"/&gt; &lt;ref bean="persion2"/&gt; &lt;/list&gt;&lt;/property&gt; 2.使用 map 节点及 map中的 entry 节点配置 Map 属性的成员变量 123456&lt;property name="persion"&gt; &lt;map&gt; &lt;entry key="aa" value-ref="persion1" /&gt; &lt;entry key="bb" value-ref="persion2" /&gt; &lt;/map&gt;&lt;/property&gt; properties 属性: 1234user=rootpassword=rootdriverClass=com.mysql.jdbc.DriverjdbcUrl=jdbc:mysql:///scms 1234567891011&lt;bean id="dataSource" class="aqqje.com.beans.contollers.DataSource"&gt; &lt;property name="properties"&gt; &lt;!-- 使用 props 和 prop 配置 properties 文件 --&gt; &lt;props&gt; &lt;prop key="driverClass"&gt;com.jdbc.mysql.Driver&lt;/prop&gt; &lt;prop key="jdbcUrl"&gt;jdbc.mysql:///test&lt;/prop&gt; &lt;prop key="user"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 配置单例集合 Bean : util命名空间 以便多个 Bean 引用 : 注意：需要导入 util jar包 123456&lt;util:list id="persions"&gt; &lt;ref bean="persion1" /&gt; &lt;ref bean="persion2" /&gt;&lt;/util:list&gt;&lt;!-- 引用单例集合 Bean --&gt;&lt;property name="persion" ref="persions"/&gt; p 命名空间：可以使用 p 命名空间对 Bean 的属性进行赋值 注意：需要导入 p jar包 ;特点：比较传统的方式更简洁 1&lt;bean id="god5" class="aqqje.com.beans.contollers.God" p:name="Aellen" p:leg="5" p:persion-ref="persions" /&gt; spring Bean 之间的关系 继承：1.1)Bean(子Bean) 可以使用 parent 属性来继承父类的 Bean(父Bean) 1.2)Bean(子Bean) 可以覆盖 Bean(父Bean) 的属性 抽象：2.1)Bean(父Bean) 可以使用 abstract 属性来定义该 Bean 为抽象Bean, 2.2)若一个 Bean 没有指定 Class 属性, 则该 Bean 必须是一个抽象 Bean 2.3)抽象 Bean 的 class 属性可以省略, 如省略 Bean(子Bean) 则必须指定 class 属性,如不省略，Bean(子Bean)则可以省略不指定 2.4)注意：抽象 Bean 不可以被 IoC 容器所实例化 3.依赖：1.1)使用 depends-on 属性指定该 Bean 需要 依赖的 Bean , 被依赖的 Bean 必须要存在(不分先后), 否则将抛出异常 1.2)单单指定 depens-on 属性是不行的, 必须与 p: ref 共同使用 1.3)如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称 1.4)前置依赖的 Bean 会在本 Bean 实例化之前创建好 123456&lt;bean id="adress" class="aqqje.com.relation.Adress" p:city="HuNan" p:street="HengYang" abstract="true"/&gt;&lt;!-- &lt;bean id="adress1" class="aqqje.com.relation.Adress" p:city="HuNan" p:street="XiangTang"/&gt;--&gt;&lt;bean id="adress1" p:city="HuNan" p:street="XiangTang" parent="adress"/&gt;&lt;bean id="persion" class="aqqje.com.relation.Persion" p:name="aqqje" p:car-ref="car" depends-on="car" /&gt;&lt;bean id="car" class="aqqje.com.relation.Car" p:brank="China" p:pirce="6100000" /&gt; spring Bean 作用域: 使用 scope 属性里设置 Bean 的作用域 singleton(单例): 默认值, 在 IoC 容器创建时该 Bean 就被实例化了, 整个 IoC 容器范围内都能共享该 Bean , 生命周期与 IoC 一样长. prototype(原型): 在 IoC 容器创建时该 Bean 不会被实例化, 一到需要使用时调用 getBean() 方法就会实例化一个该 Bean 的对象. request(请求): 每次 Http 请求都会实例化一个 Bean 对象, 该作用仅使用于 WebApplicationContext 环境 session(会议): 同一个 Http session 共享一个 bean , 不同的 Http session 使用不同的 bean, 该作用仅使用于 WebApplicationContext 环境 1&lt;bean id="car" class="aqqje.com.relation.Car" p:brank="Chian" p:pirce="61000.0" scope="prototype" /&gt; Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于 EL：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL SpEL 为 bean 的属性进行动态赋值提供了便利 通过 SpEL 可以实现： 通过 bean 的 id 对 bean 进行引用 调用方法以及引用对象中的属性 计算表达式的值 正则表达式的匹配 字面量的表示： 整数：&lt;property name=&quot;count&quot; value=&quot;#{5}&quot;/&gt; 小数：&lt;property name=&quot;frequency&quot; value=&quot;#{89.7}&quot;/&gt; 科学计数法：&lt;property name=&quot;capacity&quot; value=&quot;#{1e4}&quot;/&gt; String可以使用单引号或者双引号作为字符串的定界符号：&lt;property name=“name” value=&quot;#{&apos;Chuck&apos;}&quot;/&gt; 或 &lt;property name=&apos;name&apos; value=&apos;#{&quot;Chuck&quot;}&apos;/&gt; Boolean：&lt;property name=&quot;enabled&quot; value=&quot;#{false}&quot;/&gt; 引用其他对象 &amp;&amp; 引用其他对象的属性 &amp;&amp; 调用其他方法,还可以链式操作 $$ 支持运算符 &amp;lt;!&amp;ndash; 通过 value 属性和 SpEL 之间的应用关系 &amp;ndash;&amp;gt; &lt;bean id=&quot;persion&quot; class=&quot;aqqje.com.spel.Persion&quot; p:name=&quot;#{car.brank}&quot; p:car=&quot;#{car}&quot; p:adress=&quot;#{adress.city}&quot; p:wage=&quot;#{car.pirce &gt; 3000 ? &apos;金领&apos; : &apos;白领&apos;}&quot; /&gt; 支持运算符： 算数运算符：+, -, *, /, %, ^： 加号还可以用作字符串连接： 比较运算符： &lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge 逻辑运算符号： and, or, not, | if-else 运算符：?: (ternary), ?: (Elvis) if-else 的变体 正则表达式：matches 123&lt;bean id="adress" class="aqqje.com.spel.Adress" p:city="#&#123;'HuNan'&#125;" p:street="softSchool" /&gt;&lt;bean id="car" class="aqqje.com.spel.Car" p:brank="#&#123;'Chinal'&#125;" p:pirce="2000" p:tirecCircumference="#&#123;T(java.lang.Math).PI * 25&#125;" /&gt;&lt;bean id="persion" class="aqqje.com.spel.Persion" p:name="#&#123;car.brank&#125;" p:car="#&#123;car&#125;" p:adress="#&#123;adress.city&#125;" p:wage="#&#123;car.pirce &gt; 3000 ? '金领' : '白领'&#125;" /&gt; IoC 容器中 Bean 的周期： 作用： Spring IOC 容器可以管理 Bean 的生命周期, Spring 允许在 Bean 生命周期的特定点执行定制的任务. 初始 &amp;&amp; 销毁 在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法. Bean 的周期过程： 1.通过构造器或工厂方法创建 Bean 实例 2.为 Bean 的属性设置值和对其他 Bean 的引用 3.调用 Bean 的初始化方法 4.Bean 可以使用了 5.当容器关闭时, 调用 Bean 的销毁方法 Bean 后置处理器： 作用： 1.在调用初始化方法前后对 Bean 进行额外的处理. 2.Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性. 实现: 1.自定义 Bean 后置处理器并实现 BeanPostProcessor 接口 2.初始化方法被调用前后，重写 postProcessAfterInitialixation(...) &amp;&amp; postProcessBeforeInitialixation(...)方法 3.在 spring IoC 容器中配置Bean 后置处理器 添加 Bean 后置处理器中 Bean 的周期过程： 1.通过构造器或工厂方法创建 Bean 实例 2.为 Bean 的属性设置值和对其他 Bean 的引用 3.*将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法* 4.调用 Bean 的初始化方法 5.*将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法* 6.Bean 可以使用了 7.当容器关闭时, 调用 Bean 的销毁方法 12345678// car initpublic void init() &#123; System.out.println("Car init..");&#125;// car destroypublic void destroy() &#123; System.out.println("Car destroy....");&#125; 12345678910111213141516// Bean 后置处理器public class MyPostProcessor implements BeanPostProcessor &#123;@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessBeforeInitialization:" + bean + "," + beanName); return bean;&#125;@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessBeforeInitialization:" + bean + "," + beanName); Car car = new Car(); car.setName("aqqje"); return car;&#125; 1234567891011&lt;bean id="car" class="aqqje.com.lifecycle.Car" p:name="BMWX6" p:price="10000000" init-method="init" destroy-method="destroy"/&gt;&lt;!-- bean : bean 实例本身 beanName: IoC容器配置 的bean 的名字 返回值： 是实际上返回给用户的那个 Bean, 注意：可以在以上两方法中修改返回的 bean, 甚至返回一个新的 bean 配置 bean 的后置处理器： 不需要配置 id , IoC 容器自动识别一个 BeanPostProcessor --&gt;&lt;bean class="aqqje.com.lifecycle.MyPostProcessor" /&gt; 工厂方法创建 Bean 1) 静态工厂方法:直接调用某一个类的静态方法就可以返回一个 bean 实例 12345678910111213public class StaticFactory &#123; private static Map&lt;String, Object&gt; cars = new HashMap&lt;&gt;(); static&#123; cars.put("audi", new Car("adui", 100000)); cars.put("ford", new Car("ford", 400000)); &#125; public static Car getCar(String carName)&#123; return (Car)cars.get(carName); &#125;&#125;` 12345678910&lt;!-- 通过静态工厂方法来配置 bean， 注意不是配置静态工厂实例，而是配置 bean 实例 class 属性：指向静态工厂方法的全类名 factory-method: 指向静态工厂方法的名字 constructor-arg: 如果工厂方法需要传入参数，则使用 constructor-arg 来配置参数 --&gt;&lt;bean id="car" class="aqqje.com.factory.StaticFactory" factory-method="getCar"&gt; &lt;constructor-arg value="ford"/&gt;&lt;/bean&gt; 2) 实例工厂方法: 12345678910111213public class InstaceFactory &#123; private Map&lt;String, Object&gt; cars; public InstaceFactory()&#123; cars = new HashMap&lt;&gt;(); cars.put("audi", new Car("adui", 100000)); cars.put("ford", new Car("ford", 400000)); &#125; public Car getCar(String CarName)&#123; return (Car)cars.get(CarName); &#125;&#125; 1234567891011&lt;!-- factory-bean ：指向实例工厂方法的全类名 factory-method: 指向实例工厂方法的名字 constructor-arg: 如果工厂方法需要传入参数，则使用 constructor-arg 来配置参数 --&gt;&lt;bean id="instaceFactory" class="aqqje.com.factory.InstaceFactory" /&gt;&lt;bean id="car1" factory-bean="instaceFactory" factory-method="getCar"&gt; &lt;constructor-arg value="audi"/&gt;&lt;/bean&gt; 组件装配 context:component-scan 自动注册 AutowiredAnnotationBeanPostProcessor 实例 可以使用 autuwire 属性指定自行装配的方式（不推荐） byName: 根据 bean 的名字和当前 Bean 的 setter 风格的属性名进行自动装配，若有匹配的，则进行自行装配， 若没有就不装配 byType: 根据 bean 的类型和当前 Bean 的 的属性的类型进行自动装配， 注意：byType 使用则该只能是出现 1 次， 若有 2 个及以上的则抛出异常 @Autowired 注解自动装配具有兼容类型的单个 Bean属性 1.构造器, 普通字段(即使是非 public), 一切具有参数的方法都可以应用@Authwired 注解 2.默认情况下, 所有使用 @Authwired 注解的属性都需要被设置. 当 Spring 找不到匹配的 Bean 装配属性时, 会抛出异常, 若某一属性允许不被设置, 可以设置 @Authwired 注解的 required 属性为 false 3.默认情况下, 当 IOC 容器里存在多个类型兼容的 Bean 时, 通过类型的自动装配将无法工作. 此时可以在 @Qualifier 注解里提供 Bean 的名称. Spring 允许对方法的入参标注 @Qualifiter 已指定注入 Bean 的名称 4.@Authwired 注解也可以应用在数组类型的属性上, 此时 Spring 将会把所有匹配的 Bean 进行自动装配. 5.@Authwired 注解也可以应用在集合属性上, 此时 Spring 读取该集合的类型信息, 然后自动装配所有与之兼容的 Bean. 6.@Authwired 注解用在 java.util.Map 上时, 若该 Map 的键值为 String, 那么 Spring 将自动装配与之 Map 值类型兼容的 Bean, 此时 Bean 的名称作为键值 Spring 还支持 @Resource 和 @Inject 注解， 这两个注解和 @Autowired 注解的功用类似 @Resource 注解要求提供一个 Bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称 @Inject 和 @Autowired 注解一样也是按类型匹配注入的 Bean， 但没有 reqired 属性 建议使用 @Autowired 注解 基于注解方式的 aop 加入 jar 包： 与 aop 相关: com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar spring-aspects-4.3.14.RELEASE.jar spring-aop-4.3.14.RELEASE.jar 常用:commons-logging-1.2.jarspring-beans-4.3.14.RELEASE.jarspring-context-4.3.14.RELEASE.jarspring-core-4.3.14.RELEASE.jarspring-expression-4.3.14.RELEASE.jar 在 spring IoC 容器加入 aop 命令空间并加入如下配置: &lt;aop:aspectj-autoproxy /&gt; 把横切关注点的代码抽象到切面的类中 使用 @Component 声明该类是 IoC 容器的一个 Bean 使用 @Aspect 声明该类是一个切面 在切面类声明各种通知： @Before: 前置通知, 在方法执行之前执行 @After: 后置通知, 在方法执行之后执行 [无论是否异常] @AfterRunning: 返回通知, 在方法返回结果之后执行[返回参数 throwing 的值与方法的异常参数名要一致,方法的异常类型可以指定，指定有则执行，无则不执行] @AfterThrowing: 异常通知, 在方法抛出异常之后[异常参数 returning 的值与方法的返回参数名要一致] @Around: 环绕通知, 围绕着方法执行[该相当一个完整的代理过程 与 ProceedingJoinPoint 参数共同使用，并且方法有返回值] 可以在通知方法中声明一个类型为 JoinPoint 的参数，然后就能访问链接细节，如方法名称和参数值 123456789101112131415161718192021@Around(value="declareJointPointExpression()") public Object arounMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getClass().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); Object result = null; try &#123; // 前置通知 System.out.println("The method " + methodName + " with " + args); // 执行方法 result = joinPoint.proceed(); // 返回通知 System.out.println("The method " + methodName + " end " + result); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); // 异常通知 System.out.println("The method " + methodName + " ocrrous thorw " + throwable); &#125; // 后置通知 System.out.println("The method " + methodName + " end " + result); return result; &#125; 最典型的切入点表达式时根据方法的签名来匹配各种方法: execution com.atguigu.spring.ArithmeticCalculator.(..): 匹配 ArithmeticCalculator 中声明的所有方法,第一个 代表任意修饰符及任意返回值. 第二个 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名. execution public ArithmeticCalculator.(..): 匹配 ArithmeticCalculator 接口的所有公有方法. execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法 execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数 execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法. 重用切面关注点表达式: 定义一个方法, 用于声明切入点表达式. 一般地, 该方法中再不需要添入其他的代码. 使用 @Pointcut 来声明切入点表达式. 后面的其他通知直接使用方法名来引用当前的切入点表达式. @Order(int order) 该声明切点类的执行顺序, 参数 order 值越小其执行顺序就越高 基于 IoC 容器配置方式 配置切面 Bean 配置 AOP 配置切面表达式 配置切面及通知 1234567891011121314151617&lt;!-- 配置 Bean --&gt; &lt;bean id="arithmeticCalculator" class="aqqje.com.aspect.xml.ArithmeticCalculatorImpl" /&gt; &lt;!-- 配置切面 Bean --&gt; &lt;bean id="loggingAspect" class="aqqje.com.aspect.xml.LoggingAspect"/&gt; &lt;!-- 配置 AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切点表达式 --&gt; &lt;aop:pointcut id="arithmeticCalculatorPoincut" expression="execution(* aqqje.com.aspect.xml.ArithmeticCalculator.*(..))"/&gt; &lt;!-- 配置通知及切面 --&gt; &lt;aop:aspect ref="loggingAspect" order="1"&gt; &lt;aop:before method="berforeMethod" pointcut-ref="arithmeticCalculatorPoincut"/&gt; &lt;aop:after method="afterMethod" pointcut-ref="arithmeticCalculatorPoincut"/&gt; &lt;aop:after-returning method="afterReturnMethod" pointcut-ref="arithmeticCalculatorPoincut" returning="result"/&gt; &lt;aop:after-throwing method="afterThorwMethod" pointcut-ref="arithmeticCalculatorPoincut" throwing="e"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; spring 事务 声明式事件 配置事务管理器 DataSourceTransactionManager 启用事务管理 transaction-manager 添加事件注解 Transactional 1234567&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;!-- 启用事务管理 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; 事件的传播行为 当一个事务方法被另一个事务方法调用时，必须指定事务应该如何传播 事务的传播行为可以由传播属性指定：spring 定义了 7 种类传播行为 使用 propagation 指定事件的传播行为 Propagation.REQUIRED, 即使用外事务。 REQUIRES_NEW， 即使用内事务，外事务挂起 事务的隔离级别 1.使用 propagation 指定事务的传播行为，即当前事务方法被别处一个事务方法调用时 如何使用事务，默认取值为 REQUIRED， 即使用调用方法的事务 REQUIRES_NEW：事务自己的事务，调用的事务方法的事务被挂起。 使用 isolation 指定事务的隔离级别， 最常用的取值为事务READ_COMMITTED 3.默认情况下 spring 的声明式事务所有的运行时异常进行回滚，也可以通过对应的属性进行设置，通常情况下去默认值即可。 4.使用 readOnly 指定指定事务的是否为只读， 表示这个事务只读取数据但不更新数据 ， 这样可以帮助数据库引擎优化事务， 若真的事一个只读取数据库值的方法， 应设置 readOnly = true 5.使用 timiout 指定强制回滚之前事务可以占用的赶时间 xml形式配置事务 步骤： 1.配置事务管理器 2.配置事务属性 3.配置事务切入点，把事务切入点和事务属性关联起来 12345678910111213141516171819&lt;!-- 配置事务管理器 --&gt;&lt;bean id="tranactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; &lt;!-- 配置事务属性 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="tranactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="purchase" propagation="REQUIRES_NEW"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; &lt;!-- 配置事务切入点，把事务切入点和事务属性关联越来 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id="txPointCut" expression="execution(* aqqje.com.jdbc.txxml.services.BookStockService.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"/&gt;&lt;/aop:config&gt; Spring 如何在 WEB 应用使用? 1) 需要外加的 jar 包: spring-web-xxx.RELEASE.jar spring-webmvc-xxx.RELEASE.jar 2) spring 的配置文件不变 3) 如何创建 IoC 容器? a 非 WEB 应用在 main 方法中直接创建 b 应该在 WEB 应用被服务器加载时就创建 IoC 容器: 在 ServletContextListener#contextInitalized(ServletContextExvent sce) 方法中创建 c 在 WEB 应用的其他组件中如何来访问 IoC 容器? 在 ServletContextListener#contextInitalized(ServletContextExvent sce) 方法中创建后, 可以把其在 ServletContext(即 application 域)的一个属性中 d 实际上, spring 配置文件的名字和位置应该也是可以配置的! 将其配置到时当前 WEB 应用的初始化参数中较为合适 4) 在 WEB 环境下使用 spring 需要在 web.xml 文件中加入如下配置: 12345678910&lt;!-- 配置 Spring 配置文件的名称和位置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 启动 IOC 容器的 ServletContextListener --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;]]></content>
      <tags>
        <tag>java, ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键]]></title>
    <url>%2F2018%2F05%2F03%2FIDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IDEA快捷键 IDEA 中自动生成 get/set 的方式 – alt + insert 操作 快捷键 说明 ctrl + ] 快速跳到代码块的结尾处 ctrl + [ 同上，快速跳到代码块的开始处 ctrl +shift + Enter 将输入的 if, for, 函数等补上 {} 或者 ; 使代码语句完整 shift + Enter 在当前下方开始新行 ctrl + alt + Enter 在当前上方开始新行 ctrl + delete 删除光标所在至单词结尾处的所有字符 ctrl + backSpace 删除光标所在至单词开头的所有字符 ctrl + → 将光标移至前一个单词 ctrl + ← 将光标移至后一个单词 ctrl + ↑ 向下滚动一行 ctrl + ↓ 向上滚动一行 ctrl + w 选中整个单词 ctrl + shift + u 切换大小写 编辑 快捷键 说明 ctrl + shift + j 将选中的行合并成一行 查找 快捷键 说明 ctrl + f 在当前文件中查找 ctrl + r 替换字符串 ctrl + shift + f 在全局文件中查找字符串 ctrl + shift + r 在全局中替换字符串 alt + f7 查找当前变量的作用，并直接对话框显示 ctrl + alt + f7 在文件中查找符号的使得 ctrl + shift + f7 在文件中高亮显示变量的作用 ## 导航 快捷键 说明 Ctrl+N 查找类文件 Ctrl+Shift+N 查找文件 Ctrl+G 定位到文件某一行 Alt+向左箭头 返回至上次光标位置 Alt+向右箭头 返回至后一次光标位置 Ctrl+Shift+Backspace 返回上次编辑位置 Ctrl+Shift+反斜杠 返回后一次编辑位置 Ctrl+Alt+B 定位至选中类或方法的具体实现 Ctrl+Shift+B 直接定位至光标所在变量的类型定义 Ctrl+U 直接定位至当前方法override或者implements的方法定义处 Ctrl+F12 显示当前文件的文件结构 Ctrl+Alt+F12 显示当前文件的路径，并可以方便的将相关父路径打开 Ctrl+H 显示当前类的继承层次 Ctrl+Shift+H 显示当前方法的继承层次 Ctrl+Alt+H 显示当前方法的调用层次 F2 定位至下一个错误处 Shift+F2 定位至前一个错误处 Ctrl+Alt+向上箭头 查找前一个变量共现的地方 Ctrl+Alt+向下箭头 查找下一个变量共现的地方 代码 快捷键 说明 Ctrl+O 重写基类的方法 Ctrl+I 实现基类或接口中的方法 Alt+Insert 产生构造方法、getter/setter等方法 Ctrl+Alt+T 将选中的代码使用if、while、try/catch等包装 Ctrl+Shift+Delete 去除相关的包装代码 完成 快捷键 说明 Alt+/ 自动完成 Alt+Enter 自动提示完成 折叠 快捷键 说明 Ctrl+= 展开代码 Ctrl+- 收缩代码 Ctrl+Alt+= 递归展开代码 Ctrl+Alt+- 递归收缩代码 Ctrl+Shift+= 展开所有代码 Ctrl+Shift+- 收缩所有代码 优化 快捷键 说明 Ctrl+J 插入Live Template SCtrl+Alt+J 使用Live Template包装 Ctrl+/ 使用//进行注释 Ctrl+Shift+/ 使用/**/进行注释 Ctrl+Alt+L 格式化代码 Ctrl+Alt+I 自动缩进行 Ctrl+Alt+O 优化import 重置 快捷键 说明 Shift+F6 重命名 Ctrl+F6 更改函数签名 Ctrl+Shift+F6 更改类型 常用 快捷键 说明 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地 Alt+6 查找TODO Alt+F10 定位到断点 ALT+F1 查找文件所在目录位置 CTRL+E 最近打开的文件 Ctrl+N 查找类 CTRL+ALT+B 找所有的子类 参考：(https://blog.csdn.net/tangcv/article/details/79900556)参考：(https://www.cnblogs.com/LeoBoy/p/5821577.html)]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM_CRUD 整合思路]]></title>
    <url>%2F2018%2F04%2F30%2FSSM-CRUD-%E6%95%B4%E5%90%88%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[SSM_CRUD 整合思路 SSM_CRUD-总览 ssm:SpringMVC+Spring+MyBatis CRUD： Create（创建） Retrieve（查询） Update（更新） Delete（删除） SSM_CRUD-功能点• 1、分页 • 2、数据校验 • jquery前端校验+JSR303后端校验 • 3、 ajax • 4、 Rest风格的URI；使用HTTP协议请求方式的动词，来表示对资 源的操作（GET（查询）， POST（新增）， PUT（修改）， DELETE （删除）） SSM_CRUD-技术点• 基础框架-ssm（SpringMVC+Spring+MyBatis） • 数据库-MySQL • 前端框架-bootstrap快速搭建简洁美观的界面 • 项目的依赖管理-Maven • 分页-pagehelper • 逆向工程-MyBatis Generator SSM_CRUD-环境搭建• 1、创建一个maven工程• 2、引入项目依赖的jar包 • spring • springmvc • mybatis • 数据库连接池，驱动包 • 其他（jstl， servlet-api， junit）• 3、引入bootstrap前端框架• 4、编写ssm整合的关键配置文件 • web.xml， spring,springmvc,mybatis，使用mybatis的逆向工程生成对应的bean以 及mapper• 5、测试mapper SSM_CRUD-查询• 1、访问index.jsp页面• 2、 index.jsp页面发送出查询员工列表请求• 3、 EmployeeController来接受请求，查出员工数据• 4、来到list.jsp页面进行展示• 5、 pageHelper分页插件完成分页查询功能• URI： /emps SSM_CRUD-查询 Ajax• 1、 index.jsp页面直接发送ajax请求进行员工分页数据的查询• 2、服务器将查出的数据，以json字符串的形式返回给浏览器• 3、浏览器收到js字符串。可以使用js对json进行解析，使用js通过 dom增删改改变页面。• 4、返回json。实现客户端的无关性。 SSM_CRUD-新增逻辑• 1、在index.jsp页面点击”新增”• 2、弹出新增对话框• 3、去数据库查询部门列表，显示在对话框中• 4、用户输入数据，并进行校验• jquery前端校验， ajax用户名重复校验，重要数据（后端校验(JSR303)，唯一约束）；• 5、完成保存• URI:• /emp/{id} GET 查询员工• /emp POST 保存员工• /emp/{id} PUT 修改员工• /emp/{id} DELETE 删除员工 SSM_CRUD-修改逻辑• 1、点击编辑• 2、弹出用户修改的模态框（显示用户信息）• 3、点击更新，完成用户修改 SSM_CRUD-删除逻辑• 1、单个删除• URI:/emp/{id} DELETE• 2、批量删除]]></content>
      <tags>
        <tag>java, SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvan安装配置]]></title>
    <url>%2F2018%2F04%2F30%2Fmvan%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[mvan安装配置 参考：https://www.cnblogs.com/eagle6688/p/7838224.html maven : https://maven.apache.org/download.cgi 解压 – &gt; 进入目录 –&gt; C:\java\OpenSource\apache-maven-3.5.3 配置系统变量: 1.新增系统变量 – &gt; 变量名:MAVEN_HOME 变量值：C:\java\OpenSource\apache-maven-3.5.32.编辑path 变量：追加 – &gt; %MAVEN_HOME%\bin\; 测试: 配置Maven本地仓库:选择一个目录用作maven的本地库 – &gt; C:\java\mavelocrepo\maven-repository – &gt;打开D:\Program Files\Apache\maven\conf\settings.xml文件，查找下面这行代码： /path/to/local/repo– &gt; localRepository节点默认是被注释掉的，需要把它移到注释之外，然后将localRepository节点的值改为我们在3.5.3 中创建的目录C:\java\mavelocrepo\maven-repository – &gt; 注意: localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:\Users\用户名.m2。当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。 运行一下DOS命令: mvn help:system 如果前面的配置成功，那么D:\Program Files\Apache\maven-repository会出现一些文件。 配置Eclipse的Maven环境]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《水浒传》人物出场统计]]></title>
    <url>%2F2018%2F04%2F21%2F%E3%80%8A%E6%B0%B4%E6%B5%92%E4%BC%A0%E3%80%8B%E4%BA%BA%E7%89%A9%E5%87%BA%E5%9C%BA%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[运用了 python 的 第三库 jieba 分词库, WordCloud 词云库, pyecharts 数据报表库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#《水浒传》 人物出场统计v2import jiebaimport jsonfrom scipy.misc import imreadimport timeimport matplotlib.pyplot as pltfrom wordcloud import WordCloudfrom pyecharts import Bar# 用于加载本地文本为 listdef locallist(filepath): locattxt = [line.strip() for line in open(filepath, 'r', encoding='utf-8').readlines()] return locattxt# 文本分词def getwords(originfile, selfdect): # originfile = '.\date\水浒传.txt', selfdect= r".\date\jieba.txt" txt = open(originfile, 'r', encoding='utf-8').read(); # 加载自定義字典 jieba.load_userdict(selfdect) # jieba 分詞 words = jieba.lcut(txt, cut_all=False); return words# 去除无关的词并根据词频排序集合def stopwords(stopwords, counts): for word in stopwords: del counts[word] items = list(counts.items()); # 根据词频排序集合 items.sort(key=lambda x: x[1], reverse=True) return items#解析成 json 类型并写文件def getjson(counts): wordjson = json.dumps((sorted(counts.items(), key=lambda x:x[1], reverse=True)), ensure_ascii=False) with open(r'.\date\wordjson.json', 'w+', encoding='utf-8') as f: f.write(wordjson)# 打印def showpirnt(items): for i in range(50): word, count = items[i] print('&#123;0:^4&#125;&#123;1:&lt;10&#125;&#123;2:&gt;5&#125;'.format(i + 1, word, count))# 生成词云def getwordcloud(imagepath, counts): #back_color = imread('F:\MoocPython\week06\image\bg.jpg') # 解析该图片 imagepath = imagepath + str(time.time())[-3:] + '.jpg' # 设置图片保存的路径 wcimage = WordCloud(font_path=r".\font\msyh.ttf", max_words=50, height=600, width=1200, #background_color='white', #mask=back_color ).generate_from_frequencies(counts) plt.imshow(wcimage) plt.axis('off') plt.show() wcimage.to_file(imagepath) # 保存图片# 生成柱形表def changlist(jsondict, savepath='.\date\pycs', title='水浒传人物出场统计(50)'):# dict 数据 -&gt; list(dict.keys()), list(dict.values()) attr = [] value = [] for i in range(30): attr.append(list(jsondict.keys())[i]) for i in range(30): value.append(list(jsondict.values())[i]) attr = ['&#123;&#125;'.format(i) for i in attr] value = ['&#123;&#125;'.format(i) for i in value] bar = Bar(title) bar.add('', attr, value, is_label_show=True, is_datazoom_show=True) bar.render(path=savepath + str(time.time())[-3:] + '.html')if __name__ == '__main__': words = getwords(str('.\date\水浒传.txt'), str(r'.\date\jieba.txt')) # 设置为字典类型 counts = &#123;&#125; for word in words: if len(word) == 1: continue elif word == "宋江道" or word == "宋公明" or word == "宋江便" or word == "宋江见": rword = "宋江" elif word == "智深" or word == "和尚" or word == "提辖": rword = "鲁智深" elif word == "军师": rword == "吴用" elif word == "教头": rword == "林冲" elif word == "黑旋风": rword == "李逵" elif word == "戴宗道": rword == "戴宗" elif word == "柴大官人": rword == "柴进" else: rword = word # 利用字典统计词频 counts[rword] = counts.get(rword, 0) + 1 #print(counts) stopword = locallist(str('.\date\stopwords.txt')) items = stopwords(stopword, counts) showpirnt(items) getwordcloud(str('.\image\wcpic') ,counts) # 获取 json 数据 jsontxt = open('.\date\wordjson.json', 'r', encoding='utf-8').read() txt = dict(json.loads(jsontxt)) changlist(txt)]]></content>
  </entry>
  <entry>
    <title><![CDATA[IDEA 破解]]></title>
    <url>%2F2018%2F04%2F20%2FIDEA-%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[IDEA在激活界面选择：License server内容： http://idea.toocruel.net点击右下角 Activate即可 webstorm在激活界面选择：License server内容： http://idea.wrbugtest.tk/点击右下角 Activate即可 PyChram JetbrainsCrack-2.9-release-enc.jar 使用： JetbrainsCrack-2.9-release-enc.jar 复制到Pychram\bin目录下 Pychram\bin目录下找到以下两个文件 “pycharm.exe.vmoptions”，”pycharm64.exe.vmoptions”, 在两个文件最末处加上 “-javaagent:D:\LearnSoft\pyChram\PyCharm 2018.1.3\bin\JetbrainsCrack-2.9-release-enc.jar” 在激活界面 “Activation code” 输入以下代码，或随便写123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "licenseId":"1454467925669", "licenseeName":"ilanyu", "assigneeName":"", "assigneeEmail":"", "licenseRestriction":"", "checkConcurrentUse":false, "products":[&#123; "code":"II", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"DM", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"AC", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"RS0", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"WS","paidUpTo":"2099-12-31" &#125;,&#123; "code":"DPN", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"RC", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"PS", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"DC", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"RM", "paidUpTo":"2099-12-31" &#125;,&#123; "code":"CL","paidUpTo":"2099-12-31" &#125;,&#123; "code":"PC","paidUpTo":"2099-12-31" &#125;], "hash":"2911276/0", "gracePeriodDays":7, "autoProlongated":false&#125; 原文：原文：]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android基础]]></title>
    <url>%2F2018%2F03%2F26%2Fandroid%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[android开发环境]]></title>
    <url>%2F2018%2F03%2F10%2Fandroid%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[android开发主要有两种开发软件使用一是Eclipse二是Android studio,本文是从这两个方面来搭建环境.Eclipse:jdk + Eclipse + ADT + Android SDKAndroid studio: jdk + Android Studio + Android SDK注意：本文的搭建过程不需要vpn Eclipse手动配置准备 - jdk下载： Download Now jdk的安装以及配置过程在这里就不做过多的讲述了。 - Eclipse下载：Download Now jdk的安装过程在这里也略过了。 - ADT下载：Download Now 在这里点击默认下载：https://dl.google.com/android/ADT-23.0.7.zip 注意：如果需要其他版本：https://dl.google.com/android/ADT-xx.x.x.zip把xx.x.x改为对应的版本 - Android SDK下载：Download Now 配置 配置ADT： 找到已下载好的ADT：进行如图配置 点击确定,等待安装完成即可！ 配置Android SDK： 环境变量： - 新增系统变量：变量名：ANDROID_SDK_HOME变量值：Android SDK的根目录，如下图： - 系统变量Path中增加：%ANDROID_SDK_HOME%\platform-tools 以上两种配置完成在DOS中输入adb就会出现如下图： 设置端口：打开SDK Manager.exe,设置如下图： 端口设置：完成的之后随便选择一个Android版本下载即可 创建项目中的问题：如何可显化界面无法显示，原因是ADT与SDK版本不相匹配, 成功效果图： Eclipse集成开发包Download Now 下载集成开发包,解压即可用！这里不做过多的讲述。 Android studio准备 - jdk下载：Download Now jdk的安装以及配置过程在这里就不做过多的讲述了。 - Android Studio下载：Download Now 这里作者用的是绿色版，解压即可使用。 - Android SDK：同上不做解释。 配置 创建项目中的问题： 问题一：如下图 解决方法： 文件 –&gt; 配置 –&gt; 构建,执行,部署 –&gt; Gradle 如图设置Use local gradle distribution 确定即可 注意：Global home的路径在你的Android Studio 的根目录下。例如:D:\Android-Studio\soruce\android-studio-ide-171.4443003-windows32\android-studio\gradle\gradle-4.1 问题二：如下图： 解决方法： 找到项目 –&gt; app –&gt; build.gradle 修改如下图： 成功效果图：]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2F2018%2F03%2F07%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[java注解，三个基本的注解，自定义的注解，元注解 注解(Annotation)@since 1.5三个基本的注解 @Override:限定重写父类方法，该注释只能用于方法@Deprecated:用于表示某个程序元素（类， 方法等）已过时@SupperssWarnings:抑制编译器警钟警告 自定义的注解使用@interface声明一个注解 123public @interface MyAnnotation&#123; String value() default "hello";&#125; 元注解 @Retention:只能用于修饰一个注解定义，用于指定该注解可以保留多长时间[RetentionPolicy]类型成员变量，使用@Retention必须指定Value;value: RetetionPolicy.SOURCE:编译器直接丢弃这种策略的注释 RetetionPolicy.CLASS:编译器将把注释记录在class文件中，运行java程序时，jvm不会保留注解，这是默认值 RetetionPolicy.RUNTIME:编译器将把注释记录在class文件中，运行java程序时，jvm会保留注解，程序可以通过反射获取该 注释 @Target:用于修饰注解定义，用于指定被修饰的注解能用于修饰那些程序元素，@Target也包含一个名为value的成员变量 @Document：用于指定被该元注解修饰的注解类将javadoc工具提取成文档说明：依赖@Retention(RetentionPolicy.RUNTIME) @Inheried:被该注解修饰的注解将具有继承性，修饰的注解的类的子类将自动具有该注解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建Class的实例]]></title>
    <url>%2F2018%2F03%2F07%2F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAClass%E7%9A%84%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[如何获取Class的实例（4种） 1234567891011121314151617//Class实例四:通过类的加载器ClassLoader cl = new Arithmetic().getClass().getClassLoader();Class clazz3 = cl.loadClass("com.javaee_02.exer1.Arithmetic");Arithmetic ar3 = (Arithmetic)clazz3.newInstance();System.out.println(clazz3.getName());//Class实例三:通过Class的静态方法获取Class clazz2 = Class.forName("com.javaee_02.exer1.Arithmetic");Arithmetic ar2 = (Arithmetic)clazz2.newInstance();//Class实例二:通过运行时类的对象获取Arithmetic ar1 = new Arithmetic();Class clazz1 = ar1.getClass();//Class实例一:调用运行时类本身的.class属性Class&lt;Arithmetic&gt; clazz = Arithmetic.class;Arithmetic ar = (Arithmetic)clazz.newInstance();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORACLEU总结]]></title>
    <url>%2F2018%2F03%2F04%2FORACLEU%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对之前的学习做更深入的巩固，及加深体会，扎实基础！ 使用system用户解锁scott用户12alter user scott account unlock;alter user scott identified by tiger; 创建用户并授权12345create user newUser identified by newPwd;grant connect to newUser;grant create table to newUser;grant create proedure to newUser;grant unlimited tablespace to newUser; 创建表空间123create tablespace emp_tablespacedatafile &apos;c:emp_tablespace.dbf&apos;size 100mb newUser复制scott的emp表12grant select[all] on scott.emp to newUser; --system accountcreate table newEmp as select * from scott.emp; 显示EMP表的行号select rownum from emp;123456## &lt;span&gt;显示emp表每一个雇员的总收入(工资+奖金)&lt;/span&gt;```sqlupdate emp set comm = 0 from emp where comm is null;select ename,(sal+comm) [as] 总收入 from emp; 在列别名上使用双引号。（当你的别名为关键字或别名中有特殊符号时需要加双引号） ‘5’+ 5 结果为 10 ‘5’|| 5 结果为 ‘55’ ASC 表示升序 (可省略) Desc 表示降序(不可省略) 查询emp表雇员姓名和工资，并按工资从小到大(从大到小)排序1select ename, sal from emp order by sal asc(desc) 查询emp表雇员信息，先按部门从小到大排序，再按雇佣时间的先后排序1select * from emp order by deptno, hiredate; 使用DISTINCT消除重复行显示1select distinct job from emp; 部门ACCOUNTING所在的城市为NEW YORK1select '部门' || dname || '所在的城市为' || loc from dept; 显示雇员名称中包含“S”的雇员名称及名称长度1234-- 方法一：select ename, length(ename) from emp where like '%s%';-- 方法二：select ename, length(ename) from emp where instr(ename, 's', 1, 1) &gt; 0; 显示名称以“W”开头的雇员，并将名称转换成以大写开头1select initcap(ename) from emp where substr(ename, 1, 1) = 'W'; 如果不知道表的字段内容是大写还是小写，可以转换后比较1select * from emp where lower[upper](ename) in 'blake'['BLAKE']; 3.3434保留两位小数;1select round(3.3434, 2) from dual 判断用户的角色是否为SYSDBA1select userenv('ISDBA') from dual; 对部门表的部门名称和城市名进行转换123select decode(dname, 'ACCOUNTING', '统计部', 'RESEARCH', '研发部', 'SALES', '销售部', 'OPERATIONS', '其它部门') 部门,decode(loc, 'NEW YORK', '纽约', 'DALLAS', '达拉斯', 'CHICAGO', '芝加哥', 'BOSTON', '波士顿') 城市 from dept; 显示2008年的8月8日为星期几1select to_char('08-08月-2008', 'DY') from dual; 显示从本年1月1日开始到现在经过的天数(当前时间取SYSDATE的值)1select sysdate - to_date('2018-1-1', 'YYYY-MM-DD') from dual; 显示emp表雇员名称和雇员的经理名称123select worker.ename || '雇员的经理:' || manager.ename from emp worker, emp managerwhere worker.mgr = manager.empno 相等连接（内连接）ename,job,sal,comm,emp.deptno,dname123456--方法一：select ename, job, sal, comm, emp.deptno, dnamefrom emp, dept where emp.deptno = dept.deptno;--方法二：select ename, job, sal, comm, emp.deptno, dname from emp inner join dept on emp.deptno = dept.deptno; 求各部门平均工资的最高值1select deptno, max(ave(sal)) from emp group by deptno; 统计各部门的最高工资，排除最高工资小于3000的部门123select deptno, max(sal) from emp group by deptnohaning max(sal) &gt; 3000; 查询雇员表中排在第6～9位置上的雇员12select ename, sal from (select rownum as num, ename, sal from emp where rownum &lt;= 9 )where num &gt;= 6 查询工资低于任何一个“CLERK”的工资的雇员信息123select ename, job, sal from emp where sal &lt; any(select sal from emp where lower(job) = 'clerk')and lower(job) &lt;&gt; 'clerk' 创建从2000起始，增量为1 的序列abc：12create sequence abc increment by 1 start with 2000maxvalue 99999 cycle nocache; 创建按成绩分区的考生表，共分为3个区：1234567891011create table student(id varchar(5),name varchar(30)score number(3))partition by range(成绩)(partition a less than (300) tablespace users,partition b less than (600) tablespace users,partition c less than (maxvalue) tablespace); 创建emp表的经理视图(只读)1234creat or replace view manageras select * from emp where lower(job) = "manager" with read only;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery其他]]></title>
    <url>%2F2018%2F02%2F23%2FjQuery%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[jQuery其他:jQuery - noConflict() 方法 jQuery - noConflict() 方法: noConflict()方法,允许你在同一个页面加载多个jQuery实例，尤其是不同版本的jQuery，以及与其他javaScrip框架并存 noConflict()方法会释放对 $ 标识符的控制,这样其他脚本就可以使用它了 全名替代简写:12345678&lt;script&gt;$.noConflict();jQuery(document).ready(function()&#123; jQuery("button").click(function()&#123; jQuery("p").text("jQuery 仍然在工作!"); &#125;);&#125;);&lt;/script&gt; 创建自己的简写: 12345678&lt;script&gt;var jq=$.noConflict();jq(document).ready(function()&#123; jq("button").click(function()&#123; jq("p").text("jQuery 仍然在工作!"); &#125;);&#125;);&lt;/script&gt; 如果你的 jQuery 代码块使用 $ 简写，并且您不愿意改变这个快捷方式，那么您可以把 $ 符号作为变量传递给 ready 方法。这样就可以在函数内使用 $ 符号了 - 而在函数外，依旧不得不使用 “jQuery”：: 12345678&lt;script&gt;$.noConflict();jQuery(document).ready(function($)&#123; $("button").click(function()&#123; $("p").text("jQuery 仍然在工作!"); &#125;);&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery Ajax]]></title>
    <url>%2F2018%2F02%2F22%2FjQuery-Ajax%2F</url>
    <content type="text"><![CDATA[jQuery Ajax:jQuery - AJAX 简介,jQuery - AJAX load() 方法,jQuery - AJAX get() 和 post() 方法 jQuery - AJAX 简介什么是 AJAX？ AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。 关于 jQuery 与 AJAX jQuery 提供多个与 AJAX 有关的方法。通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中 jQuery - AJAX load() 方法load():从服务器加载数据，并把返回的数据放入被选元素中。 语法: $(selector).load(URL,data,callback); 参数： URL:必需，规定您希望加载的 URL。 data:可选的,规定与请求一同发送的查询字符串键/值对集合。 callback:可选,load() 方法完成后所执行的函数名称,回调函数可以设置不同的参数： responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 demo_test.txt:12&lt;h2&gt;jQuery and AJAX is FUN!!!&lt;/h2&gt;&lt;p id="p1"&gt;This is some text in a paragraph.&lt;/p&gt; 文件 “demo_test.txt” 的内容加载到指定的 元素中：1234567&lt;script&gt;$(document).ready(function()&#123; $(&quot;button&quot;).click(function()&#123; $(&quot;#div1&quot;).load(&quot;/statics/demosource/demo_test.txt&quot;); &#125;);&#125;);&lt;/script&gt; 把 “demo_test.txt” 文件中 id=”p1” 的元素的内容，加载到指定的 元素中：1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").load("/statics/demosource/demo_test.txt #p1"); &#125;);&#125;);&lt;/script&gt; load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示”外部内容加载成功！”，而如果失败，则显示错误消息： 123456789101112 &lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").load("/statics/demosource/demo_test.txt",function(responseTxt,statusTxt,xhr)&#123; if(statusTxt=="success") alert("外部内容加载成功!"); if(statusTxt=="error") alert("Error: "+xhr.status+": "+xhr.statusText); &#125;); &#125;);&#125;);&lt;/script&gt; jQuery - AJAX get() 和 post() 方法 $.get():通过 HTTP GET 请求从服务器上请求数据。 语法： $.get(URL,callback); 参数: URL:必需,规定您希望请求的 URL。 callback:可选,是请求成功后所执行的函数名。 $.get() 方法从服务器上的一个文件中取回数据： demo_test.php: 123&lt;?phpecho "This is some text from an external PHP file.";?&gt; 123456789&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $.get("/statics/demosource/demo_test.php",function(data,status)&#123; alert("数据: " + data + "\n状态: " + status); &#125;); &#125;);&#125;);&lt;/script&gt; $.post():通过 HTTP POST 请求从服务器上请求数据。 语法: $.post(URL,data,callback); 参数： URL:必需,规定您希望请求的 URL。 data:可选,规定连同请求发送的数据。 callback:可选,是请求成功后所执行的函数名。 使用 $.post() 连同请求一起发送数据： demo_test_post.php:12 &lt;?php $name = isset($_POST[‘name’]) ? htmlspecialchars($_POST[‘name’]) : ‘’; $city = isset($_POST[‘city’]) ? htmlspecialchars($_POST[‘city’]) : ‘’; echo ‘Dear ‘ . $name; echo ‘Hope you live well in ‘ . $city; ?&gt;1234567891011121314&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $.post("/statics/demosource/demo_test_post.php", &#123; name:"W3Cschool", url:"http://www.w3cschool.cn" &#125;, function(data,status)&#123; alert("数据: " + data + "状态: " + status); &#125;); &#125;);&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery遍历]]></title>
    <url>%2F2018%2F02%2F21%2FjQuer%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[-jQuery 遍历-jQuery 遍历 – 祖先-jQuery 遍历 – 后代--jQuery 遍历 – 同胞(siblings)-jQuery 遍历 – 过滤 jQuery 遍历12345678910 &lt;div&gt; | &lt;ul&gt; |-------------------------------- &lt;li&gt; &lt;li&gt; | | ------------ -------- | | |&lt;span&gt; &lt;span&gt; &lt;b&gt; 图示解析：1234567 &lt;div&gt; 元素是 &lt;ul&gt; 的父元素，同时是其中所有内容的祖先。&lt;ul&gt; 元素是 &lt;li&gt; 元素的父元素，同时是 &lt;div&gt; 的子元素左边的 &lt;li&gt; 元素是 &lt;span&gt; 的父元素，&lt;ul&gt; 的子元素，同时是 &lt;div&gt; 的后代。&lt;span&gt; 元素是 &lt;li&gt; 的子元素，同时是 &lt;ul&gt; 和 &lt;div&gt; 的后代。两个 &lt;li&gt; 元素是同胞（拥有相同的父元素）。右边的 &lt;li&gt; 元素是 &lt;b&gt; 的父元素，&lt;ul&gt; 的子元素，同时是 &lt;div&gt; 的后代。&lt;b&gt; 元素是右边的 &lt;li&gt; 的子元素，同时是 &lt;ul&gt; 和 &lt;div&gt; 的后代。 遍历 DOM:遍历方法中最大的种类是树遍历（tree-traversal）。 jQuery 遍历 – 祖先向上遍历 DOM 树方法: -parent():返回被选元素的直接父元素,该方法只会向上一级对 DOM 树进行遍历-parents():返回被选元素的所有祖先元素，它一路向上直到文档的根元素-parentsUntil():返回介于两个给定元素之间的所有祖先元素。 parent(): 返回所有 元素的所有祖先:12345&lt;script&gt;$(document).ready(function()&#123; $("span").parent().css(&#123;"color":"red","border":"2px solid blue"&#125;);&#125;);&lt;/script&gt; parents(): 返回所有 元素的所有祖先，并且它是 元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("span").parents("ul").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; parentsUntil(): 与 元素之间的所有祖先元素： 12345 &lt;script&gt;$(document).ready(function()&#123; $("span").parents("ul").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; jQuery 遍历 – 后代-children():返回被选元素的所有直接子元素。-find():返回被选元素的后代元素，一路向下直到最后一个后代。 children(): 返回每个 元素的所有直接子元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("div").children().css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; 返回类名为 “1” 的所有 元素，并且它们是 的直接子元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("div").children("p.1").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; find(): 返回属于 后代的所有 元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("div").find("span").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; 返回 的所有后代： 12345&lt;script&gt;$(document).ready(function()&#123; $("div").find("*").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; jQuery 遍历 - 同胞(siblings)-siblings():返回被选元素的所有同胞元素。-next():返回被选元素的下一个同胞元素。-nextAll():返回被选元素的所有跟随的同胞元素。-nextUntil():返回介于两个给定参数之间的所有跟随的同胞元素。-prev()&amp;&amp;prevAll()&amp;&amp;-prevUntil():工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞元素向后遍历，而不是向前）。 siblings(); 返回 的所有同胞元素：[但返回中不包含被选元素] 12345&lt;script&gt;$(document).ready(function()&#123; $("h2").siblings().css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; 返回属于 的同胞元素的所有 元素：[返回中包含被选元素] 12345&lt;script&gt;$(document).ready(function()&#123; $("h2").siblings("h2").css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; next(): 返回 的下一个同胞元素：[返回中不包含被选元素]12345&lt;script&gt;$(document).ready(function()&#123; $("h2").next().css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; nextAll(): 返回 的所有跟随的同胞元素：[返回中不包含被选元素]12345&lt;script&gt;$(document).ready(function()&#123; $("h2").nextAll().css(&#123;"color":"red","border":"2px solid red"&#125;);&#125;);&lt;/script&gt; jQuery 遍历 – 过滤 first():返回被选元素的首个元素。 last():返回被选元素的最后一个元素。 eq():返回被选元素中带有指定索引号的元素,index从0开始 filter():允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 not():返回不匹配标准的所有元素,not() 方法与 filter() 相反 first(): 选取首个 元素内部的第一个 元素：12345&lt;script&gt;$(document).ready(function()&#123; $("div p").first().css("background-color","yellow");&#125;);&lt;/script&gt; last(): 选择最后一个 元素中的最后一个 元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("div p").last().css("background-color","yellow");&#125;);&lt;/script&gt; eq(): 选取第二个 元素（索引号 1）：12345&lt;script&gt;$(document).ready(function()&#123; $("p").eq(0).css("background-color","yellow");&#125;);&lt;/script&gt; filter(): 返回带有类名 “intro” 的所有 元素：实例 12345&lt;script&gt;$(document).ready(function()&#123; $("p").filter(".url").css("background-color","yellow");&#125;);&lt;/script&gt; not(): 返回不带有类名 “intro” 的所有 元素： 12345&lt;script&gt;$(document).ready(function()&#123; $("p").not(".url").css("background-color","yellow");&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery HTML]]></title>
    <url>%2F2018%2F02%2F20%2FjQuery-HTML%2F</url>
    <content type="text"><![CDATA[jQuery HTML：jQuery 捕获,jQuery 设置,jQuery 添加元素,jQuery 删除元素,jQuery CSS 类,jQuery css() 方法,jQuery 尺寸 jQuery 捕获获取内容： text():设置或返回所选元素的文本内容 html():设置或返回所选元素的内容（包括 HTML 标记） val():设置或返回表单字段的值 获取属性： attr():用于获取属性值 text()&amp;&amp;html():123456789101112&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; alert("Text: " + $("#test").text()); //Text:这是段落中的 粗体 文本。 &#125;); $("#btn2").click(function()&#123; alert("HTML: " + $("#test").html()); //Html:这是段落中的&lt;b&gt;粗体&lt;/b&gt;文本。 &#125;);&#125;);&lt;/script&gt; val():1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; alert("Val:" + $("#test").val()); &#125;);&#125;);&lt;/script&gt; attr(): 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; alert("Attr:" + $("#w3s").attr("href")); &#125;);&#125;);&lt;/script&gt; jQuery 设置text()&amp;&amp;html()&amp;&amp;val: 12345678910111213&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("#test1").text("Hello world!"); &#125;); $("#btn2").click(function()&#123; $("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;"); &#125;); $("#btn3").click(function()&#123; $("#test3").val("W3Cschool"); &#125;);&#125;);&lt;/script&gt; text()、html() 以及 val()，同样拥有回调函数。回调函数由两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串 1234567891011121314$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("#test1").text(function(i,origText)&#123; return "旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")"; &#125;); &#125;); $("#btn2").click(function()&#123; $("#test2").html(function(i,origText)&#123; return "旧 html: " + origText + " 新 html: Hello &lt;b&gt;world!&lt;/b&gt; (index: " + i + ")"; &#125;); &#125;);&#125;); attr(): 1234567891011&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; //$("#runoob").attr("href", "http://www.w3cschool.cn/jquery"); $("#runoob").attr(&#123; "href" : "http://www.w3cschool.cn/jquery", "title" : "jQuery 教程" &#125;); &#125;);&#125;);&lt;/script&gt; Query 添加元素 append():在被选元素内部的结尾插入指定内容 prepend():在被选元素内部的开头插入指定内容 after():在被选元素之后插入内容 before():在被选元素之前插入内容 append()&amp;&amp;prepend: 12345678910&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("p").prepend("&lt;b&gt;在开头追加文本&lt;/b&gt;。 "); &#125;); $("#btn2").click(function()&#123; $("ol").prepend("&lt;li&gt;在开头添加列表项&lt;/li&gt;"); &#125;);&#125;);&lt;/script&gt; append()&amp;&amp;prepend添加若干新元素:12345678910&lt;script&gt;function appendText()&#123; var txt1="&lt;p&gt;文本。&lt;/p&gt;"; // 使用 HTML 标签创建文本 var txt2=$("&lt;p&gt;&lt;/p&gt;").text("文本。"); // 使用 jQuery 创建文本 var txt3=document.createElement("p"); txt3.innerHTML="文本。"; // 使用 DOM 创建文本 text with DOM $("body").append(txt1,txt2,txt3); // 追加新元素&#125;&lt;/script&gt; after()&amp;&amp;before(): 1234567891011&lt;script&gt;$(document).ready(function()&#123; $("#btn1").click(function()&#123; $("img").before("&lt;b&gt;之前&lt;/b&gt;"); &#125;); $("#btn2").click(function()&#123; $("img").after("&lt;i&gt;之后&lt;/i&gt;"); &#125;);&#125;);&lt;/script&gt; after()&amp;&amp;before()添加若干新元素: 12345678910111213141516&lt;script&gt;function afterText()&#123;var txt1="&lt;b&gt;I &lt;/b&gt;";var txt2 = $("&lt;i&gt;&lt;/i&gt;").text(" LOVE ");var txt3=document.createElement("big");txt3.innerHTML = "LIULI";$("img").after(txt1,txt2,txt3); &#125;function beforeText()&#123; var text1 = "&lt;b&gt;I &lt;/b&gt;"; var text2 = $("&lt;i&gt;&lt;/i&gt;").text(" LOVE "); var text3 = document.createElement("big"); text3.innerHTML=" LIULI"; $("img").before(text1,text2,text3);&#125;&lt;/script&gt; jQuery 删除元素 remove():删除被选元素（及其子元素） empty():从被选元素中删除子元素 remove(): 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").remove(); &#125;);&#125;);&lt;/script&gt; remove()过滤被删除的元素: 12345678 //class="italic" 的所有 &lt;p&gt; 元素&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("p").remove(".italic"); &#125;);&#125;);&lt;/script&gt; empty():(所有子类删除) 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").empty(); &#125;);&#125;);&lt;/script&gt; jQuery CSS 类 addClass():向被选元素添加一个或多个类 removeClass():从被选元素删除一个或多个类 toggleClass():对被选元素进行添加/删除类的切换操作 addClass():12345678&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("h1,h2,p").addClass("blue"); $("div").addClass("important"); &#125;);&#125;);&lt;/script&gt; addClass()规定多个类:1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("div").addClass("important blue"); &#125;);&#125;);&lt;/script&gt; removeClass(): 也可以删除多个class属性1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("h1,h2,p").removeClass("blue"); &#125;);&#125;);&lt;/script&gt; toggleClass()：1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("h1,h2,p").toggleClass("blue"); &#125;);&#125;);&lt;/script&gt; jQuery css() 方法 css():设置或返回样式属性 css():返回 CSS 属性 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; alert("背景颜色 = " + $("p").css("background-color")); &#125;);&#125;);&lt;/script&gt; css():设置 CSS 属性 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("p").css("background-color","yellow"); &#125;);&#125;);&lt;/script&gt; css():设置多个 CSS 属性 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("p").css(&#123;"background-color":"yellow","font-size":"200%"&#125;); &#125;);&#125;);&lt;/script&gt; jQuery 尺寸 width():设置或返回元素的宽度（不包括内边距、边框或外边距） height():设置或返回元素的高度（不包括内边距、边框或外边距） innerWidth():返回元素的宽度（包括内边距） innerHeight():方法返回元素的高度（包括内边距） outerWidth():返回元素的宽度（包括内边距和边框） outerHeight():方法返回元素的高度（包括内边距和边框） width()&amp;&amp;height(): 12345678910&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; var txt=""; txt+="Width of div: " + $("#div1").width() + "&lt;/br&gt;"; txt+="Height of div: " + $("#div1").height(); $("#div1").html(txt); &#125;);&#125;);&lt;/script&gt; innerWidth()&amp;&amp;innerHeight(): 123456789101112&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; var txt=""; txt+="div 宽度: " + $("#div1").width() + "&lt;/br&gt;"; txt+="div 高度: " + $("#div1").height() + "&lt;/br&gt;"; txt+="div 宽度，包含内边距: " + $("#div1").innerWidth() + "&lt;/br&gt;"; txt+="div 高度，包含内边距: " + $("#div1").innerHeight(); $("#div1").html(txt); &#125;);&#125;);&lt;/script&gt; outerHeight()&amp;&amp;outerWidth(): 123456789101112&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; var txt=""; txt+="div 宽度: " + $("#div1").width() + "&lt;/br&gt;"; txt+="div 高度: " + $("#div1").height() + "&lt;/br&gt;"; txt+="div 宽度，包含内边距和边框: " + $("#div1").outerWidth() + "&lt;/br&gt;"; txt+="div 高度，包含内边距和边框: " + $("#div1").outerHeight(); $("#div1").html(txt); &#125;);&#125;);&lt;/script&gt; outerWidth(true) 方法返回元素的宽度（包括内边距、边框和外边距）]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java File类练习]]></title>
    <url>%2F2018%2F02%2F20%2Fjava-File%E7%B1%BB%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[对File类进行了解！ 1234567891011121314151617181920212223242526272829303132333435363738394041package test;import java.io.File;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;public class file &#123; public static void main(String[] args) throws IOException &#123; //初始化 File f1 = new File("h:\\mmjpg"); //判断是不是存在 System.out.println(f1.exists()); //判断是不是文件 System.out.println(f1.isFile()); //判断是不是文件夹 System.out.println(f1.isDirectory()); //获取文件大小(不能用于文件夹) System.out.println(f1.length() + "字节！"); //获取文件最后修改的时间 long l1 = f1.lastModified(); Date d1 = new Date(l1); SimpleDateFormat sdf = new SimpleDateFormat("YYYY-MM-dd HH:mm:ss"); System.out.println(sdf.format(d1)); //获得文件名称(初始化的文件名称"D:\\mmjpg") System.out.println("文件名称" + f1.getName()); //获得文件的上层目录 System.out.println(f1.getParent()); //获得文件的绝对路径 System.out.println(f1.getAbsoluteFile()); //获得标准绝对路径 System.out.println(f1.getCanonicalPath()); //获得分区的总大小 System.out.println(f1.getTotalSpace()); //获得分区未使用大小 System.out.println(f1.getFreeSpace()); //重命名 //File f2 = new File("D:\\mm"); //f1.renameTo(f2); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java复制文件]]></title>
    <url>%2F2018%2F02%2F20%2Fjava%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Download Now 1.字节流:每次只能处理一个字节 2.java中所有字节流都以InPutStream和OutputStream作为祖先类 3.InputStream类 最核心方法read 其次是读取一个字节 无参,其返回值是int类型,里面存放的就是所读到的那个字节的信息 下次再调用read方法时,读取的并 不是刚才所读到的那个字节,而下一个字节 以此类推,直到把数据源中每一个字节都读取完毕 当read所返回值是-1表示读到数据源的末尾 4.OutputStream类 最核心方法write 是向数据源中输出一个字节 参数int类型,其意义就是向数据源输出的信息,真实写入数据源的仅是一个字节 write就去没有所谓的结束,理论上,有多少字节都可以逐一写入数据源中 5.无论是输入流还是输出流,在使用完之后,都要关闭流对象,否则会导致系统资源耗尽 6.调用流对象的close方法实现关闭 读取单个字节复制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package test;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class fileIO &#123; public static void main(String[] args) &#123; //伪初始化 InputStream fis = null; OutputStream fos = null; String inpath = "D:\\test.txt"; String outpath = ("f:\\test.txt"); File f1 = new File(inpath); File f2 = new File(outpath.substring(0, 8)); //判断是不是存在源文件和目标目录 if(!(f1.isFile() == true &amp;&amp; f2.isDirectory() == true)) &#123; System.out.println("复制失败！源文件或目标目录存在"); &#125; else &#123; try &#123; //初始化 fis = new FileInputStream(inpath); fos = new FileOutputStream(outpath); int temp; //开始复制文件 while((temp=fis.read())!=-1) &#123; fos.write(temp); &#125; System.out.println("文件复制成功！"); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); //关闭IO流并处理异常 &#125; finally &#123; if(fis!=null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block； e.printStackTrace(); &#125; if(fos!=null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 读取一组字节复制重载read()读取一组字节 int read(byte[] b) int read(byte[] b, int off, int len)重载write()写入一组字节 int write(byte[] b) int write(byte[] b, int off, int len) 12345int readByteByte[] buff = new Byte[1024]while((readByte=fis.read(buff))!=-1)&#123; fos.write(buff,0,readByte)&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery效果]]></title>
    <url>%2F2018%2F02%2F19%2FjQuery%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[jQuery效果:隐藏和显示[hide(),show(),toggle()],淡入淡出[fadeIn(),fadeOut(),fadeToggle(),fadeTo()],滑动[slideDown(),slideUP(),slideToggle()],动画[animate()],停止动画[stop()] 隐藏和显示[hide(),show(),toggle()]toggle语法：切换hide()与show()【隐藏和显示】 $(selector).toggle(speed, callback) 参数： speed:规定隐藏/显示的速度value:”slow”、”fast” 或毫秒 callback: $(selector)选中的元素的个数为n个，则callback函数会执行n次callback函数名后加括号，会立刻执行函数体，而不是等到显示/隐藏完成后才执行callback既可以是函数名，也可以是匿名函数 1234567&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("p").toggle("slow"); &#125;);&#125;);&lt;/script&gt; hide(),show()与toggle大同小异 淡入淡出[fadeIn(),fadeOut(),fadeToggle(),fadeTo()]fadeToggle语法：切换fadeIn()与fadeOut()【淡入淡出】 $(selector).fadeToggle(speed,callback) 参数：同toggle() 123456789&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").fadeToggle(1000); $("#div2").fadeToggle("slow"); $("#div3").fadeToggle("fast"); &#125;);&#125;);&lt;/script&gt; fadeTo()语法：【设不透明度】 $(selector).fadeTo(speed,opacity,callback); 参数： speed:必需参数,规定效果的时长 opacity:必需参数,透明度value[0`1] callback:可选参数,该函数完成后所执行的函数名称 123456789&lt;script&gt;$(document).ready(function()&#123; $("button").click(function()&#123; $("#div1").fadeTo("slow",0.15); $("#div2").fadeTo("slow",0.4); $("#div3").fadeTo("slow",0.7); &#125;);&#125;);&lt;/script&gt; 滑动[slideDown(),slideUP(),slideToggle()]toggle语法：切换slideDown()与slideUP()【向下滑动与向上滑动】 $(selector).slideToggle(speed,callback); 参数：同toggle() 1234567&lt;script&gt; $(document).ready(function()&#123; $("#flip").click(function()&#123; $("#panel").slideToggle("slow"); &#125;);&#125;);&lt;/script&gt; 动画[animate()]【使用Camel 标记法书写属性名】语法： $(selector).animate({params},speed,callback); 参数： {params}:必需参数,定义形成动画的 CSS 属性 speed:可选参数,规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒 callback:可选参数,动画完成后所执行的函数名称 1. 元素往右边移动了250px1234567&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("div").animate(&#123;left:'250px'&#125;); &#125;);&#125;);&lt;/script&gt; 2. 元素往右边移动了250px,透明度为0.5,高变150px,宽为150px $(document).ready(function(){ $("button").click(function(){ $("div").animate({ left:'250px', opacity:'0.5', height:'150px', width:'150px' }); }); }); 3.animate()使用相对值 1234567891011&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("div").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;); &#125;);&#125;);&lt;/script&gt; 4.animate() - 使用预定义的值[valu:show,hide,toggle] 123456789&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; $("div").animate(&#123; height:'toggle' &#125;); &#125;);&#125;);&lt;/script&gt; 5.animate() - 使用队列功能 1234567891011&lt;script&gt; $(document).ready(function()&#123; $("button").click(function()&#123; var div=$("div"); div.animate(&#123;height:'300px',opacity:'0.4'&#125;); div.animate(&#123;width:'300px',opacity:'0.8'&#125;); div.animate(&#123;height:'100px',opacity:'0.4'&#125;); div.animate(&#123;width:'100px',opacity:'0.8'&#125;); &#125;);&#125;);&lt;/script&gt; 停止动画[stop()]语法: $(selector).stop(stopAll,goToEnd); 参数: stoppAll:可选参数,规定是否应该清除动画队列,默认是 false goToEnd:可选参数,规定是否立即完成当前动画,默认是 false 12345678910&lt;script&gt; $(document).ready(function()&#123; $("#flip").click(function()&#123; $("#panel").slideDown(5000); &#125;); $("#stop").click(function()&#123; $("#panel").stop(); &#125;);&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pygame小游戏]]></title>
    <url>%2F2018%2F02%2F19%2Fpygame%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[最近了解了pygame库，根据学习内容，完成了这个小游戏，游戏大概是窗口中的文字可以移动，上下左右键可以控制移动的速度，鼠标也可以控制文字，当窗口最小化时，文字不移动，当窗口重新打开亦可以移动，移动时背景色发生相应的变化！不足的时鼠标控制有点问题！ 依赖： pygame第三方库 执行 pip install pygame 即可以安装 ##代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import pygame, sysimport pygame.freetype# 初始化pygame.init()size = width, height = 600, 400#窗口大小speed = [1, 1]#速度GOLD = 255, 251, 0#文字颜色aqqje = [230, 160]#文字范围screen = pygame.display.set_mode(size, pygame.RESIZABLE)f1 = pygame.freetype.Font('C:\Windows\Fonts\simhei.ttf', 36)#设置字体f1rect = f1.render_to(screen, aqqje, r"aqqje'note", fgcolor=GOLD, size = 61)#绘制文字fps = 300flock = pygame.time.Clock()#设置帧率bgcolor = pygame.Color('black')still = Falsedef RGBChannel(a): return 0 if a &lt; 0 else (255 if a &gt; 255 else int(a))while True: for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() #键盘控制 elif event.type == pygame.KEYDOWN: #left速度+1 if event.key == pygame.K_LEFT: speed[0] = speed[0] if speed[0] == 0 else (abs(speed[0]) - 1) * int(speed[0] / abs(speed[0])) #right速度-1 elif event.key == pygame.K_RIGHT: speed[0] = speed[0] + 1 if speed[0] &gt; 0 else speed[0] - 1 #up速度+1 elif event.key == pygame.K_UP: speed[1] = speed[1] + 1 if speed[1] &gt; 0 else speed[1] - 1 #down速度-1 elif event.key == pygame.K_DOWN: speed[1] = speed[1] if speed[1] == 0 else (abs(speed[1]) - 1) * int(speed[1] / abs(speed[1])) #Esc退出 elif event.key == pygame.K_ESCAPE: sys.exit() #改变窗口大小 elif event.type == pygame.VIDEORESIZE: size = width, height = event.w, event.h screen = pygame.display.set_mode(size, pygame.RESIZABLE) #鼠标事件 elif event.type == pygame.MOUSEBUTTONDOWN: if event.button == 1: still = True elif event.type == pygame.MOUSEBUTTONUP: still = False if event.pos == 1: aqqje[0] = event.pos[0] - f1rect.width aqqje[1] = event.pos[1] - f1rect.height elif event.type == pygame.MOUSEMOTION: if event.buttons[0] == 1: aqqje[0] = event.pos[0] - f1rect.width aqqje[1] = event.pos[1] - f1rect.height #保证不出右界 if aqqje[0] &lt; 0 or aqqje[0] + f1rect.width &gt; width: speed[0] = -speed[0] if f1rect.width &gt; width and f1rect.width + aqqje[0] &gt; f1rect.width: speed[0] = -speed[0] #保证不出下界 if aqqje[1] &lt; 0 or aqqje[1] + f1rect.height &gt; height: speed[1] = -speed[1] if f1rect.height &gt; height and f1rect.height + aqqje[1] &gt; f1rect.height: speed[1] = -speed[1] #窗口最小化停止移动 if pygame.display.get_active(): #横向移动 aqqje[0] = aqqje[0] + speed[0] #向下移动 aqqje[1] = aqqje[1] + speed[1] #背景可变 bgcolor.r = RGBChannel(f1rect.width * 255 / width) bgcolor.g = RGBChannel(f1rect.height * 255 / height) bgcolor.b = RGBChannel(min(aqqje[0], aqqje[1] * 255 / max(aqqje[0], aqqje[1], 1))) #刷新 screen.fill(bgcolor) f1rect = f1.render_to(screen, aqqje, r"aqqje'note", fgcolor=GOLD, size=61) pygame.display.update() flock.tick(fps)]]></content>
      <categories>
        <category>-python -pygame</category>
      </categories>
      <tags>
        <tag>-python -pygame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器]]></title>
    <url>%2F2018%2F02%2F18%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[介绍常见的jQuery选择器：元素选择器，id选择器，.class选择器，css选择器 元素选择器jQuery 元素选择器基于元素名选取元素. $(“p”) $(“button”) … #id选择器jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器. $(“#test”) $(“#lui”) .class选择器jQuery 类选择器可以通过指定的 class 查找元素 $(“.test”) $(“.lui”) css选择器jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性 $(“p”).css(“background-color”,”red”); More 语法 描述 $(“*”) 选取所有元素 $(this) 选取当前 HTML 元素 $(“p.intro”) 选取 class 为 intro 的 元素 $(“p:first”) 选取第一个 元素 $(“ul li:first”) 选取第一个 元素的第一个 元素 $(“ul li:first-child”) 选取每个 元素的第一个 元素 $(“[href]”) 选取带有 href 属性的元素 $(“a[target=’_blank’]”) 选取所有 target 属性值等于 “_blank” 的 元素 $(“a[target!=’_blank’]”) 选取所有 target 属性值不等于 “_blank” 的 元素 $(“:button”) 选取所有 type=”button” 的 元素 和 元素 $(“tr:even”) 选取偶数位置的 元素 $(“tr:odd”) 选取奇数位置的 元素 CDN库引用百度： http://libs.baidu.com/jquery/1.10.2/jquery.min.js Download Now 又拍云: http://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js Download Now 新浪: http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js Download Now Google: http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js Download Now Microsoft: http://ajax.htmlnetcdn.com/ajax/jQuery/jquery-1.10.2.min.js Download Now]]></content>
      <categories>
        <category>-jQuery</category>
      </categories>
      <tags>
        <tag>-jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery鼠标事件]]></title>
    <url>%2F2018%2F02%2F18%2FjQuery%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[jQuery常见的鼠标事件：单击click,双击dbclick,进入mouseenter,离开mouseleave,鼠标按键mousedown，鼠标按钮mouseup,光标悬停hover,焦点focus,失焦blur click()click() 方法是当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。 1234567&lt;script&gt; $(document).ready(function()&#123; $("p").click(function()&#123; $(this).hide(); &#125;); &#125;);&lt;/script&gt; dbclick()当双击元素时，会发生 dblclick 事件。dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数： 1234567&lt;script&gt; $(document).ready(function()&#123; $("#p1").dblclick(function()&#123; $(this).hide(); &#125;); &#125;);&lt;/script&gt; mouseenter()当鼠标指针穿过元素时，会发生 mouseenter 事件。mouseenter() 方法触发 mouseenter 事件，或规定当发生 mouseenter 事件时运行的函数： 1234567&lt;script&gt; $(document).ready(function()&#123; $("#p1").mouseenter(function()&#123; alert("You entered p1!"); &#125;); &#125;);&lt;/script&gt; mouseleave()当鼠标指针离开元素时，会发生 mouseleave 事件。mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数 1234567&lt;script&gt; $(document).ready(function()&#123; $("#p1").mouseleave(function()&#123; alert("Bye! You now leave p1!"); &#125;); &#125;);&lt;/script&gt; mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数 1234567&lt;script&gt; $(document).ready(function()&#123; $("#p1").mousedown(function()&#123; alert("Bye! You now leave p1!"); &#125;); &#125;);&lt;/script&gt; mouseup()当在元素上松开鼠标按钮时，会发生 mouseup 事件。mouseup() 方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数 1234567&lt;script&gt;$(document).ready(function()&#123; $("#p1").mouseup(function()&#123; alert("Mouse up over p1!") &#125;);&#125;);&lt;/script&gt; hover()hover()方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 123456789&lt;script&gt; $(document).ready(function()&#123; $("#p1").hover(function()&#123;alert("You entered p1!"); &#125;, function()&#123; alert("Bye! You now leave p1!"); &#125;); &#125;);&lt;/script&gt; focus()&amp;&amp;blur()1.当元素获得焦点时，发生 focus 事件。当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数 2.当元素失去焦点时，发生 blur 事件。blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数 12345678910&lt;script&gt;$(document).ready(function()&#123; $("input").focus(function()&#123; $(this).css("background-color","#cccccc"); &#125;); $("input").blur(function()&#123; $(this).css("background-color","#ffffff"); &#125;);&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>-jQuery</category>
      </categories>
      <tags>
        <tag>-jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐外链接]]></title>
    <url>%2F2018%2F02%2F18%2F%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%A4%96%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[网易云音乐外链接公式:http://music.163.com/song/media/outer/url?id=ID.mp3 歌曲：Superstar网易云url：http://music.163.com/#/song?id=492145159网易云音乐外链接url:http://music.163.com/song/media/outer/url?id=492145159.mp3 参考]]></content>
      <categories>
        <category>[object Object]</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬取全网站所有图片]]></title>
    <url>%2F2018%2F02%2F18%2Fpython%E7%88%AC%E5%8F%96%E5%85%A8%E7%BD%91%E7%AB%99%E6%89%80%E6%9C%89%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[整体思路：1.获取网站最大page是多少?2.再遍历出所有page的url3.再分别对每个page页进行套图的url遍历4.找出每个套图的最大page，5.对套图的每一个图片进行保存 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134# 导入必要的库import requestsfrom bs4 import BeautifulSoupimport osimport sysimport lxmlfrom multiprocessing import Pool, cpu_countimport time# 设置headers头信息header = &#123; # 判断客户端的请求是Ajax请求 'X-Requested-With': 'XMLHttpRequest', # 用户代理 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.204 Safari/537.36', # 反盗链 'Referer': 'http://www.mmjpg.com' &#125;# 保存地址path = 'D:/mmjpg/'home_url = 'http://www.mmjpg.com'home_page = 'http://www.mmjpg.com/home/'# 爬取网站的最大page/也可以从网站直接得到def getMax_page(home_url): try: # 爬取home_url html = requests.get(home_url, headers = header, timeout=30) # 状态码 html.raise_for_status() # 设置编码格式 html.encoding = html.apparent_encoding except: return home_url + " html爬取失败！" # 解析html.text /使用 lxml 解析器 soup = BeautifulSoup(html.text, 'lxml') return soup.find('div', 'page').find('a', 'last')['href'].split('/')[-1]# 获取每套图最大pagedef getMax_pic_page(href): try: html = requests.get(href,headers = header) html.raise_for_status() html.encoding = html.apparent_encoding except: return url + " html爬取失败！" soup = BeautifulSoup(html.text, 'lxml') return int(soup.find('div', class_ = 'page').find_all('a')[-2].text)# 对网站的每页的套图进行一一爬取def craw_pic(max_page): # 遍历全站page for n in range(1, int(max_page) + 1): # 如果page是首页url='http://www.mmjpg.com' if n == 1: url = 'http://www.mmjpg.com' # 否则就是 home_page + str(n) else: url = home_page + str(n) try: html = requests.get(url, headers = header, timeout = 30) html.raise_for_status() html.encoding = html.apparent_encoding except: return url + " html爬取失败！" soup = BeautifulSoup(html.text, 'lxml') # 获得套图的img标签 all_img = soup.find('div', class_='pic').find('ul').find_all('span', class_='title') # 遍历img标签 for a in all_img: # 获得套图标题 title = a.a.get_text() if(title != ''): print('开始爬取：' + title) # win 不能创建带？ 的目录 if(os.path.exists(path + title.strip().replace('?', ''))): print('目录已存在') flag = 1 else: # 创建文件夹 os.makedirs(path + title.strip().replace('?', '')) flag = 0 # 进入目标文件夹 os.chdir(path + title.strip().replace('?', '')) # 得到套图首图url href = a.a['href'] if(flag == 1 and len(os.listdir(path + title.strip().replace('?', '')))): print('已经保存完毕，跳过') continue # 遍历套图的url for num in range(1, getMax_pic_page(href) + 1): pic_page = href + '/' + str(num) try: html = requests.get(pic_page, headers = header, timeout = 30) html.raise_for_status() html.encoding = html.apparent_encoding except: return href + ' html爬取失败！' soup = BeautifulSoup(html.text, 'lxml') pic_url = soup.find('div', class_='content').find('a').img['src'] print('正在爬取：' + pic_url) # 图片的名称 file_name = pic_url.split('/')[-1] imghtml = requests.get(pic_url, headers = header) f = open(file_name, 'wb') # 保存图片 f.write(imghtml.content) # 关闭图片 f.close() print('爬取完成：' + title) if n == max_page: print('全站爬取完成') if __name__ == "__main__": max_page = getMax_page(home_url) craw_pic(max_page) ''' # 多线程 pool = Pool(processes=cpu_count()) try: print("开始爬取") pool.map(craw_pic, max_page) print("爬取结束！") except Exception as e: # 失败后睡眠30s time.sleep(30) print("开始爬取") pool.map(craw_pic, max_page) print("爬取结束！") ''' 参考]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python Craw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java访问文件夹]]></title>
    <url>%2F2018%2F02%2F16%2Fjava-FileClass%2F</url>
    <content type="text"><![CDATA[具体思路：一用File类，获取需要访问的文件，二创建getFile(File file)方法判断是否存在该文件，不存在直接return,存在打印文件名称，三判断参数是否为文件夹，是则打印其大小，四递归调用。优化分层：getFile方法增加div参数，用来定义文件的层级，分层功能写在打印名称之前，优化统计：定义静态全局变量sum。 代码：12345678910111213141516171819202122232425262728293031323334353637383940import java.io.File;public class testFile &#123; static long sum = 0; public void getFile(File file,int div) &#123; //判断是否存在该文件 if(file == null) &#123; return; &#125; //打印层次 for(int i = 0; i &lt; div; i++) &#123; System.out.print("\t"); &#125; //打印名称 System.out.print(file.getName()); //判断参数是否为文件夹 if(!file.isDirectory()) &#123; //是文件就打印文件的大小(字节) System.out.println("\t"+file.length() + "字节"); //计算总文件大小 sum = sum+file.length(); return; &#125; //递归调用 System.out.println(); File[] fils = file.listFiles(); for(int i = 0; i &lt; fils.length; i++) &#123; getFile(fils[i],div + 1); &#125; &#125; public static void main(String[] args) &#123; File file = new File("F:\\python文件"); testFile tf = new testFile(); tf.getFile(file,0); System.out.println("总文件大小："+sum+"字节"); &#125;&#125; 运用结果： 12345678910111213141516171819202122232425python文件 lover-time.html 2307字节 mzitu.html 26922字节 pygame1.py 276字节 python day_01 first.py 3179字节 frest.py 3568字节 second.py 179字节 test.py 1074字节 third.py 266字节 three.py 2684字节 day_02 first.py 1843字节 hdf myfile.txt 11字节 myfile1.txt 0字节 myfile3.txt 7字节 second.py 1446字节 新建文本文档 (2).txt 0字节 新建文本文档.txt 0字节 python网络爬虫与信息提取 china_unwocity.py 7413字节 requstes.py 1618字节总文件大小：52793字节]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习十一]]></title>
    <url>%2F2018%2F01%2F25%2Fpython%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[文件操作 文件操作1.open() 打开或者创建一个文件 格式：open(&apos;文件路径&apos;，&apos;打开模式&apos;) 返回值：文件io对象 打开模式一共N种： w模式： 写模式write 文件不存在时会创建文件，如果文件已存在则清空文件 r模式： 读模式read 文件不存在就报错，存在则准备读取文件 a模式： 追加模式append 文件不存在则新建，文件存在则在文件末尾追加内容 x模式： 抑或模式xor 文件存在则报错，文件不存在则新建文件 b模式： 二进制模式： 辅助模式不能单独使用 +模式： 增强模式plus: 也是辅助模式不能单独使用 123456789101112131415161718192021222324252627282930313233343536373839404142# w模式 每次打开都清空文件内容fp = open(&quot;myfile.txt&quot;,&quot;w&quot;)result = fp.write(&quot;qwwerty&quot;)fp.close()# r模式 只读fp = open(&quot;myfile.txt&quot;,&quot;r&quot;)result = fp.read()fp.close()print(result)&apos;&apos;&apos;结果如下：qwwerty&apos;&apos;&apos;# a模式 原有文件内容上追加新内容fp = open(&quot;myfile.txt&quot;,&quot;a&quot;)result = fp.write(&quot;1234&quot;)fp.close()&apos;&apos;&apos;文件内容如下：qwwerty1234&apos;&apos;&apos;&apos;&apos;&apos;# x模式 抑或模式 文件存在则报错，文件不存在则新建文件 fp = open(&quot;myfile3.txt&quot;,&quot;x&quot;)result = fp.write(&quot;qwwerty&quot;)fp.close()&apos;&apos;&apos;# b模式fp = open(&apos;myfile.txt&apos;,&apos;rb&apos;) #b 二进制模式 binary,辅助使用，不能单个使用result = fp.read()print(result) 2.readline() 读取一行文件 格式：文件io对象.readline() 返回值：一行内容的字符串 格式：文件io对象.readline(字符长度) 返回值：一行内容的字符串 注意：字符长度 &lt; 当前内容，则读取指定长度的字符串，并且一次再读取还是这个一行中获取没有读取内容。 字符长度 &gt;= 当前行内容，直接读取当前行 3.readlines() 将文件中的内容读取到序列当中 格式：文件io对象.readlines() 返回值：列表 格式：文件io对象.readlines(字符长度) 返回值：列表 注意：读取的行数由字符长度决定，如果字符长度读取了N行后，还剩下没有读取，则直接读取下一行进来 4.writelines() 将序列写入文件中 格式：文件io对象.writelines(序列) 返回值：None 5.truncate() 字符串截取操作 格式：文件io对象.truncate(字节长度) 返回值：截取的字节长度 6.tell() 查看当前指针(光标)的位置 7.seek() 调整指针的位置 格式：文件io对象.seek(N) 将指针直接调整到N的位置，从头计算第N个位置 返回值：指针的位置 格式：文件io对象.seek(偏移位置，参考点方式) 返回值：指针的位置 参考点方式： 0 从文件的最开头计算偏移 1 从文件的当前指针位置开始计算偏移 2 从文件末尾开始计算偏移 os模块os 操作系统的简称（对操作系统进行操作） 导入os模块 import os 1.os模块的函数 getcwd() 获取当前工作目录 格式：os.getcwd() 返回值:路径字符串 chdir() 修改当前工作目录 格式：os.chdir() 返回值：None listdir() 获取指定文件夹中的所有文件和文件夹组成的列表 格式：os.listdir(目录路径) 返回值：目录中内容名称的列表 mkdir() 创建一个目录/文件夹 格式：os.mkdir(目录路径) 返回值：None rmdir() 删除一个目录/文件夹(必须空文件) 格式：os.rmdir(目录路径) 返回值：None makedirs() 递归创建目录 格式：os.makedirs(c:/d/c/f)(c:/d,c:d/c 都不存在) 返回值：None removedirs() 递归删除目录 格式：os.removedirs(c:d/c/f)(c:/d/,c:d/c,c:d/c/f 都必须为空) 返回值：None rename() 修改文件和文件夹 格式:os.rename(源文件或文件夹，目标文件或文件夹) 返回值：None stat 获取文件信息 格式：os.rename(文件路径) 返回值：包含文件信息的元组 system() 执行系统命令 格式：os.system(系统命令) 返回值：整型 注意：慎用！ getenv() 获取系统环境变量 格式：os.getenv(环境变量名) 返回值：字符串 putenv() 增加系统环境变量 格式：os.putenv(环境变量名称，值) 返回值：无 exit() 退出当前执行命令，直接关闭当前操作 格式：exit() 返回值：无 os.environ 可以直接获取所有环境变量的信息组成的字典，如果希望更改环境变量，并且可以查询得到，就需要对os.environ进行操作 os.path 代表一个子模块 os.curdir 表示当前目录 os.pardir 表示上一层文件夹的路径 os.name 当前系统的内核名称 win -&gt; nt linux/unix -&gt; posix os.sep 当前系统的路径分割体符号 win -&gt; \ linux/nuin -&gt; / os.extsep 当前系统中文件名和后缀之间的分割符号，所有系统都是 os.linesep os.linesep 当前系统的换行符号 win -&gt; \r\n linux/unix -&gt; \n os函数 abspath() 将一个相对路径转化为绝对路径 格式：os.path.abspath(相对路径) 返回值：绝对路径字符串 basename() 获取路径中的文件夹或者文件名称（只要路径的最后一部分） dirname() 获取路径中的路径部分（出去最后一部分） 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习十]]></title>
    <url>%2F2018%2F01%2F24%2Fpython%E5%AD%A6%E4%B9%A0%E5%8D%81%2F</url>
    <content type="text"><![CDATA[列表推导式 列表专有函数 元组成员检测 元组中的序列函数 元组的推导式 元组的函数 字典创建 字典专有函数 集合专有函数 列表推导式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&quot;&quot;&quot;# 简单的列表推导式list1 = [&apos;小工&apos;,&apos;小明&apos;,&apos;小丽&apos;,&apos;小敏&apos;,&apos;小国&apos;]result = [&apos;@&apos; + i + &apos;@&apos; for i in list1]print(result)&apos;&apos;&apos;结果如下：[&apos;@小工@&apos;, &apos;@小明@&apos;, &apos;@小丽@&apos;, &apos;@小敏@&apos;, &apos;@小国@&apos;]&apos;&apos;&apos;# 带有判断条件的列表推导式list1 = [12,23,4,5,6,74,]result = [i for i in list1 if i % 2 ==0]print(result)&apos;&apos;&apos;结果如下：[12, 4, 6, 74]&apos;&apos;&apos;# 多个列表的推导式list1 = [&apos;小工&apos;,&apos;小明&apos;,&apos;小丽&apos;,&apos;小敏&apos;,&apos;小国&apos;]list2 = [&apos;吃饭&apos;,&apos;读书&apos;,&apos;写作业&apos;,&apos;想人&apos;,&apos;上班&apos;]result = [i + &apos;=&gt;&apos; + j for i in list1 for j in list2 ]print(result)&apos;&apos;&apos;结果如下:[&apos;小工=&gt;吃饭&apos;, &apos;小工=&gt;读书&apos;, &apos;小工=&gt;写作业&apos;, &apos;小工=&gt;想人&apos;, &apos;小工=&gt;上班&apos;,&apos;小明=&gt;吃饭&apos;, &apos;小明=&gt;读书&apos;, &apos;小明=&gt;写作业&apos;, &apos;小明=&gt;想人&apos;, &apos;小明=&gt;上班&apos;,&apos;小丽=&gt;吃饭&apos;, &apos;小丽=&gt;读书&apos;, &apos;小丽=&gt;写作业&apos;, &apos;小丽=&gt;想人&apos;, &apos;小丽=&gt;上班&apos;,&apos;小敏=&gt;吃饭&apos;, &apos;小敏=&gt;读书&apos;, &apos;小敏=&gt;写作业&apos;, &apos;小敏=&gt;想人&apos;, &apos;小敏=&gt;上班&apos;,&apos;小国=&gt;吃饭&apos;, &apos;小国=&gt;读书&apos;, &apos;小国=&gt;写作业&apos;, &apos;小国=&gt;想人&apos;, &apos;小国=&gt;上班&apos;]&apos;&apos;&apos;# 多个列表推导式，带有判断条件1num1 = [2,4,6,8,]num2 = [4,16,36,64]result = [i + y for i in num1 for y in num2 if y == i*i]print(result)&apos;&apos;&apos;结果如下 ：[6, 20, 42, 72]&apos;&apos;&apos;&quot;&quot;&quot;# 多个列表推导式，带有判断条件1list1 = [&apos;小工&apos;,&apos;小明&apos;,&apos;小丽&apos;,&apos;小敏&apos;,&apos;小国&apos;]list2 = [&apos;吃饭&apos;,&apos;读书&apos;,&apos;写作业&apos;,&apos;想人&apos;,&apos;上班&apos;]result = [i + &apos;=&gt;&apos; + j for i in list1 for j in list2 if list1.index(i) == list2.index(j)]print(result)&apos;&apos;&apos;结果如下：[&apos;小工=&gt;吃饭&apos;, &apos;小明=&gt;读书&apos;, &apos;小丽=&gt;写作业&apos;, &apos;小敏=&gt;想人&apos;, &apos;小国=&gt;上班&apos;]&apos;&apos;&apos; 列表专有函数 append() 向列表中的末尾添加新元素 格式：列表.append(值) 返回值：None 注意：新添加的值在列表的末尾，该函数直接操作原有列表 clear() 清空列表中所有元素 格式：列表.clear() 返回值：None copy() 复制列表 格式: 列表.copy() 返回值:新的列表 count() 计算某个元素出现的次数 格式：列表.count(值) 返回值：整数 extend() 将一个列表继承另一个列表 格式：列表.extend(序列) 返回值：None 注意：直接改变原有列表 index() 获取某个在列表中的索引 格式：列表.index(值) 返回值:整数 注意：值不存在与列表时抛出异常错误！ pop() 在列表中移除一个元素 格式：列表.pop([牵引]) 返回值：无 注意：没有指定索引，默认移除最后一个元素 remove() 移除指定的值 格式：列表.remove(值) 返回值：元 注意：如果有索引的清空下推荐使用pop移除，效率比remove高 reverse() 列表反转操作 格式:列表.reverse() 返回值：None sort() 列表排序 格式:列表.sort() 按照从小到大排序(数字) 格式：列表.sort(reverse = True) 按照从大到小排序(数字) 格式：列表.sort(key = 函数) 对值进行指定的函数处理之后再小到大排序 格式：列表.sort(key = 函数,reverse = True) 对值进行指定的函数处理之后再大到小排序 返回值：None 注意：直接改变原有列表 12345678list1 = [&apos;s&apos;,&apos;E&apos;,&apos;A&apos;,&apos;d&apos;]list1.sort(key = str.upper)print(list1)&apos;&apos;&apos;结果如下：[&apos;A&apos;, &apos;d&apos;, &apos;E&apos;, &apos;s&apos;]&apos;&apos;&apos; 元组成员检测格式： 值 in 元组 返回值：布尔值 作用：检测一个值是否在元组当中 格式： 值 not in 元组 返回值：布尔值 作用：检测一个值是否不在元组当中 12345678tuple1 = (&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;,&apos;赵六&apos;)result = &apos;张三&apos; in tuple1# &apos;张三&apos; not in tupel1print(result)&apos;&apos;&apos;结果如下：True&apos;&apos;&apos; 元组中的序列函数 len() 获取元组的长度 max() 获取元组中的最大值 min() 获取元组中的最小值 tuple() 创建空元组或者将其他序列转化为元组类型 元组的推导式方法同列表推导式 元组的函数 index() 获取指定值在元组中的索引值 格式:元组.index(值) 返回值:整数 count() 计算某个值在元组中出现的次数 格式：元组.count(值) 返回值：整数 ## 字典创建 格式： 变量：dict(zip((键，键，键...),(值，值，值...))) 字典专有函数 clear() 清空字典 copy() 复制字典 fromkeys() 使用指定的序列作为创建字典 格式：字典.fromkeys(序列，值) 返回值：字典 get() 根据键获取指定的值 格式：字典.get(键[,默认值]) 返回值：如果键不存在，则使用默认值，如果 没有默认值则返回None items() 将字典的键值转化成类型似元组的形式，方便遍历 格式：字典.items() 返回值：类似元组的类型 keys() 将字典的所有键组成一个序列 格式：字典.keys() 返回值：序列 values() 将字典的所有值组成一个序列 格式：字典.values() 返回值：序列 pop() 移除字典中指定的元素 格式：字典.pop(键[,默认值]) 返回值：被移除的键对应的值 注意：如果键不存在，则报错，如果键不存在，默认值设置，则返回默认值 popitem() 移除字典中的键值对 格式：字典.popitme() 返回值：键值对组成的元组 注意：弹一个原字典就少一个，字典为空就不可以弹，会报错 setdefault() 添加一个元素 格式：字典.setdefault(键，值) 返回值：None 注意：添加是键存在则不进行任何操作，键不存在则添加，添加是不写值，默认None值 update() 格式：字典.update(键 = 值) 返回值：None 集合专有函数 add() 向集合中添加一个元素 格式：集合.add(值) 返回值：None 注意:直接改变原有集合 pop() remove() clear() copy() discard() 删除集合中的某个元素 格式：集合.discard(值) 返回值：None 注意：直接改变原有集合 remove移除非成员值会报错，discard移除非成员不会报错 difference() 差集 difference_update() 差集更新，将差集赋值给第一人集合 intersection() 交集 intersection_upate() 交集更新 union() 并集 update() 并集更新 issuperset() 检测一个集合是不是另一个集合的超集 格式：集合1.issuperset(集合2) 返回值：布尔值 issubset() 检测一个集合是不是另外一个集合的字节 格式：集合1.issubset(集合2) 返回值：布尔值 isdisjoint() 检测2个集合是否相交 格式：集合1.isdisjoint(集合2) 返回值：布尔值 symmetric_difference() 对称差集操作 格式：集合1.symmetric_difference(集合2) 返回值：集合 操作：将集合1和集合2不相交的部分取出组成的新的集合 symmetric_difference_update() 对称差集更新操作 冰冻集合/固定集合 frozenset12345678910111213# 创建空的冰冻集合fset = frozenset()print(type(fset))print(fset)# 创建具有元素的集合fset = frozenset([&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;,&apos;赵六&apos;])print(type(fset))print(fset)# 冰冻集合，不能修改 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习九]]></title>
    <url>%2F2018%2F01%2F23%2Fpython%E5%AD%A6%E4%B9%A0%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[string模块 ascill 数学模块 模块提供的常见值 随机模块 string模块import string ascill_letters 获取所有ascilll码中字母字符的字符串(包含大写和小写) ascill_uppercase 获取所有ascill码中的大写英文字母 ascill_lowercase 获取所有ascill码中的ihpg英文字母 digits 获取所有的10进制数字字符 octdigits 获取所有的8进制数字字符 hexdigits 获取所有16进制数字字符 printable 获取所有可以打印的字符 whitespace 获取所有空白字符 punctuation 获取所有的标点符号 ascii美国标准信息交换代码 定制了128个常用字符，主要是英文，数字，标点符号及键盘中其他按键对应的整数值。 python中与ascill码相关的两个函数： chr() 将ascill编码转化为字符 格式：chr(ascill码) 返回值：字符 ord() 将字符转化为对应的ascii码 格式：ord(字符) 返回值：ascill码 数学模块import math ceil() 向上取整操作 格式：math.ceil(数值) 返回值：整型 floor() 向下取整操作 格式：math.floor(数值) 返回值：整型 round() 四舍五入操作 格式：round(数值) 返回值：整数 注意：该函数不在math模块当中。 pow() 计算一个数值的N次方 格式：math.pow(底数，幂) 返回值：浮点类型 注意：该操作相当于**运算结果为浮点型 sqrt() 开平方 格式：math.sqrt(数值) 返回值：浮点型 fabs() 对一个数值获取其绝对值操作 格式：math.fabs(数值) 返回值：浮点数 abs() 对一个数值获取其绝对值操作 格式：abs(数值) 返回值：可能是整数能浮点数 注意：abs() 它是内建函数，同时返回值根据原类型决定 modf() 将一个浮点拆成整数和小数部分组成的元组 格式：math.modf(数值) 返回值：元组 （小数部分，整数部分） copysign() 将第二个的正负号复制给第一个数 格式：math.copysign(值1，值2) 返回值：值1 符号是值2的正负 fsum() 将一个序列的数值进相加求和 格式：math.fsum(序列) 返回值：浮点数 sum() 将一个序列的数值进行相加求和 格式：sum(序列) 返回值：数值类型 模块提供的常见值pi 圆周率 3.14159265358793 e 自然数 2.718181828459045 随机模块import random random() 获取0-1之间的随机小数包含0不包含1 格式：random.random() 返回值：浮点数 choice() 随机获取列表中的值 格式：random.choice(序列) 返回值：序列中的某个值 shuffle() 随机打乱序列 格式：random.shffle(序列) 返回值：打乱顺序的序列 randrage() 获取指定范围内指定间隔的随机整数 格式：random.ranges(开始值，结束值[,间隔值]) 返回值：整数 uniform() 随机获取指定范围内的所有数值包含小数 格式：random.uniform(开始值，结束值) 返回值：随机返回范围内的所有数值（浮点型） 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习八]]></title>
    <url>%2F2018%2F01%2F22%2Fpython%E5%AD%A6%E4%B9%A0%E5%85%AB%2F</url>
    <content type="text"><![CDATA[中国大学排名定向爬虫 中国大学排名定向爬虫1234567891011121314151617181920212223242526272829303132333435#CrawUnivRankingA.pyimport requestsfrom bs4 import BeautifulSoupimport bs4 def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot;def fillUnivList(ulist, html): soup = BeautifulSoup(html, &quot;html.parser&quot;) for tr in soup.find(&apos;tbody&apos;).children: if isinstance(tr, bs4.element.Tag): tds = tr(&apos;td&apos;) ulist.append([tds[0].string, tds[1].string, tds[3].string]) def printUnivList(ulist, num): tplt = &quot;&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;&quot; print(tplt.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;,chr(12288))) for i in range(num): u=ulist[i] print(tplt.format(u[0],u[1],u[2],chr(12288))) def main(): uinfo = [] url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos; html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 20) # 20 univsmain() 结果如下： 12345678910111213141516171819202122======== RESTART: F:\python文件\MOCC_python网络爬虫与信息提取\china_unwocity.py ======== 排名 学校名称 总分 1 清华大学 95.9 2 北京大学 82.6 3 浙江大学 80 4 上海交通大学 78.7 5 复旦大学 70.9 6 南京大学 66.1 7 中国科学技术大学 65.5 8 哈尔滨工业大学 63.5 9 华中科技大学 62.9 10 中山大学 62.1 11 东南大学 61.4 12 天津大学 60.8 13 同济大学 59.8 14 北京航空航天大学 59.6 15 四川大学 59.4 16 武汉大学 59.1 17 西安交通大学 58.9 18 南开大学 58.3 19 大连理工大学 56.9 20 山东大学 56.3 中国大学排名定向爬虫 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习七]]></title>
    <url>%2F2018%2F01%2F22%2Fpython%E5%AD%A6%E4%B9%A0%E4%B8%83%2F</url>
    <content type="text"><![CDATA[requests库 beautiful soup库 基于bs4库的HTML内容的遍历方法 简写形式 find的扩展方法 requests库1.安装requests库 打开cmd -&gt; pip install requests 2.操作实例 12345678910# 引入requests库import requests# 设置爬取的网页r = requests.get(&quot;http://www.baidu.com&quot;)# 打印爬取状态码print(r.status_code)# 设置编码格式 r.encoding = &quot;utf-8&quot;# 打印爬取网页的html代码print(r.text) 3.requests库的七个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应HTTP的HEAD requests.post() 向HTML页面提交POST请求的方法，对应HTTP的POST requests.put() 向HTML页面提交PUT请求的方法，对应HTTP的PUT requests.patch() 向HTML页面提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应于HTTP的DELETE 4.get方法 格式： r = requests.get(url,params = None,**kwargs) | | | | Response Requset url:拟获取页面的url链接 params:url中额外参数，字典或字节流格式，可选 **kwargs:12个控制访问的参数 5.Response对象的属性 属性 说明 r.status_code HTTP请求的返回状态，200表示连接成功，404表示失败 r.text HTTP响应内容的字符串形式，即，url对应的页面内容 r.encoding 从HTTP headr 中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式(备选编码方式) r.content HTTP响应内容的二进制形式 r.encoding：如果header中不存在charset，则认为编码为ISO-8859-1 r.apparent_encoding:根据页面内容分析出的编码方式 6.理解Resquests库的异常 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败，拒绝连接等 requests.HTTPError HTTP错误异常 requests.URLRequird URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 r.raise_for_status() : 如果不是200，产生异常requests.HTTPerror 1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status()#如果状态不是200，引发HTTPError异常 r.encoding = r.apparent_encoding return r.text except: return &quot;产生异常&quot;if __name__ == &quot;__main__&quot;: url = &quot;//www.baidu.com&quot; print(getHTMLText(url)) beautiful soup库beautiful soup库是解析，遍历，维护“标签树”的功能库， 1.安装pip install beautifulsoup4 2.测试 1234567891011import requestsr = requests.get(&quot;http://python123.io/ws/demo.html&quot;)print(r.status_code)print(r.text)dome = r.textfrom bs4 import BeautifulSoupsoup = BeautifulSoup(dome , &quot;html.parser&quot;) # html.parser 解析器print(soup.prettify()) 3.Beautiful soup库解析器 解析器 使用方法 条件 bs4的HTML解析器 BeautifulSoup(mk,”html.parser”) 安装bs4库 lxml的html解析器 BeautifulSoup(mk,”lxml”) pip install lxml lxml的XML解析器 BeautifulSoup(mk,”html.parser”) pip install lxml html5lib的解析器 BeautifulSoup(mk,”html5lib”) pip install html5lib 4.Beautiful Soup类的基本元素 基本元素 说明 Tag 标签，最基本的信息组织单元分别用&lt;&gt;和&lt;/&gt;标明开头和结尾 Name 标签的名字,…的名字是’p’,格式：.name Attributes 标签的属性，字典形式组织，格式：.attrs NavigableString 标签内非属性字符串，&lt;&gt;…&lt;/&gt;中字符串，格式：.string comment 标签内字符串的注释部分，一种特殊的Comment类型 基于bs4库的HTML内容的遍历方法1.标签树的下行遍历 属性 说明 .contents 子节点的列表，将所有儿子节点存入列表 .children 子节点的迭代类型，与.contents类似，用于循环遍历儿子节点 .descendants 子孙节点的迭代类型，包含所有子孙节点，用于循环遍历 # 遍历儿子/子孙节点 for child in soup.body.children: print(child) 2.标签树的上行遍历 属性 说明 .parent 节点的父亲标签 .parents 节点先辈标签的迭代类型，用于循环遍历先辈节点 3.标签树的平行遍历 属性 说明 .next_sibling 返回按照HTML文本顺序的下一个平行标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签 4.&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs) 返回一个列表类型，存储查找的结果 name:对标签名称的检索字符串 attrs:对标签属性值的检索字符串，可标注属性检索 recursive:是否对子孙全部检索，默认True string:&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串 **kwargs: 简写形式(..) &lt;==&gt; .find_all(…)soup(..) &lt;==&gt; soup.find_all(..) find的扩展方法 方法 说明 &lt;&gt;.find() 搜索且只返回一个结果，字符串类型，同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索.，字符串类型，同.find_all()参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果，字符串类型，同.find_all()参数 &lt;&gt;.find_next_silbings() 在后续平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_next_silbing() 在后续平行节点中返回一个结果，返回字符串类型，同.find_all()参数 &lt;&gt;.find_preious_siblings() 在前序平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_preious_sibling() 在前序平行节点中返回一个结果，返回字符串类型，同.find_all()参数 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习六]]></title>
    <url>%2F2018%2F01%2F17%2Fpython%E5%AD%A6%E4%B9%A0%E5%85%AD%2F</url>
    <content type="text"><![CDATA[nonlocal lambda表达式 递归函数 字符串操作 字符串函数 format 字符格式化操作 nonlocalnonlocal关键字的意义，不是局部变量，当然它也不是全局变量，通常用于内部函数中使用外部函数的局部变量。 注意： 1.如果内部函数想使用全局变量，那么应该使用global声明变量(函数最外层的全局变量) 2.如果内部函数使用的是外部函数的局部变量，那么应该使用nonlocal声明 123456789101112131415# 声明一个外部函数def outer(): # 声明一个变量(肯定不是全局变量) x = 5 # 声明一个内部函数 def inner(): nonlocal x # 声明x不是局部变量 x += 9 print(x) # 调用函数 inner()# 调用outerouter() lambda表达式lambda表达式是一种简洁的函数，该表达不是正常的函数结构，而是属于表达式的类型。 基本格式： lambda 参数，参数...：函数功能代码 带分支格式： lambda 参数，参数...:值1 if 条件表达式 else 值2 调用函数格式： lambda 参数，参数..:其他函数(...) lambda表达式的优缺点： 优点： 1.书写简单不需要def关键字 2.不需要起函数名(匿名函数) 3.看起来高大上 缺点： 1.lambda表达式功能受限，无法使用循环和多项分支复杂的操作，不适合lambda表达式 123456789101112# 声明一个lamdba表达式1mylamb = lambda x,y:x+y#相当于一个函数#def func(x,y):# return x+yresult = mylamb(3,5)print(result) 123456# 声明一个lamdba表达式2mylamb = lambda name = &apos;a&apos;:&apos;aqqje&apos; if name == &apos;a&apos; else &apos;yjgmy&apos;result = mylamb()print(result) 1234567# 声明一个lamdba表达式调用函数mylamb = lambda x:type(x)result = mylamb(10)print(result) 递归函数在函数内调用当前函数本身的函数就是递归函数 12345678910111213141516# 递归函数def digui(num): print(num) # 判断条件，不改变num if num &gt; 0: digui(num - 1) else: print(&apos;===============&apos;) print(num) digui(3) 结果如下:1234567893210===============012+ 字符串操作+ 字符串连接操作 * 字符复制操作 [] 字符串索引操作，通过索引访问指定位置的字符，索引从0开始 [::] 字符串取片操作 完整格式： [开始索引:结束索引:间隔值] [:结束索引] 从开头到指定位置之前截取 [开始索引:] 从指定位置截取到最后 [开始索引:结束索引] 从开始索引截取到结束索引之前(不包含结束位置) [:] 截取整个字符串 r&apos;字符串&apos; 元字符串，所有字符串的转义字符不会转义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# + 字符串连接操作str1 = &apos;你好，&apos;str2 = &apos;旧时光&apos;result = str1 + str2print(result)# 你好，旧时光# * 字符复制操作strone = &apos;★★★★★★★★\n&apos;strten = strone * 10print(strten)&apos;&apos;&apos;★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★&apos;&apos;&apos;# 字符串索引操作str1 = &apos;QWERTYUIOPASDFGHJKLZXCVBNM&apos;print(str1[23])# B# 字符串取片操作 字符串[开始索引:结束索引:间隔值]str1 = str1 = &apos;QWERTYUIOPASDFGHJKLZXCVBNM&apos;# 从开头到指定位置之前截取print(str1[:6])QWERTY# 从指定位置截取到最后print(str1[21:])# CVBNMprint(str1[-5:])# CVBNM# 从开始索引截取到结束索引之前(不包含结束位置)print(str1[7:12])# IOPAS# 截取整个字符串print(str1[:])# QWERTYUIOPASDFGHJKLZXCVBNM# 按照指定间隔数截取字符串print(str1[:25:2])# QETUOADGJLXVN 字符串函数1.capitalize() 字符串首字母大写 格式：字符串.capitalize() 返回值：新字符串 2.title() 将每个单词首字母大写 格式：字符串.title() 返回值：新字符串 3.upper() 将所有字母大写 格式：字符串.upper() 返回值：新字符串 4.lower() 将所有字母小写 格式：字符串.lower() 返回值：新字符串 5.swapcase() 大小写互换 格式：字符串.swapcase() 返回值：新字符串 6.len() 计算字符串的长度 格式：len(字符串) 返回值：整型 7.count() 计算指定字符串出现的次数 格式:字符串.count(查找字符串[,开始索引[,结束索引]]) 返回值：整型 8.find() 查找指定字符串第一次出现的位置 格式：字符串.find(查找字符串[,开始索引[,结束索引]]) 返回值：整型 找不到返回 -1 9.index() 查找指定字符串第一次出现的位置 格式：字符串.index(查找字符串[,开始索引[,结束索引]]) 返回值：整型 找不到抛出错误！ 10.startwith() 检测字符串是否以指定的字符串开头 格式：字符串.startwith(查找字符串) 返回值：布尔值 11.endswith() 检测字符串是否以指定的字符串结尾 格式：字符串.endswith(查找字符串) 返回值：布尔值 12.isupper() 检测一个字符串中的英文是否都是大写字母，符号不算 格式：字符串.isupper() 返回值：布尔值 13.islower() 检测一个字符串中的英文是否都是小写字母，符号不算 格式：字符串.islower() 返回值：布尔值 14.isalsum() 检测字符串是否由数字，字母和文字等组成 格式：字符串.isalum() 返回值：布尔值，汉字当作普通字符处理，没有标点和特殊字符就是真，空字符串为False 15.isalpha() 检测字符串是否由字母和文字等组成 格式：字符串.isalpha() 返回值：布尔值，汉字当作普通字符处理，空字符串为False 16.isdigit() 检测字符串是否由纯数字组成 (十进制) 格式：字符串.isdigit() 返回值：布尔值 17.isspace() 检测字符串是否空白字符组成 格式：字符串.isspace() 返回值：布尔值 18.istitle() 检测是否符合标题要求 （整数） 格式：字符串.istitle() 返回值：布尔值 19.isnumeric() 检测是否是数值字符串 格式：字符串.isnumeric() 返回值：布尔值 20.isdecimal() 检测字符串是否是纯数值字符串组成 格式：字符串.isdecimal() 返回值：布尔值 21.split() 使用指定的字符串切割字符串 格式：字符串，split(切割指定字符串) 返回值：列表 22.splitlines() 将字符串按照换行位置进行切割操作 格式：字符串.splitlines() 返回值：列表 23.join 将列表中的内容按照指定字符连接成一个字符串 格式：连接字符串。join(列表) 返回值：字符串 24.zfill 在原有字符串长度不足指定长度，用0填充 格式：字符串.zfill(指定字符串长度) 返回值：字符串 不足的长度使用0填充，原来的字符串内容靠右 26.center() 指定字符串长度，并且使得元字符串内容剧中，其余位置使用指定字符串填充 格式：字符串.center(指定字符串长度[,&apos;指定字符串&apos;]) 返回值：字符串 填充字符默认空格，可以指定其他 27.ljust() 指定字符串长度，并且使得元字符串内容靠左，其余位置使用指定字符串填充 格式：字符串.ljust(指定字符串长度[,&apos;指定字符串&apos;]) 返回值：字符串 填充字符默认空格，可以指定其他 28.rjust() 指定字符串长度，并且使得元字符串内容靠右，其余位置使用指定字符串填充 格式：字符串.rjust()(指定字符串长度[,&apos;指定字符串&apos;]) 返回值：字符串 填充字符默认空格，可以指定其他 29.strip() 去掉左右两侧的指定字符，默认空格 格式：字符串.strip([指定字符]) 返回值:字符串 30.lstrip() 去掉左侧的指定字符，默认空格 格式：字符串.lstrip()([指定字符]) 返回值:字符串 31.rstrip() 去掉右侧的指定字符，默认空格 格式：字符串.rstrip()([指定字符]) 返回值:字符串 32.maketrans() 制作用于字符替换的映射表 格式：字符串.maketrans(&apos;查找字符&apos;，&apos;替换字符&apos;) 两个字符必须长度相等 返回值：字典 33.translate() 进行字符串替换操作 格式：字符串.translate(映射表) 返回值：字符串 替换之后的字符串 format 字符格式化操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 方法1 位置参数# 非关键字参数str1 = &apos;&#123;&#125;位和&#123;&#125;位操作系统是指：CPU一次处理数据的能力是&#123;&#125;位还是&#123;&#125;位&apos;result1 = str1.format(&apos;32&apos;,&apos;64&apos;,&apos;32&apos;,&apos;64&apos;)print(result1)# 多次利用参数str2 = &apos;&#123;0&#125;位和&#123;1&#125;位操作系统是指：CPU一次处理数据的能力是&#123;0&#125;位还是&#123;1&#125;位&apos;result2 = str2.format(&apos;32&apos;,&apos;64&apos;)print(result2)# 关键字参数str3 = &apos;&#123;(threetwo&#125;位和&#123;sixforth&#125;位操作系统是指：CPU一次处理数据的能力是&#123;(threetwo&#125;位还是&#123;sixforth&#125;位&apos;result3 = str3.format(threetwo = &apos;32&apos;,sixforth = &apos;64&apos;)print(result3) # 方法2 通过下标str4 = &apos;&#123;0[0]&#125;位和&#123;0[1]&#125;位操作系统是指：CPU一次处理数据的能力是&#123;0[0]&#125;位还是&#123;0[1]&#125;位&apos;result4 = str4.format([&apos;32&apos;,&apos;64&apos;])print(result4)str5 = &apos;&#123;0[t]&#125;位和&#123;0[f]&#125;位操作系统是指：CPU一次处理数据的能力是&#123;0[0]&#125;位还是&#123;0[1]&#125;位&apos;result5 = str5.format(&#123;&apos;t&apos;:&apos;32&apos;,&apos;f&apos;:&apos;64&apos;&#125;)print(result5)# 方法3 格式限定符#填充与补齐str6 = &apos;速度。重新定义&#123;:□&gt;10&#125;&apos;# 速度。重新定义□□□□□□新的高度 【靠右齐，且补满10】str6 = &apos;速度。重新定义&#123;:□&lt;10&#125;&apos;# 速度。重新定义□□□□□□新的高度 【靠左齐，且补满10】str6 = &apos;速度。重新定义&#123;:□^ 10&#125;&apos;# 速度。重新定义□□□□□□新的高度 【靠剧中齐，且补满10】result6 = str6.format(&apos;新的高度&apos;)print(result6)# 精度计算str7 = &apos;快捷快递价格表，山西省1kg&#123;:.1f&#125;&apos; # 浮点数保留1位小数result7 = str7.format(3.55777)print(result7)# 进制进制操作（默认十进制）&#123;:d&#125;str8 = &apos;&#123;:b&#125;元买了一件风衣&apos; # 转化成了二进制str8 = &apos;&#123;:o&#125;元买了一件风衣&apos; # 转化成了八进制str8 = &apos;&#123;:x&#125;元买了一件风衣&apos; # 转化成了十六进制result8 = str8.format(15)pirnt(result8)# 金融字符，逗号分隔str9 = &apos;今天上班，得了&#123;:,&#125;元&apos; # 今天上班，得了2,600,000元result9 = str.format(2600000)print(result9) 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习五]]></title>
    <url>%2F2018%2F01%2F16%2Fpython%E5%AD%A6%E4%B9%A0%E4%BA%94%2F</url>
    <content type="text"><![CDATA[函数文档 定义函数的文档 变量的作用域 内部函数 函数文档函数文档就是用来查看当前函数相关信息介绍的一个特定格式而已 查看函数文档的方法 help(函数名称) 直接输出显示函数文档的内容字符串 函数名称.__doc__ 直接输出显示函数文档的内容元字符串(转义字符不转义) 定义函数的文档def 函数名称(参数...) &apos;&apos;&apos; 在此处声明函数文档 &apos;&apos;&apos; 函数功能代码... 函数功能代码... ... 注意：函数文档的作用是函数进行说明，便于阅读和快速掌握函数的使用，通常函数文档需要具有以下信息： 函数的作用 函数的参数介绍(个数，数据类型) 函数的返回值(数据和类型) 变量的作用域变量的作用域就是指变量的有有效范围 变量按照作用范围分为2类： 全局变量： 在函数外部声明的变量就是全局（在函数内部需要global关键字才可以使用） 局部变量： 在函数内部声明的变量就是局部变量 全局变量和局部变量的有效范围： 1.全局变量在函数外部也可以正常使用 2.全局变量在函数内部也可以正常使用(需要global声明) 3.局部变量在函数内部可以正常使用 4.局部变量在函数外部不可以被访问 global关键字 将局部变量提升为全局变量 格式： def 函数名(): # 提升局部变量为全局变量 global 变量名 函数的其他功能代码... ... 注意：只有在函数内部使用global关键字对变量进行全局声明，该变量才是一个完整的全局变量，在函数内外可以进行任意获取修改删除等操作。 内部函数在函数内部声明的函数就是内部函数 特征： 1.内部函数的本质就是局部变量(函数就是一个变量) 2.内部函数在函数外部不可以直接调用 3.内部函数在函数内部调用必须定义在内部函数之后可以调用 闭包(函数式开发使用)想办法将局部变量引入到全局环境中可以使用，这就是闭包操作 闭包方法1： def 函数名(): 局部变量1 局部变量2 ... def 内部函数1() pass def 内部函数2() pass ... return (局部变量1，局部变量2...内部函数2...) 闭包方法2： def 函数名(): 局部变量1 局部变量2 ... def 内部函数1() pass def 内部函数2() pass ... # 获取/收集所有需要进行闭包操作的内部函数和变量 def all(): return (局部变量1，局部变量2...内部函数2...) return all 闭包的优缺点： 优点： 1.可以方便的进行函数式编程，组织程序代码 2.使用局部变量和内部函数在外部可以访问 缺点： 1.闭包操作会导致整个函数的内部环境，被长久保存，占用大量内存 闭包环境查看： \_\_closure\_\_ 用于查询当前闭包操作所使用的环境中的变量和内部函数等信息 123456789101112131415161718192021222324252627282930313233343536# 实现闭包操作1# 全局环境# 函数局部环境def py(): # 局部变量 boy = &apos;aqqje&apos; girl = &apos;yjgmy&apos; # 内部函数 def boyName(): print(boy+&apos;123456&apos;) def girlName(): print(girl+&apos;987654&apos;) # 通过return语句和容器数据将局部变量和内部函数返回 return (boy,girl,boyName,girlName)# 调用函数获取所有的返回值result = py()print(result)# 高级写法men,wemen,name1,name2 = result# 初级写法#men = result[0]#wemen = result[1]#name1 = result[2]#name2 = result[3]name2() 结果如下： 12(&apos;aqqje&apos;, &apos;yjgmy&apos;, &lt;function py.&lt;locals&gt;.boyName at 0x01DFD780&gt;, &lt;function py.&lt;locals&gt;.girlName at 0x01E5DA98&gt;)yjgmy987654 1234567891011121314151617181920212223# 实现闭包操作2# 全局环境# 函数局部环境def py(): # 局部变量 boy = &apos;aqqje&apos; girl = &apos;yjgmy&apos; # 内部函数 def boyName(): print(boy+&apos;123456&apos;) def girlName(): print(girl+&apos;987654&apos;) def getall(): return [boy,girl,boyName,girlName] return getallresult = py()print(result)allvar = result()print(allvar) 123456789101112131415161718192021222324252627# 实现闭包操作3# 全局环境allinner = None# 函数局部环境def py(): # 局部变量 global allinner boy = &apos;aqqje&apos; girl = &apos;yjgmy&apos; # 内部函数 def boyName(): print(boy+&apos;123456&apos;) def girlName(): print(girl+&apos;987654&apos;) def getall(): return [boy,girl,boyName,girlName] allinner = getall()py()n,a,b,c = allinnerprint(n)print(a)b()c() 1234567891011121314# 闭包环境查看：def demo(): x = 6 y = 3 def inner1(): pass def inner2(): pass def all(): return [y,inner1,inner2] return allbb = demo()print(bb.\_\_closure\_\_) 结果如下：1(&lt;cell at 0x01E53690: function object at 0x01346A08&gt;, &lt;cell at 0x01E53670: function object at 0x01DFD780&gt;, &lt;cell at 0x01E536D0: int object at 0x5B382AA0&gt;) 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习四]]></title>
    <url>%2F2018%2F01%2F16%2Fpython%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[函数 函数的作用 函数的定义 收集参数 多种参数混合 关于返回值问题 函数函数的英文单词： function 在计算机中称之为函数 在现实生活中称之为功能 函数是能够实现特定功能的计算机代码而已，他是一种特定的代码组结构 函数的作用1.提升代码的重复利用率，避免重复开发相同代码 2.提高程序开发效率 3.便于程序维护 函数的定义：1.基本格式： def 函数名(): 函数功能代码... 函数功能代码... ... 调用函数：函数名(): 特征：函数定义之后不会自动执行，必须在调用函数后函数才会执行 函数名的命名规则：和变量基本一样 1.推荐使用英文或者拼音，禁止使用中文 2.可以使用数字，但是不能用数字开头 3.不可以使用特殊字符，除了_ 4.函数名严格区分大小写 5.函数名必须要有意义 6.不能和系统已经存在的保留关键字冲突 7.禁止使用和系统提供函数相同的函数名 带有参数的格式： def 函数名(形参，形参...): 函数功能代码... 函数功能代码... ... 调用函数：函数名(实参，实参...): 形参：形式上的参数，声明函数时()中的参数是形参 实参：实际上的参数，调用函数时()中的参数是实参 注意:实参将值传递给形参的过程本质上就是简单的变量赋值仅此而已 1234567891011121314def myStar(maxRow,maxLine): hang = 0; while hang &lt; maxRow : lie = 0 while lie &lt; maxLine : if lie % 2 == 0 : print('★',end = '') else : print('☆',end = '') lie += 1 print('\n',end = '') hang += 1myStar(4,10) 带有默认值的参数: def 函数名(形参 = 默认值，形参 = 默认值...): 函数功能代码... 函数功能代码... ... 调用函数： 函数名() 使用函数时所有形参采用默认值操作 函数名(实参，实参...) 使用时形象的值面抛弃默认值 注意： 在此情况下使用实参值覆盖原有形参的默认值，本质上就是变量的重新赋值操作 关键字参数： def 函数名(形参 = 默认值，形参 = 默认值...): 函数功能代码... 函数功能代码... ... 调用函数：函数名(形参 = 实参，形参 = 实参...) 关键字参数就是调用函数时，在实参前面指定形参的做法，为了防止参数按照位置传递出现的错误 收集参数1.非关键字收集参数 def 函数名(*参数名)： 函数功能代码... 函数功能代码... ... 调用函数：函数名(实参，实参...) 没有数量限制 特征： 1.非关键字收集参数，在形参前添加一个*即可 2.非关键字收集参数收集实参组成一个元组 3.非关键字收集，仅收集没任何形参接受的非关键字实参 4.非关键字收集参数和普通的形参可以共存 12345678910111213141516171819202122232425262728293031323334353637## 制作一个可以计算任意数的和的函数def sum(*args): num = 0 total = 0 while num &lt; len(args): total = total + args[num] num += 1 print(total)sum(1,2,3,4,5,6)# 定义一个元组tuple1 = (2,3,4,6,22,33,4,55,)# 遍历元组for tupleCollec in tuple1: print(tupleCollec)print('\n',end = '')i = 0while i &lt; len(tuple1): print(tuple1[i]) i += 1# 检测收集参数收集的规则def myargs(no1,no2,*args): print(no1) print(no2) print(args)myargs(2,323,32,1,4,5,2,) 2.关键字收集参数 def 函数名(**参数名)： 函数功能代码... 函数功能代码... ... 调用函数： 函数名(形参 = 实参，形参 = 实参...) 没有数量限制 特征： 1.关键字收集参数，在形参前添加两个**即可 2.关键字收集参数，收集的结果组成一个字典，关键字成为的键，实参成为值 3.关键字收集参数，仅收集没有任何形参接受的关键字参数 4.关键字参数可以和普通的形参共存 12345678910# 收集关键字参数def myArgs(**args): # 打印所有 print(args) # 打印指定的 print(args['qq']) passmyArgs(ch = 'wifi',g5 = '5g',qq = '104232323' ) 结果如下：12&#123;&apos;ch&apos;: &apos;wifi&apos;, &apos;g5&apos;: &apos;5g&apos;, &apos;qq&apos;: &apos;104232323&apos;&#125;104232323 多种参数混合定义函数时尽量避免多种参数格式混合(普通参数/非关键字参数，关键字参数，非关键字收集参数，关键字收集参数) 1.普通参数(非关键字参数)和关键字参数必须在两种收集参数之前 2.非关键字收集参数，必须在关键字收集参数之前 3.如果多种参数在一起，必须注意进制参数多次赋值操作(相同赋值之后，关键字参数在此赋值！) 12345678910111213141516# 非关键字参数，关键字参数，非关键字收集参数，关键字收集参数共存'''num 非关键字参数name 关键字参数*fargs 非关键字收集参数**args 关键字收集参数'''def argsAll(num,name,*fargs,**args): print(num) print(name) print(fargs) print(args)argsAll(100,99,88,name = 'aaje',sex = '0') 结果如下： 123410099(88,)&#123;'naem': 'aaje', 'sex': '0'&#125; 关于返回值问题函数根据执行完毕是否可以得到一个结果，将函数分为2个类型： 执行过程函数：print() 函数执行完毕之后，不会有任何结果可以被接受的函数。 123456def learn1(): print('努力学习一个月')learn1()print(learn1()) 结果如下： 123努力学习一个月努力学习一个月None 具有返回值的函数：id(),type() 函数执行完毕之后，会产生一个结果，可以被变量接收或者使用的函数 格式： def 函数名(参数...) 函数功能代码... 函数功能代码... ... [return 语句] return 的特征： 1.具有return 语句的函数称为具有返回值的函数 2.return 可以为当前函数执行完毕返回一个结果，这样的函数调用可以被接受 3.return 执行之后，函数则会终止，所有return之后的语句不会执行 4.一个函数可以眉宇 多个return语句，但是一般放入分支结构当中。 5.一个函数如果需要返回多个数据，需要借助复合数据数据类型(list,tupe,set,dict)来操作即可！ 123456def learn2(): print('努力学习一年') return '程序员一个'learn2()print(learn2()) 结果如下: 123努力学习一年努力学习一年程序员一个 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习三]]></title>
    <url>%2F2018%2F01%2F14%2Fpython%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[流程控制 流程分类 顺序结构 break continue pa 流程控制流程: 计算机执行代码的顺序就是流程。 流程控制： 对计算机代码执行顺序的管理就是流程控制。 流程分类 流程控制一共分为三类： 1.顺序结构 2.分支结构/选择结构 3.循环结构 顺序结构: 顺序结构就是代码一种自上而下执行的结构，这是python默认的流程 分支/选择结构: 分支结构一共分为4类： 1.单项分支 2.双项分支 3.多项分支 4.巢状分支 单项分支： 格式： if 条件表达式： 一条python语句... 一条python语句... 一条python语句... ... 特征： 1.if条件表达式结果为真，则执行if之后所有的控制代码组，如果为假，则不执行后面的代码组(:后面的N行中有相同缩进的代码) 2.:之后下一行的内容必须缩进，否则语法错误。 3.if之后的代码 中如果缩进不一致，则不受if条件表达式的控制，也不是单项分支的内容，是顺序结构的一部分。 4.if:后面的代码是在条件表达式结果为真的情况下执行，所以称之为真区间或者if区间 双项分支: 格式: if 条件表达式： 一条python语句... 一条python语句... 一条python语句... ... else: 一条python语句... 一条python语句... 一条python语句... ... 特征： 1.双项分支有2个区间：分别是 True 控制的if区间和 False 控制的else区间（假区间） 2.if区间的内容在双项分支中必须缩进，否则语法错误。 多项分支： 格式： if 条件表达式： 一条python语句... 一条python语句... 一条python语句... ... elif 条件表达式： 一条python语句... 一条python语句... 一条python语句... ... else: 一条python语句... 一条python语句... 一条python语句... ... 特征： 1.多项分支可以添加无限个elif分支，无论如何只会执行一个分支。 2.执行完一个分支后，分支结构就会结束，后面的分支都不会判断也不会执行。 3.多项分支的判断顺序是自上而下逐个进行判断。 巢状分支： 巢状分支是其他分支结构的嵌套结构，无论哪个分支都可以嵌套 循环结构: 循环结构分为2类： 1.while 循环 1.for .. in 循环 while 循环： 格式1： while 条件表达式： 循环的内容 [变量的变化] 格式2： while 条件表达式： 循环的内容 [变量的变化] else: python语句.. 注意：while 循环中的else是在while条件表达式为假的情况下执行的代码内容。 123456789num = 0while num &lt; 100 : if num % 2 == 0 : print(&apos;★&apos;,end = &apos;&apos;) else : print(&apos;☆&apos;,end = &apos;&apos;) if num % 10 == 9 : print(&apos;\n&apos;,end = &apos;&apos;) num += 1; 结果如下： 12345678910★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆ for ... in 循环 用于遍历容器类的数据（字符串，列表，元组，字典，集合） 格式1: for 变量 in 容器: python代码,可以在此使用变量 格式2: for 变量1,变量2 in 容器: python代码,可以在此使用变量1和变量2 要求遍历的容器必须是以下几种格式: [(),(),()] 列表中有元组 [[],[],[]] 列表中有列表 ((),(),()) 元组中有元组 {(),(),()} 集合中有元组 格式3: for 变量 in 容器: python代码,可以在此使用变量 else: 循环结束是执行的代码! 遍历字典的特殊方式 12345678dict1 = &#123;&apos;aqqj&apos;:&apos;sdsd&apos;,&apos;dfef&apos;:&apos;dfsd&apos;&#125;for i,j in dict1.items() : print(i) print(j)``` 结果如下: aqqjsdsddfefdfsd12----------------- str1 = ‘liu’ for onechar in str1 : print(onechar) 12结果如下： liu1234567891011121314151617181920-----------## break break 破坏,结束,打破作用:在循环中break的作用是终止当前循环结构的后续操作,一旦程序运行了break,循环也就终止了.## continuecontinue 继续作用:在循环中continue的作用是跳过本次循环,开始下一次循环操作,continue执行之后当前循环的后续代码就不会在执行,直接进入下一次循环(主要用于数据过渡)## pass 空语句作用:pass是没有任何意义的空语句,但是在书写语言结构时如果不需要任何操作,那么为了避免语法错误,可以使用pass占位语句,占位 aqqje = ‘li’if aqqje == ‘li’ : passelse: print(aqqje)` 无结果: 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE学习二]]></title>
    <url>%2F2018%2F01%2F14%2FjavaSE%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE学习一]]></title>
    <url>%2F2018%2F01%2F14%2FjavaSE%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[基础常识(了解) Java语言概述(了解) Java程序运行机制及运行过程(掌握) 注 释(掌握) Java API文档(掌握) 基础常识 (了解) 常用的DOS命令 dir : 列出当前目录下的文件以及文件夹 md : 创建目录 rd : 删除目录 cd : 进入指定目录 cd.. : 退回到上一级目录 cd\: 退回到根目录 del : 删除文件 exit : 退出 dos 命令行 Java语言概述(了解) 是SUN(Stanford University Network，斯坦福大学网络公司)1995年推出的一门高级编程语言。95年，SUN发布JDK 1.0，98年，JDK1.2，后续JDK1.3， 1.4，1.5（更名为Java5.0）最新为JDK1.8。 是一种面向Internet的编程语言。 随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 Java技术体系平台 Java SE(Java Standard Edition)标准版 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE Java EE(Java Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE Java ME(Java Micro Edition)小型版 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME Java Card 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台 Java语言运行机制及运行过程(掌握) Java语言的特点 特点一：面向对象 1.两个基本概念：类、对象 2.三大特性：封装、继承、多态 特点二：健壮性 1.吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制 特点三：跨平台性 1.跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” 2.原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。 Java两种核心机制 Java虚拟机（Java Virtal Machine） 1.JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。 2.对于不同的平台，有不同的虚拟机。 3.Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。 垃圾收集机制（Garbage Collection） 1.不再使用的内存空间应回收—— 垃圾回收。 2.在C/C++等语言中，由程序员负责回收无用内存。 3.Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。 4.垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。 注释 用于注解说明解释程序的文字就是注释。 提高了代码的阅读性；调试程序的重要方法。 Java中的注释类型： 1.单行注释 // -- &lt;!-- --&gt; 2.多行注释 3.文档注释（java特有） 注释是一个程序员必须要具有的良好编程习惯。 将自己的思想通过注释先整理出来，再用代码去体现 单行注释 格式： //注释文字 多行注释 格式： /* 注释文字 */ 注意： 1.对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。 2.多行注释里面不允许有多行注释嵌套。 文档注释（java特有） 格式： /** * @author 指定java程序的作者 *@version 指定源文件的版本 *@param 方法的参数说明信息 */ 注意： 1.注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 操作方式：(DOS) javadoc -d mydoc -author -version HelloWorld.java Java API文档(掌握) API （Application Programming Interface,应用程序编程接口）是 Java 提供的基本编程接口。 Java语言提供了大量的基础类，因此 Oracle 也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。 javadoc 和 javadoc注释规范 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习二]]></title>
    <url>%2F2018%2F01%2F13%2Fpython%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[运算 运算符 运算的分类 关系运算/比较运算 赋值运算 逻辑运算 位运算 身份运算 运算优先级的问题 检测数据归属类型 运算由一个以上的值经过变化等到新值的过短就是运算。 运算符用于运算的符号就是运算符。 运算的分类1.算数运算 2.比较运算/关系运算 3.赋值运算 4.逻辑运算 5.位运算 6.成员运算 7.身份运算 算数运算+ 加法运算 - 减法运算 * 乘法运算 / 除法运算 % 取余运算 // 取商运算/地板除 ** 幂运算 注意：python中没有自增的 ++ ，也没自减的 – 运算 关系运算/比较运算&gt; 大于运算 &lt; 小于运算 == 等于运算 &gt;= 大于等于运算 &lt;= 小于等于运算 != 不于运算 注意：python中没有类型判断，所以没有 === 和 ！== 运算 赋值运算= 普通赋值运算 += 加法赋值运算 -= 减法赋值运算 *= 乘法赋值运算 /= 除法赋值运算 %= 取余赋值运算 //= 取商赋值运算 **= 幂赋值运算 注意：所有的运算操作的格式都可以转化为 【变量 = 变量 运算符 值】，等号两侧一定都变量 var /= 5 -&gt; var = var / 5 逻辑运算逻辑运算就是布尔值之间的运算，python只有三种运算方式 and 逻辑与运算 -&gt; 有假则假 or 逻辑或运算 -&gt; 有真则真 not 逻辑非运算 -&gt; 真变假，假变真 注意：逻辑运算一共四种，python只提供了三种：没有提供逻辑异或【相同为假，不同为真】运算 位运算在二进制基础上进行的逻辑运算就是位运算 &amp; 按与运算 | 按或运算 ~ 按非运算 ^ 按位异或运算 &gt;&gt; 右移运算 相当于*2运算 &lt;&lt; 左移运算 相当于//2运算 成员运算检测一个数据是否在指定的容器(复合数据)当中 检测一个数据a是否在别名一个数据b当中 格式： 数据a in 数据b 检测一个数据a是否不在别名一个数据b当中 格式： 数据a not in 数据b 身份运算检测2个变量在内存中是否同一个值 检测2个变量是不是同一个值 格式： 数据a is 数据b 检测2个变量是不是不是同一个值 格式： 数据a is not 数据b 运算优先级的问题** 指数（最高优先级） ~ + - 按位翻转，一元加号和减号（+@ 和 -@） * / % // 乘，除，取模，取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移 运算符 &amp; 位 &apos;AND&apos; ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is (is not) 身份运算符 in (not in) 成员运算符 not or and 逻辑运算符 注意：实际中，使用()来解决 检测数据归属类型type() 测试可以使用，开发尽量避免。 ininstance() 检测一个数据是否由指定类型创建。 格式： isinstance(变量，检测的类型) 检测的类型名称就是类型转换的那些功能的名称，不需要() 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习一]]></title>
    <url>%2F2018%2F01%2F12%2Fpython%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[python的安装 python的检测 python的语言特色 如何创建python文件 注释 python的语句分类 变量 python赋值原理 python变量的三个常用操作 python数据类型 转义字符 元字符串 数据类型转换 python的安装 目前python有2个大的版本 2X版本 和 3X版本 windows安装python 根据操作系统的位数选择对应的版本的安装程序即可。 注意: 安装界面中 Add python... TO PATH 的选项一定要打勾。 python的检测1.”开始菜单” -&gt; “运行” -&gt; “cmd” -&gt; “python” 出现以提示表示成功: 1234Python 3.7.0a4 (v3.7.0a4:07c9d85, Jan 9 2018, 06:16:56) [MSC v.1900 32 bit (Intel)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 2.DOS界面中 -&gt; “python -v” (直接查看版本) 出现以提示表示成功: 12Python 3.7.0a4 3.”开始菜单” -&gt; “所有程序” -&gt; “Python …” 出现正常的文件夹表示成功 python的语言特色1.python是一门解释性的语言 解释性语言： 在系统运行时需解释器将代码翻译成计算机可识别的语言，这种类型就解释性语言。 java,python,php ... 编译性语言： 在系统运行程序之前，已经由开发者将源代码翻译成计算机可识别的代码，计算机直接运行即可，不需要任何解释器，这就是编译性语言。 c,object-c 开发效率 解释性语言 &lt; 编译性语言 2.强类型语言 ? 弱类型语言 强类型语言特色： 1.存储数据时需要预先声明的数据类型。 2.在进行不同的数据类型运算时不可以运算。 （python） 弱类型语言特色： 1.存储数据是不需要预先声明数据类型。 （python） 2.在进行不同的数据类型运算时可以自动转换类型并运算。 3.python是一门面向对象的语言 python支持全面的面向对象开发模式，当然python也支持过程开发和函数式开发。 4.python是一门胶水语言 python可以把其他语言开发的模块嵌入python当中进行使用。 python语言本身大部分都是由C语言构建而来的。 如何创建python文件文件名称部分 1.可以使用英文，不要使用中文。 2.可以使用数字，但是尽量不要使用数字。 3.可以使用_或者.等部分字符分隔文件名。 4.文件命名要有意义方便维护。 文件后辍部分 常用文件后辍：.py .pyc 123#第一句python代码 -- 注释print(&apos;你好！python!&apos;) 注释注释就是注解，解释，主要用坏在代码中进行代码相关的文字提示或者程序调试功能 注释一共分2种 单行注释： #注释内容 多行注释： ··· 多行内容 多行内容 多行内容 ... ··· 或者: &quot;&quot;&quot; 多行内容 多行内容 多行内容 ... &quot;&quot;&quot; python的语句分类python语句分为2类： 单行语句： 一行python代码 多行语句： 代码组都是特定的语言结构 12345678# 代码组if 1 : print(&apos;liuliaqqje&apos;) print(&apos;liuliaqqje&apos;) print(&apos;liuliaqqje&apos;) print(&apos;liuliaqqje&apos;) 变量变量就是可以改变的量 变量赋值： 格式： 变量名 = 值 变量的命名规范： 1.汉字变量名能用，不推荐使用。 2.可以使用数字但是不能用数字开头。 3.不可以使用特殊字符，除了_。 4.变量严格区分大小写。 5.变量命名要有意义（规范）。 6.变量命名要避免和系统使用的保留关键字冲突。 关键字： False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;async&apos;, &apos;await&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos; 查询系统保留关键字： import keyword print(keyword.kwlist) 其他的变量赋值格式 变量名 = 值 变量1 = 变量2 = 变量3 = 值 变量1，变量2，变量3 = 值1，值2，值3 python赋值原理 12345678910# 变量1 = 变量2 = 变量3 = 值name1 = name2 = name3 = &apos;aqqje&apos;print(name1);print(id(name1));print(name2);print(id(name2));print(name3);print(id(name3)); 输出结果： 123456aqqje33830688aqqje33830688aqqje33830688 12345678910# 变量1，变量2，变量3 = 值1，值2，值3name1,name2,name3 = &apos;aqqje1&apos;,&apos;aqqje2&apos;,&apos;aqqje3&apos;;print(name1);print(id(name1));print(name2);print(id(name2));print(name3);print(id(name3)); 输出结果：12345aqqje13180313631803072aqqje331803168 Python无变量，万物皆对象！ python变量的三个常用操作输出值： print(变量名); 输出ID： print(id(变量名)); 输出类型： print(type(变量名)); python数据类型python中可以自定义类型类型，可以具有无限个类型。 python提供默认6个标准数据类型： 1.Number 数值型 2.String 字符型 3.List 列表型 4.Tuple 元组型 5.Dict 字典型 6.Set 集合型 Number类型 Number型一共分为四个小类型:整型，浮点型，布尔型，复数 整型： 整型就是数字中的整数，包含正整，0和负整数。 声明整型有四种方式： 十进制： 0 ~ 9 变量 = 十进制数字 二进制： 0 ~ 1 变量 = 0b二进制数字 0b二进制标志符 八进制： 0 ~ 7 变量 = 0o八进制数字 0o八进制标志符 十六进制： 0 ~ 9 A ~ F 变量 = 0x十六进制数字 0x十六进制标志符 浮点型： 浮点型就是小数类型 声明浮点型的两种方式： 小数方式： 变量 = 3.1452114; 科学计数法： 变量 = 314e2 314*10的平方 布尔型： 计算专用的数据类型，只有两个值： true 和 false true 表示肯定的答案 false 表示否定的答案 复数： 复数的完整结构 （实数部分 + 虚数部分） 实数：现实存在的所有数值就是实数，真实存在的数字 虚数：不是真实存在的数字(), 声明复数的两种方式： 表达式方式： 变量 = 实数 + 虚数 comVal1 = 3 + 2j; 特定功能 变量 = complex(实数，虚数值) comVal2 = complex(5,3); String类型 字符串类型就是文字类型 声明一个字符串类型有三种方式： 单引号： 变量 = &apos;内容&apos; 内容中包含大量的双引号时适合使用单引号声明字符串 双引号： 变量 = &quot;内容&quot; 内容中包含大量的单引号时适合使用双引号声明字符串 三引号： 变量 = &apos;&apos;&apos;内容&apos;&apos;&apos; 或者 变量 = &quot;&quot;&quot;内容&quot;&quot;&quot; 适合多内容，单双引号都存在的情况下声明字符串 在双引号中使用双引号，在单引号中使用单引号（转义） List 列表类型 一组数据的有序组合就是 List 类型。 格式： 变量 = [值1，值2，值3...]; 注意：列表的标志符号是 [] Tuple 元组类型 一组数据的有序集合就是元组，元组是一种特殊的列表，不可以修改。 格式： 变量 = (值1，值2，值3...); 注意元组的标志符号是 ， Dict 字典类型 由一组具有键值对格式的数据 组成的无序的数据就是字典。 格式： 变量 = {键:值，键:值，键:值，键:值...} 注意：字典的标志就是 {} Set 集合类型 一组特定(去重)数据 的无序组合就是集合（） 格式： 变量 = {值，值，值...} 注意：集合没有标志符号 集合中的数据一定是唯一的，不会重复。 转义字符转义字符就是通过指定的格式，改变字符的意义。 转义字符 描述 * (在行尾时) 续行符 * \ 反斜杠符号 *** \’ 单引号 ** \” 双引号 ** \a 响铃 \b 退格(Backspace) \e 转义 \000 空 \n 换行 ** \v 纵向制表符 \t 横向制表符 ** \r 回车 ** \f 换页 \oyy 八进制数，yy代表的字符 例如：\o12代表换行 xyy 十六进制数，十六代表的字符 例如：\x0a代表换行 \other 其他的字符以普通格式输出 元字符串元字符就是字符串中的转义字符格式不进行任何转义操作的字符串，能够使得转义失效。 格式： 变量 = r&apos;字符串&apos; 或者 R&apos;字符串&apos; 数据类型转换将数据具当前类型变化为其他类型的操作就是数据类型转换 数据类型转换分类： 隐式转换（自动转换）：程序根据运算要求行的转换，不需要人工干预。 1.自动类型转换不需要人工干预 2.自动类型转换多发在运算或者判断过程中 3.转化时向着更加精确的类型转换 显示转换（强制转换）：根据程序需要，由编写程序人员人为改变数据类型的方式就是强制数据类型转换。 int() 将其他类型转化为整型 1.数字整型转化之后，还是原来的。 2.浮点型转化之后，舍去小数部分。 3.布尔值转化 True -&gt; 1 False -&gt; 0 4.字符串转换，仅纯整型字符串可以转换。 5.复数不可以转换。 float() 将其他类型转化为浮点型 1.整型转换之后变为浮点型，后面 +.0 2.浮点数不需要转化，转化也不会变化。 3.布尔值转化 True -&gt; 1.0 False -&gt; 0.0 4.字符串，纯整型和纯浮点型字符串可以转换。 complex() 将其他类型转化为复数 1.整型转换之后变为(整型 + 0j) 2.浮点型转换之后变为(浮点型 + 0j) 3.布尔值转化之后 True -&gt; (1 + 0j) False(0j) 4.字符串，纯整型和纯浮点型字符串可以转换。 5.复数，无需转换。 bool() 将其他类型转化为布尔值 1.整型 0 2.浮点型 0.0 3.复数 0 + 0j 4.布尔 True/False 5.字符串 &apos;&apos; 空字符串 6.列表 [] 空列表 7.元组 () 空元组 8.字典 {} 空字典 9.集合 set() 空集合 str() 将其他类型转化为字符串 1.所有转换均改变类型为字符串，表示方式依旧不变。 list() 将其他类型转化为列表类型 在python中5种可迭代序列，可以互相转换，他们分别是：字符串，列表，元组，字典，集合 注意： 1.字符串转换时每个字符变成列表中的一个值。 2.字典类型转换时，仅将字典的键部分转换成列表，忽略值的部分。 例如： 123var = (&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;);newvar = list(var);print(newvar); 结果如下: [‘张三’, ‘李四’, ‘王五’] tupe() 将其他类型转化为元组类型 注意： 1.字符串转换时每个字符变成列表中的一个值。 2.字典类型转换时，仅将字典的键部分转换成列表，忽略值的部分。 例如： 123var = (&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;);newvar = tuple(var);print(newvar); 结果如下: [‘张三’, ‘李四’, ‘王五’] set() 将其他类型转化为集合类型 注意： 1.字符串转换时每个字符变成列表中的一个值。 2.字典类型转换时，仅将字典的键部分转换成列表，忽略值的部分。 例如： 123var = (&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;);newvar = tuple(var);print(newvar); 结果如下: [‘张三’, ‘李四’, ‘王五’] 值的顺序不定 dict() 将其他类型转化为字典类型 其他类型转化为字典时需要按照指定的格式才可以转化：（列表和元组的组合可以） [[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;],[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;],[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]] [(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;),(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;),(&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;)] 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pull 冲突解决方法]]></title>
    <url>%2F2017%2F12%2F19%2Fgithub-pull-%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[多人协作git pull 问题解决 1.首先将本地修改存储 存储修改 1git stash 查看保存信息 1git stash list 其中stash@{0}是保存的标记 ## 2.pull远程仓库 1git pull 还原暂存内容1git stash pop stash@&#123;0&#125; 手动解决文件冲突部分其中Updated upstream 和=====之间的内容就是pull下来的内容，====和stashed changes之间的内容就是本地修改的内容 正常push到远程仓库1git push origin master 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>git pull问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeTalk-Forum总结]]></title>
    <url>%2F2017%2F12%2F19%2FFreeTalk-Forum%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[创建数据库 创建存储过程 sql server日期时间转字符串 新加一个列（表已存在） java调用存储过程 创建数据库123456789101112131415161718/*创建数据库*/create database FreeTalkDB on(name=FreeTalkDB_dat,filename=&apos;F:\FreeTalk\FreeTalkDB.mdf&apos;,size=5MB,maxsize=50MB,filegrowth=5%)log on(name=FreeTalkBD_log,filename=&apos;F:\FreeTalk\FreeTalkDB.ldf&apos;,size=3MB,maxsize=20MB,filegrowth=3MB) 创建存储过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*创建用户表*/create table Fuser (UId char(10) not null, --用户ID [1712180001] pkUserName varchar(25) not null, --用户名PassWord varchar(16) not null, --密码U_Sex int not null, --性别U_Head varchar(50) not null, --头像地址U_Grand int not null --权限等级);/*创建存储过程 * 实现ID字段的自动增长并实现insert功能 * */ --创建UID_increment create proc UID_increment @uName varchar(25), @passWord varchar(16), @uSex int, @uHead varchar(50), @uGrand int as begin declare @date char(6),@id char(4),@uID char(10) select @date=right(convert(varchar(8),getdate(),112),6); select @id=MAX(UID) from Fuser if @id IS null begin set @id =&apos;0001&apos;; end else begin select @id=(convert(int,RIGHT(UID,4))+1) from Fuser; if @id &lt;10 set @id = &apos;000&apos;+(convert(char,@id)); else if @id &lt; 100 and @id &gt;= 10 set @id = &apos;00&apos;+(convert(char,@id)); else if @id &lt; 1000 and @id &gt;= 100 set @id = &apos;0&apos;+(convert(char,@id)); end select @uID=@date+@id; insert into Fuser values (@UID,@uName,@passWord,@uSex,@uHead,@uGrand); end; /*调用存储过程*/exec UId_increment &apos;adf&apos;,&apos;123&apos;,1,&apos;sdfs&apos;,1; /*查询结果*/select * from Fuser; sql server日期时间转字符串sql server日期时间转字符串 新加一个列（表已存在）1234/*版块表(Section)增加一个列(S_notify)*/alter table Section add S_notify varchar(256); java调用存储过程123456789101112131415161718192021222324252627public boolean addUser(User user) &#123; Connection conn = DBConnection.getConnection(); try &#123; CallableStatement cs = conn.prepareCall(&quot;&#123;call UId_increment（?,?,?,?,?）&#125;&quot;); cs.setString(1, user.getUserName()); cs.setString(2, user.getPassWord()); cs.setInt(3, user.getSex()); cs.setString(4, user.getuHead()); cs.setInt(5,user.getGrand()); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return false; &#125; finally &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; // TODO Auto-generated method stub return true; &#125; 通过集合获取一个对象12345678910111213141516171819202122232425262728293031323334353637public List&lt;Section&gt; getSections() &#123; // TODO Auto-generated method stub Connection conn = DBConnection.getConnection(); PreparedStatement pstmt = null; ResultSet rs = null; List&lt;Section&gt; list = new ArrayList&lt;Section&gt;(); String sql = &quot;select * from Section order by ? asc&quot;; try &#123; Section s = new Section(); pstmt = conn.prepareStatement(sql); pstmt.setInt(1,s.getsId()); rs = pstmt.executeQuery(); while(rs.next()) &#123; s.setsId((rs.getInt(1))); s.setsName(rs.getString(2)); s.setsNotice(rs.getString(3)); User u1 = new User(); u1.setuId(rs.getString(4)); s.setModerator1(u1); User u2 = new User(); u2.setuId(rs.getString(5)); s.setModerator1(u2); User u3 = new User(); u3.setuId(rs.getString(6)); s.setModerator1(u3); s.setsClickCount(rs.getInt(7)); list.add(s); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return null; &#125; return list; &#125; java中的几个集合类的详解java中的几个集合类的详解 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Item</category>
      </categories>
      <tags>
        <tag>Item  summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十四]]></title>
    <url>%2F2017%2F12%2F13%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十四章，主要是用来复习和巩固在课堂学习的知识！ 笔记一、游标参数的传递 例： 12345678910111213SET SERVEROUTPUT ON DECLARE V_empno NUMBER(5); V_ename VARCHAR2(10); CURSOR emp_cursor(p_deptno NUMBER,p_job VARCHAR2) IS SELECT empno,ename FROM emp WHERE deptno = p_deptno AND job = p_job; BEGIN OPEN emp_cursor(10, 'CLERK'); LOOP FETCH emp_cursor INTO v_empno,v_ename; EXIT WHEN emp_cursor%NOTFOUND; DBMS_OUTPUT.PUT_LINE(v_empno||','||v_ename); END LOOP; END; 二、异常处理错误处理的语法如下： 123456 EXCEPTIONWHEN 错误1[OR 错误2] THEN 语句序列1;WHEN 错误3[OR 错误4] THEN 语句序列2;...WHEN OTHERS 语句序列n; END; 例： 12345678910SET SERVEROUTPUT ON DECLARE v_name VARCHAR2(10); BEGIN SELECT ename INTO v_name FROM emp WHERE empno = 1234; DBMS_OUTPUT.PUT_LINE('该雇员名字为：'|| v_name); EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('编号错误，没有找到相应雇员！'); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！'); END; 三、存储过程1.创建和删除存储过程格式： 12345678CREATE [OR REPLACE] PROCEDURE 存储过程名[(参数[IN|OUT|IN OUT] 数据类型...)] &#123;AS|IS&#125; [说明部分] --定义需要使用的临时变量 BEGIN 语句集; [EXCEPTION] [错误处理部分] END [过程名]; 删除： 1drop procedure 存储过程名; 调用存储过程1234567方法1： EXECUTE 模式名.存储过程名[(参数...)]; (适用于命今行窗口及sql窗口)方法2： (适用于sql窗口)BEGIN 模式名.存储过程名[(参数...)];END; 例：编写显示雇员信息的存储过程EMP_LIST，并引用EMP_COUNT存储过程(无参存储过程 )。 123456789CREATE OR REPLACE PROCEDURE EMP_LISTASCURSOR emp_cursor IS SELECT empno,ename FROM emp;BEGIN FOR Emp_record IN emp_cursor LOOP DBMS_OUTPUT.PUT_LINE(Emp_record.empno||Emp_record.ename); END LOOP; EMP_COUNT; END; 调用： 123begin EMP_LIST;end; 参数传递 a.输入参数: 参数名 IN 数据类型 DEFAULT 值； 例：编写给雇员增加工资的存储过程CHANGE_SALARY，通过IN类型的参数传递要增加工资的雇员编号和增加的工资额。 12345678910111213CREATE OR REPLACE PROCEDURE CHANGE_SALARY(P_EMPNO IN NUMBER DEFAULT 7788,P_RAISE NUMBER DEFAULT 10) --形参P_EMPNO及P_RAISEAS V_ENAME VARCHAR2(10); V_SAL NUMBER(5);BEGIN SELECT ENAME,SAL INTO V_ENAME,V_SAL FROM EMP WHERE EMPNO=P_EMPNO; UPDATE EMP SET SAL=SAL+P_RAISE WHERE EMPNO=P_EMPNO; DBMS_OUTPUT.PUT_LINE('雇员'||V_ENAME||'的工资被改为'||TO_CHAR(V_SAL+P_RAISE)); COMMIT;EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生错误，修改失败！'); ROLLBACK; --如果出了异常则撤消END; 调用： 123begin CHANGE_SALARY(7788,80)end; b.输出参数: 参数名 OUT 数据类型 DEFAULT 值； 例：统计雇员的人数 12345CREATE OR REPLACE PROCEDURE EMP_COUNT(P_TOTAL OUT NUMBER) --P_TOTAL为输出参数ASBEGINSELECT COUNT(*) INTO P_TOTAL FROM EMP; END; 调用： 1234567DECLARE V_EMPCOUNT NUMBER; --定义变量接收过程求出的结果 BEGIN EMP_COUNT(V_EMPCOUNT); DBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_EMPCOUNT); END;` c.输入输出参数： 参数名 IN OUT 数据类型 DEFAULT 值； 例：使用IN OUT类型的参数，给电话号码增加区码。 12345CREATE OR REPLACE PROCEDURE ADD_REGION(P_HPONE_NUM IN OUT VARCHAR2) AS BEGIN P_HPONE_NUM:='024-'||P_HPONE_NUM; END; 调用： 1234567DECLARE V_PHONE_NUM VARCHAR2(15); BEGIN V_PHONE_NUM:='26731092'; ADD_REGION(V_PHONE_NUM); DBMS_OUTPUT.PUT_LINE('新的电话号码：'||V_PHONE_NUM); END; 错误处理错误处理部分位于程序的可执行部分之后，是由WHEN语句引导的多个分支构成的。错误处理的语法如下： 1234EXCEPTIONWHEN 错误1[OR 错误2] THEN语句序列1；WHEN 错误3[OR 错误4] THEN 语句序列2； 123WHEN OTHERS语句序列n；END; 其中：错误是在标准包中由系统预定义的标准错误，或是由用户在程序的说明部分自定义的错误，参见下一节系统预定义的错误类型。语句序列就是不同分支的错误处理部分。 凡是出现在WHEN后面的错误都是可以捕捉到的错误，其他未被捕捉到的错误，将在WHEN OTHERS部分进行统一处理，OTHENS必须是EXCEPTION部分的最后一个错误处理分支。如要在该分支中进一步判断错误种类，可以通过使用预定义函数SQLCODE( )和SQLERRM( )来获得系统错误号和错误信息。 如果在程序的子块中发生了错误，但子块没有错误处理部分，则错误会传递到主程序中。 下面是由于查询编号错误而引起系统预定义异常的例子。 【训练1】 查询编号为1234的雇员名字。 123456789101112131415SET SERVEROUTPUT ONDECLAREv_name VARCHAR2(10);BEGIN SELECT ename INTO v_name FROM emp WHERE empno = 1234;DBMS_OUTPUT.PUT_LINE('该雇员名字为：'|| v_name);EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('编号错误，没有找到相应雇员！'); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！');END; 说明：在以上查询中，因为编号为1234的雇员不存在，所以将发生类型为“NO_DATA_ FOUND”的异常。“NO_DATA_FOUND”是系统预定义的错误类型，EXCEPTION部分下的WHEN语句将捕捉到该异常，并执行相应代码部分。在本例中，输出用户自定义的错误信息“编号错误，没有找到相应雇员!”。如果发生其他类型的错误，将执行OTHERS条件下的代码部分，显示“发生其他错误!”。 【训练2】 由程序代码显示系统错误。 1234567891011SET SERVEROUTPUT ONDECLAREv_temp NUMBER(5):=1;BEGINv_temp:=v_temp/0;EXCEPTION WHEN OTHERS THENDBMS_OUTPUT.PUT_LINE('发生系统错误！'); DBMS_OUTPUT.PUT_LINE('错误代码：'|| SQLCODE( )); DBMS_OUTPUT.PUT_LINE('错误信息：' ||SQLERRM( )); END; 说明：程序运行中发生除零错误，由WHEN OTHERS捕捉到，执行用户自己的输出语句显示错误信息，然后正常结束。在错误处理部分使用了预定义函数SQLCODE( )和SQLERRM( )来进一步获得错误的代码和种类信息。 预定义错误Oracle的系统错误很多，但只有一部分常见错误在标准包中予以定义。定义的错误可以在EXCEPTION部分通过标准的错误名来进行判断，并进行异常处理。 比如，如果程序向表的主键列插入重复值，则将发生DUP_VAL_ON_INDEX错误。 如果一个系统错误没有在标准包中定义，则需要在说明部分定义，语法如下： 1错误名 EXCEPTION; 定义后使用PRAGMA EXCEPTION_INIT来将一个定义的错误同一个特别的Oracle错误代码相关联，就可以同系统预定义的错误一样使用了。语法如下： 1PRAGMA EXCEPTION_INIT(错误名，- 错误代码)； 【训练1】 定义新的系统错误类型。 12345678910111213 SET SERVEROUTPUT ON DECLARE V_ENAME VARCHAR2(10); NULL_INSERT_ERROR EXCEPTION; PRAGMA EXCEPTION_INIT(NULL_INSERT_ERROR,-1400); BEGIN INSERT INTO EMP(EMPNO) VALUES(NULL);EXCEPTIONWHEN NULL_INSERT_ERROR THEN DBMS_OUTPUT.PUT_LINE('无法插入NULL值！'); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他系统错误！');END; 说明：NULL_INSERT_ERROR是自定义异常，同系统错误1400相关联。 自定义异常程序设计者可以利用引发异常的机制来进行程序设计，自己定义异常类型。可以在声明部分定义新的异常类型，定义的语法是： 1错误名 EXCEPTION; 用户定义的错误不能由系统来触发，必须由程序显式地触发，触发的语法是： 1RAISE 错误名； RAISE也可以用来引发模拟系统错误，比如，RAISE ZERO_DIVIDE将引发模拟的除零错误。 使用RAISE_APPLICATION_ERROR函数也可以引发异常。该函数要传递两个参数，第一个是用户自定义的错误编号，第二个参数是用户自定义的错误信息。使用该函数引发的异常的编号应该在20 000和20 999之间选择。 自定义异常处理错误的方式同前。 【训练1】 插入新雇员，限定插入雇员的编号在7000～8000之间。 123456789101112131415161718192021222324SET SERVEROUTPUT ONDECLAREnew_no NUMBER(10);new_excp1 EXCEPTION;new_excp2 EXCEPTION;BEGIN new_no:=6789;INSERT INTO emp(empno,ename) VALUES(new_no, '小郑'); IF new_no&lt;7000 THEN RAISE new_excp1; END IF; IF new_no&gt;8000 THEN RAISE new_excp2; END IF; COMMIT;EXCEPTIONWHEN new_excp1 THEN ROLLBACK; DBMS_OUTPUT.PUT_LINE('雇员编号小于7000的下限！'); WHEN new_excp2 THEN ROLLBACK; DBMS_OUTPUT.PUT_LINE('雇员编号超过8000的上限！'); END; 说明：在此例中，自定义了两个异常：new_excp1和new_excp2，分别代表编号小于7000和编号大于8000的错误。在程序中通过判断编号大小，产生对应的异常，并在异常处理部分回退插入操作，然后显示相应的错误信息。 【训练2】 使用RAISE_APPLICATION_ERROR函数引发系统异常。 12345678910111213141516SET SERVEROUTPUT ONDECLARENew_no NUMBER(10);BEGIN New_no:=6789; INSERT INTO emp(empno,ename) VALUES(new_no, 'JAMES');IF new_no&lt;7000 THEN ROLLBACK; RAISE_APPLICATION_ERROR(-20001, '编号小于7000的下限！'); END IF; IF new_no&gt;8000 THEN ROLLBACK; RAISE_APPLICATION_ERROR (-20002, '编号大于8000的下限！'); END IF;END; 说明：在本训练中，使用RAISE_APPLICATION_ERROR引发自定义异常，并以系统错误的方式进行显示。错误编号为20001和20002。 注意：同上一个训练比较，此种方法不需要事先定义异常，可直接引发。 可以参考下面的程序片断将出错信息记录到表中，其中，errors为记录错误信息的表，SQLCODE为发生异常的错误编号，SQLERRM为发生异常的错误信息。 12345678910111213DECLARE v_error_code NUMBER; v_error_message VARCHAR2(255);BEGIN...EXCEPTION...WHEN OTHERS THEN v_error_code := SQLCODE ; v_error_message := SQLERRM ; INSERT INTO errors VALUES(v_error_code, v_error_message);END; 阶段训练【训练1】 将雇员从一个表复制到另一个表。 步骤1：创建一个结构同EMP表一样的新表EMP1： 1CREATE TABLE emp1 AS SELECT * FROM SCOTT.EMP WHERE 1=2; 步骤2：通过指定雇员编号，将雇员由EMP表移动到EMP1表： 12345678910111213141516SET SERVEROUTPUT ON DECLAREv_empno NUMBER(5):=7788;emp_rec emp%ROWTYPE;BEGIN SELECT * INTO emp_rec FROM emp WHERE empno=v_empno; DELETE FROM emp WHERE empno=v_empno;INSERT INTO emp1 VALUES emp_rec; IF SQL%FOUND THEN COMMIT; DBMS_OUTPUT.PUT_LINE('雇员复制成功！'); ELSE ROLLBACK; DBMS_OUTPUT.PUT_LINE('雇员复制失败！'); END IF;END; 步骤2：显示复制结果： 1SELECT empno,ename,job FROM emp1; 说明：emp_rec变量是根据emp表定义的记录变量，SELECT…INTO…语句将整个记录传给该变量。INSERT语句将整个记录变量插入emp1表，如果插入成功(SQL%FOUND为真)，则提交事务，否则回滚撤销事务。试修改雇员编号为7902，重新执行以上程序。 【训练2】 输出雇员工资，雇员工资用不同高度的█表示。 输入并执行以下程序： 123456SET SERVEROUTPUT ON BEGIN FOR re IN (SELECT ename,sal FROM EMP) LOOP DBMS_OUTPUT.PUT_LINE(rpad(re.ename,12,' ')||rpad(' █ ',re.sal/100,' █ ')); END LOOP;END; 说明：第一个rpad函数产生对齐效果，第二个rpad函数根据工资额产生不同数目的*。该程序采用了隐式的简略游标循环形式。 【训练3】 编写程序，格式化输出部门信息。 输入并执行如下程序： 12345678910111213141516SET SERVEROUTPUT ON DECLARE v_count number:=0; CURSOR dept_cursor IS SELECT * FROM dept; BEGIN DBMS_OUTPUT.PUT_LINE('部门列表');DBMS_OUTPUT.PUT_LINE('---------------------------------'); FOR Dept_record IN dept_cursor LOOP DBMS_OUTPUT.PUT_LINE('部门编号：'|| Dept_record.deptno); DBMS_OUTPUT.PUT_LINE('部门名称：'|| Dept_record.dname); DBMS_OUTPUT.PUT_LINE('所在城市：'|| Dept_record.loc); DBMS_OUTPUT.PUT_LINE('---------------------------------'); v_count:= v_count+1; END LOOP; DBMS_OUTPUT.PUT_LINE('共有'||to_char(v_count)||'个部门！'); END; 说明：该程序中将字段内容垂直排列。V_count变量记录循环次数，即部门个数。 【训练4】 已知每个部门有一个经理，编写程序，统计输出部门名称、部门总人数、总工资和部门经理。 输入并执行如下程序： 1234567891011121314151617181920212223242526SET SERVEROUTPUT ON DECLARE v_deptno number(8); v_count number(3); v_sumsal number(6); v_dname varchar2(15);v_manager varchar2(15); CURSOR list_cursor IS SELECT deptno,count(*),sum(sal) FROM emp group by deptno;BEGIN OPEN list_cursor; DBMS_OUTPUT.PUT_LINE('----------- 部 门 统 计 表 -----------');DBMS_OUTPUT.PUT_LINE('部门名称 总人数 总工资 部门经理'); FETCH list_cursor INTO v_deptno,v_count,v_sumsal; WHILE list_cursor%found LOOP SELECT dname INTO v_dname FROM dept WHERE deptno=v_deptno; SELECT ename INTO v_manager FROM emp WHERE deptno=v_deptno and job='MANAGER';DBMS_OUTPUT.PUT_LINE(rpad(v_dname,13)||rpad(to_char(v_count),8) ||rpad(to_char(v_sumsal),9)||v_manager); FETCH list_cursor INTO v_deptno,v_count,v_sumsal; END LOOP; DBMS_OUTPUT.PUT_LINE('--------------------------------------'); CLOSE list_cursor; END; 说明：游标中使用到了起分组功能的SELECT语句，统计出各部门的总人数和总工资。再根据部门编号和职务找到部门的经理。该程序假定每个部门有一个经理。 【训练5】 为雇员增加工资，从工资低的雇员开始，为每个人增加原工资的10%，限定所增加的工资总额为800元，显示增加工资的人数和余额。 输入并调试以下程序： 12345678910111213141516171819202122232425262728293031323334SET SERVEROUTPUT ON DECLARE V_NAME CHAR(10); V_EMPNO NUMBER(5); V_SAL NUMBER(8); V_SAL1 NUMBER(8); V_TOTAL NUMBER(8) := 800; --增加工资的总额V_NUM NUMBER(5):=0; --增加工资的人数 CURSOR emp_cursor IS SELECT EMPNO,ENAME,SAL FROM EMP ORDER BY SAL ASC; BEGIN OPEN emp_cursor; DBMS_OUTPUT.PUT_LINE('姓名 原工资 新工资'); DBMS_OUTPUT.PUT_LINE('---------------------------'); LOOP FETCH emp_cursor INTO V_EMPNO,V_NAME,V_SAL;EXIT WHEN emp_cursor%NOTFOUND; V_SAL1:= V_SAL*0.1; IF V_TOTAL&gt;V_SAL1 THEN V_TOTAL := V_TOTAL - V_SAL1; V_NUM:=V_NUM+1; DBMS_OUTPUT.PUT_LINE(V_NAME||TO_CHAR(V_SAL,'99999')|| TO_CHAR(V_SAL+V_SAL1,'99999')); UPDATE EMP SET SAL=SAL+V_SAL1 WHERE EMPNO=V_EMPNO; ELSEDBMS_OUTPUT.PUT_LINE(V_NAME||TO_CHAR(V_SAL,'99999')||TO_CHAR(V_SAL,'99999')); END IF; END LOOP; DBMS_OUTPUT.PUT_LINE('---------------------------'); DBMS_OUTPUT.PUT_LINE('增加工资人数:'||V_NUM||' 剩余工资：'||V_TOTAL); CLOSE emp_cursor; COMMIT; END; 识存储过程和函数存储过程和函数也是一种PL/SQL块，是存入数据库的PL/SQL块。但存储过程和函数不同于已经介绍过的PL/SQL程序，我们通常把PL/SQL程序称为无名块，而存储过程和函数是以命名的方式存储于数据库中的。和PL/SQL程序相比，存储过程有很多优点，具体归纳如下： 存储过程和函数以命名的数据库对象形式存储于数据库当中。存储在数据库中的优点是很明显的，因为代码不保存在本地，用户可以在任何客户机上登录到数据库，并调用或修改代码。 存储过程和函数可由数据库提供安全保证，要想使用存储过程和函数，需要有存储过程和函数的所有者的授权，只有被授权的用户或创建者本身才能执行存储过程或调用函数。 存储过程和函数的信息是写入数据字典的，所以存储过程可以看作是一个公用模块，用户编写的PL/SQL程序或其他存储过程都可以调用它(但存储过程和函数不能调用PL/SQL程序)。一个重复使用的功能，可以设计成为存储过程，比如：显示一张工资统计表，可以设计成为存储过程；一个经常调用的计算，可以设计成为存储函数；根据雇员编号返回雇员的姓名，可以设计成存储函数。 像其他高级语言的过程和函数一样，可以传递参数给存储过程或函数，参数的传递也有多种方式。存储过程可以有返回值，也可以没有返回值，存储过程的返回值必须通过参数带回；函数有一定的数据类型，像其他的标准函数一样，我们可以通过对函数名的调用返回函数值。 存储过程和函数需要进行编译，以排除语法错误，只有编译通过才能调用。 创建和删除存储过程创建存储过程，需要有CREATE PROCEDURE或CREATE ANY PROCEDURE的系统权限。该权限可由系统管理员授予。创建一个存储过程的基本语句如下： 12345678CREATE [OR REPLACE] PROCEDURE 存储过程名[(参数[IN|OUT|IN OUT] 数据类型...)]&#123;AS|IS&#125;[说明部分]BEGIN可执行部分[EXCEPTION错误处理部分]END [过程名]; 其中： 可选关键字OR REPLACE 表示如果存储过程已经存在，则用新的存储过程覆盖，通常用于存储过程的重建。 参数部分用于定义多个参数(如果没有参数，就可以省略)。参数有三种形式：IN、OUT和IN OUT。如果没有指明参数的形式，则默认为IN。 关键字AS也可以写成IS，后跟过程的说明部分，可以在此定义过程的局部变量。 编写存储过程可以使用任何文本编辑器或直接在SQLPlus环境下进行，编写好的存储过程必须要在SQLPlus环境下进行编译，生成编译代码，原代码和编译代码在编译过程中都会被存入数据库。编译成功的存储过程就可以在Oracle环境下进行调用了。 一个存储过程在不需要时可以删除。删除存储过程的人是过程的创建者或者拥有DROP ANY PROCEDURE系统权限的人。删除存储过程的语法如下： 1DROP PROCEDURE 存储过程名； 如果要重新编译一个存储过程，则只能是过程的创建者或者拥有ALTER ANY PROCEDURE系统权限的人。语法如下： 1ALTER PROCEDURE 存储过程名 COMPILE； 执行(或调用)存储过程的人是过程的创建者或是拥有EXECUTE ANY PROCEDURE系统权限的人或是被拥有者授予EXECUTE权限的人。执行的方法如下： 123456方法1：EXECUTE 模式名.存储过程名[(参数...)];方法2：BEGIN模式名.存储过程名[(参数...)];END; 传递的参数必须与定义的参数类型、个数和顺序一致(如果参数定义了默认值，则调用时可以省略参数)。参数可以是变量、常量或表达式，用法参见下一节。 如果是调用本账户下的存储过程，则模式名可以省略。要调用其他账户编写的存储过程，则模式名必须要添加。 以下是一个生成和调用简单存储过程的训练。注意要事先授予创建存储过程的权限。 【训练1】 创建一个显示雇员总人数的存储过程。 步骤1：登录SCOTT账户(或学生个人账户)。 步骤2：在SQL*Plus输入区中，输入以下存储过程： 1234567CREATE OR REPLACE PROCEDURE EMP_COUNTASV_TOTAL NUMBER(10);BEGIN SELECT COUNT(*) INTO V_TOTAL FROM EMP; DBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_TOTAL);END; 步骤3：按“执行”按钮进行编译。 如果存在错误，就会显示: 警告: 创建的过程带有编译错误。 如果存在错误，对脚本进行修改，直到没有错误产生。 如果编译结果正确，将显示： 过程已创建。 步骤4：调用存储过程，在输入区中输入以下语句并执行： 1EXECUTE EMP_COUNT; 显示结果为： 雇员总人数为：14 PL/SQL 过程已成功完成。 说明：在该训练中，V_TOTAL变量是存储过程定义的局部变量，用于接收查询到的雇员总人数。 注意：在SQL*Plus中输入存储过程，按“执行”按钮是进行编译，不是执行存储过程。 如果在存储过程中引用了其他用户的对象，比如表，则必须有其他用户授予的对象访问权限。一个存储过程一旦编译成功，就可以由其他用户或程序来引用。但存储过程或函数的所有者必须授予其他用户执行该过程的权限。 存储过程没有参数，在调用时，直接写过程名即可。 【训练2】 在PL/SQL程序中调用存储过程。 步骤1：登录SCOTT账户。 步骤2：授权STUDENT账户使用该存储过程，即在SQL*Plus输入区中，输入以下的命令： 1GRANT EXECUTE ON EMP_COUNT TO STUDENT 授权成功。 步骤3：登录STUDENT账户，在SQL*Plus输入区中输入以下程序： 1234SET SERVEROUTPUT ONBEGINSCOTT.EMP_COUNT;END; 步骤4：执行以上程序，结果为： 雇员总人数为：14 PL/SQL 过程已成功完成。 说明：在本例中，存储过程是由SCOTT账户创建的，STUDEN账户获得SCOTT账户的授权后，才能调用该存储过程。 注意：在程序中调用存储过程，使用了第二种语法。 【训练3】 编写显示雇员信息的存储过程EMP_LIST，并引用EMP_COUNT存储过程。 步骤1：在SQL*Plus输入区中输入并编译以下存储过程： 12345678910CREATE OR REPLACE PROCEDURE EMP_LISTASCURSOR emp_cursor IS SELECT empno,ename FROM emp;BEGINFOR Emp_record IN emp_cursor LOOP DBMS_OUTPUT.PUT_LINE(Emp_record.empno||Emp_record.ename);END LOOP;EMP_COUNT;END; 执行结果： 过程已创建。 步骤2：调用存储过程，在输入区中输入以下语句并执行： 1EXECUTE EMP_LIST 显示结果为：7369SMITH7499ALLEN7521WARD7566JONES 执行结果： 雇员总人数为：14 PL/SQL 过程已成功完成。 说明：以上的EMP_LIST存储过程中定义并使用了游标，用来循环显示所有雇员的信息。然后调用已经成功编译的存储过程EMP_COUNT，用来附加显示雇员总人数。通过EXECUTE命令来执行EMP_LIST存储过程。 【练习1】编写显示部门信息的存储过程DEPT_LIST，要求统计出部门个数。 参数传递参数的作用是向存储过程传递数据，或从存储过程获得返回结果。正确的使用参数可以大大增加存储过程的灵活性和通用性。 参数的定义形式和作用如下： 1参数名 IN 数据类型 DEFAULT 值； 定义一个输入参数变量，用于传递参数给存储过程。在调用存储过程时，主程序的实际参数可以是常量、有值变量或表达式等。DEFAULT 关键字为可选项，用来设定参数的默认值。如果在调用存储过程时不指明参数，则参数变量取默认值。在存储过程中，输入变量接收主程序传递的值，但不能对其进行赋值。 1参数名 OUT 数据类型； 定义一个输出参数变量，用于从存储过程获取数据，即变量从存储过程中返回值给主程序。 在调用存储过程时，主程序的实际参数只能是一个变量，而不能是常量或表达式。在存储过程中，参数变量只能被赋值而不能将其用于赋值，在存储过程中必须给输出变量至少赋值一次。 1参数名 IN OUT 数据类型 DEFAULT 值； 定义一个输入、输出参数变量，兼有以上两者的功能。在调用存储过程时，主程序的实际参数只能是一个变量，而不能是常量或表达式。DEFAULT 关键字为可选项，用来设定参数的默认值。在存储过程中，变量接收主程序传递的值，同时可以参加赋值运算，也可以对其进行赋值。在存储过程中必须给变量至少赋值一次。 如果省略IN、OUT或IN OUT，则默认模式是IN。 【训练1】 编写给雇员增加工资的存储过程CHANGE_SALARY，通过IN类型的参数传递要增加工资的雇员编号和增加的工资额。 步骤1：登录SCOTT账户。 步骤2：在SQL*Plus输入区中输入以下存储过程并执行： 1234567891011121314CREATE OR REPLACE PROCEDURE CHANGE_SALARY(P_EMPNO IN NUMBER DEFAULT 7788,P_RAISE NUMBER DEFAULT 10) AS V_ENAME VARCHAR2(10); V_SAL NUMBER(5); BEGIN SELECT ENAME,SAL INTO V_ENAME,V_SAL FROM EMP WHERE EMPNO=P_EMPNO; UPDATE EMP SET SAL=SAL+P_RAISE WHERE EMPNO=P_EMPNO; DBMS_OUTPUT.PUT_LINE('雇员'||V_ENAME||'的工资被改为'||TO_CHAR(V_SAL+P_RAISE));COMMIT; EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生错误，修改失败！'); ROLLBACK; END; 执行结果为： 过程已创建。 步骤3：调用存储过程，在输入区中输入以下语句并执行： 1EXECUTE CHANGE_SALARY(7788,80) 显示结果为： 雇员SCOTT的工资被改为3080 说明：从执行结果可以看到，雇员SCOTT的工资已由原来的3000改为3080。 参数的值由调用者传递，传递的参数的个数、类型和顺序应该和定义的一致。如果顺序不一致，可以采用以下调用方法。如上例，执行语句可以改为： 1EXECUTE CHANGE_SALARY(P_RAISE=&gt;80,P_EMPNO=&gt;7788); 可以看出传递参数的顺序发生了变化，并且明确指出了参数名和要传递的值，=&gt;运算符左侧是参数名，右侧是参数表达式，这种赋值方法的意义较清楚。 【练习1】创建插入雇员的存储过程INSERT_EMP，并将雇员编号等作为参数。 在设计存储过程的时候，也可以为参数设定默认值，这样调用者就可以不传递或少传递参数了。 【训练2】 调用存储过程CHANGE_SALARY，不传递参数，使用默认参数值。 在SQL*Plus输入区中输入以下命令并执行： 1EXECUTE CHANGE_SALARY 显示结果为： 雇员SCOTT的工资被改为3090 说明：在存储过程的调用中没有传递参数，而是采用了默认值7788和10，即默认雇员号为7788，增加的工资为10。 【训练3】 使用OUT类型的参数返回存储过程的结果。 步骤1：登录SCOTT账户。 步骤2：在SQL*Plus输入区中输入并编译以下存储过程： 12345CREATE OR REPLACE PROCEDURE EMP_COUNT(P_TOTAL OUT NUMBER) AS BEGIN SELECT COUNT(*) INTO P_TOTAL FROM EMP; END; 执行结果为： 过程已创建。 步骤3：输入以下程序并执行： 123456DECLARE V_EMPCOUNT NUMBER; BEGIN EMP_COUNT(V_EMPCOUNT); DBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_EMPCOUNT); END; 显示结果为： 雇员总人数为：14 PL/SQL 过程已成功完成。 说明：在存储过程中定义了OUT类型的参数P_TOTAL，在主程序调用该存储过程时，传递了参数V_EMPCOUNT。在存储过程中的SELECT…INTO…语句中对P_TOTAL进行赋值，赋值结果由V_EMPCOUNT变量带回给主程序并显示。 以上程序要覆盖同名的EMP_COUNT存储过程，如果不使用OR REPLACE选项，就会出现以下错误： ERROR 位于第 1 行: ORA-00955: 名称已由现有对象使用。 【练习2】创建存储过程，使用OUT类型参数获得雇员经理名。 以上程序要覆盖同名的EMP_COUNT存储过程，如果不使用OR REPLACE选项，就会出现以下错误： ERROR 位于第 1 行: ORA-00955: 名称已由现有对象使用。 【练习2】创建存储过程，使用OUT类型参数获得雇员经理名。 【训练4】 使用IN OUT类型的参数，给电话号码增加区码。 步骤1：登录SCOTT账户。 步骤2：在SQL*Plus输入区中输入并编译以下存储过程： 12345CREATE OR REPLACE PROCEDURE ADD_REGION(P_HPONE_NUM IN OUT VARCHAR2) AS BEGIN P_HPONE_NUM:='024-'||P_HPONE_NUM;END; 执行结果为： 过程已创建。 步骤3：输入以下程序并执行： 12345678SET SERVEROUTPUT ONDECLAREV_PHONE_NUM VARCHAR2(15);BEGINV_PHONE_NUM:='26731092';ADD_REGION(V_PHONE_NUM);DBMS_OUTPUT.PUT_LINE('新的电话号码：'||V_PHONE_NUM);END; 显示结果为： 新的电话号码：024-26731092 PL/SQL 过程已成功完成。 说明：变量V_HPONE_NUM既用来向存储过程传递旧电话号码，也用来向主程序返回新号码。新的号码在原来基础上增加了区号024和-。 创建和删除存储函数创建函数，需要有CREATE PROCEDURE或CREATE ANY PROCEDURE的系统权限。该权限可由系统管理员授予。创建存储函数的语法和创建存储过程的类似. 在可执行部分的RETURN(表达式)，用来生成函数的返回值，其表达式的类型应该和定义部分说明的函数返回值的数据类型一致。在函数的执行部分可以有多个RETURN语句，但只有一个RETURN语句会被执行，一旦执行了RETURN语句，则函数结束并返回调用环境。 一个存储函数在不需要时可以删除，但删除的人应是函数的创建者或者是拥有DROP ANY PROCEDURE系统权限的人。其语法如下： 1DROP FUNCTION 函数名； 重新编译一个存储函数时，编译的人应是函数的创建者或者拥有ALTER ANY PROCEDURE系统权限的人。重新编译一个存储函数的语法如下： 1234567ALTER PROCEDURE 函数名 COMPILE；``` 函数的调用者应是函数的创建者或拥有EXECUTE ANY PROCEDURE系统权限的人，或是被函数的拥有者授予了函数执行权限的账户。函数的引用和存储过程不同，函数要出现在程序体中，可以参加表达式的运算或单独出现在表达式中，其形式如下： ```sql变量名:=函数名(...) 【训练1】 创建一个通过雇员编号返回雇员名称的函数GET_EMP_NAME。 步骤1：登录SCOTT账户。 步骤2：在SQL*Plus输入区中输入以下存储函数并编译： 123456789101112131415161718CREATE OR REPLACE FUNCTION GET_EMP_NAME(P_EMPNO NUMBER DEFAULT 7788) RETURN VARCHAR2 AS V_ENAME VARCHAR2(10); BEGIN SELECT ENAME INTO V_ENAME FROM EMP WHERE EMPNO=P_EMPNO;RETURN(V_ENAME);EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('没有该编号雇员！'); RETURN (NULL); WHEN TOO_MANY_ROWS THEN DBMS_OUTPUT.PUT_LINE('有重复雇员编号！'); RETURN (NULL); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！'); RETURN (NULL);END; 步骤3：调用该存储函数，输入并执行以下程序： 1234BEGIN DBMS_OUTPUT.PUT_LINE('雇员7369的名称是：'|| GET_EMP_NAME(7369)); DBMS_OUTPUT.PUT_LINE('雇员7839的名称是：'|| GET_EMP_NAME(7839));END; 存储过程和函数的查看可以通过对数据字典的访问来查询存储过程或函数的有关信息，如果要查询当前用户的存储过程或函数的源代码，可以通过对USER_SOURCE数据字典视图的查询得到。USER_SOURCE的结构如下： 1DESCRIBE USER_SOURCE 【训练1】 查询过程EMP_COUNT的脚本。 在SQL*Plus中输入并执行如下查询： 1select TEXT from user_source WHERE NAME='EMP_COUNT'; 【训练2】 查询过程GET_EMP_NAME的参数。 在SQL*Plus中输入并执行如下查询： 1DESCRIBE GET_EMP_NAME 【训练2】 查询过程GET_EMP_NAME的参数。 在SQL*Plus中输入并执行如下查询： 12345678910111213141516DESCRIBE GET_EMP_NAME``` 【训练3】 在发生编译错误时，显示错误。 ```sqlSHOW ERRORS``` 说明：查询一个存储过程或函数是否是有效状态(即编译成功)，可以使用数据字典USER_OBJECTS的STATUS列.【训练4】 查询EMP_LIST存储过程是否可用： ```sqlSELECT STATUS FROM USER_OBJECTS WHERE OBJECT_NAME='EMP_LIST'; 当一个存储过程编译成功，状态变为VALID，会不会在某些情况下变成INVALID。结论是完全可能的。比如一个存储过程中包含对表的查询，如果表被修改或删除，存储过程就会变成无效INVALID。所以要注意存储过程和函数对其他对象的依赖关系。 如果要检查存储过程或函数的依赖性，可以通过查询数据字典USER_DENPENDENCIES来确定，该表结构如下： 1DESCRIBE USER_DEPENDENCIES; 还有一种情况需要我们注意：如果一个用户A被授予执行属于用户B的一个存储过程的权限，在用户B的存储过程中，访问到用户C的表，用户B被授予访问用户C的表的权限，但用户A没有被授予访问用户C表的权限，那么用户A调用用户B的存储过程是失败的还是成功的呢？答案是成功的。如果读者有兴趣，不妨进行一下实际测试。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[易错集二]]></title>
    <url>%2F2017%2F12%2F13%2F%E6%98%93%E9%94%99%E9%9B%86(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[oracle存储过程的易错点 第一点对于创建存储过程和修改命令窗口中可使用【set serveroutput on】而在SQL窗口不可使用： 命令窗口： undefined SQL窗口： undefined 第二点对于调用存储过程中 命令窗口 中可使用 execute procdure_name ，而在SQL窗口不用 第三点undefined undefined 第四点存储函数函数的调用要依赖DBMS_OUTPUT.PUT_LINE(); undefined]]></content>
      <categories>
        <category>易错集</category>
      </categories>
      <tags>
        <tag>易错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十三]]></title>
    <url>%2F2017%2F12%2F10%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十三章，主要是用来复习和巩固在课堂学习的知识！ 笔记IF语句1、IF-THEN-END IF形式 undefined 2、IF-THEN-ELSE-END IF形式 undefined 3．IF-THEN-ELSIF-ELSE-END IF形式 undefined CASE语句1．基本CASE结构 undefined 2.搜索CASE结构 undefined 循环1．基本LOOP循环 undefined 2.FOR LOOP循环 FOR循环是固定次数循环，格式如下： undefined 注：循环控制变量是隐含定义的，不需要声明。 下限和上限用于指明循环次数。正常情况下循环控制变量的取值由下限到上限递增，REVERSE关键字表示循环控制变量的取值由上限到下限递减。 3．WHILE LOOP循环 undefined 游标游标概念 游标是SQL的一个内存工作区，由系统或用户以变量的形式定义。游标的作用就是用于临时存储从数据库中提取的数据块。在某些情况下，需要把数据从存放在磁盘的表中调到计算机内存中进行处理，最后将处理结果显示出来或最终写回数据库。这样数据处理的速度才会提高，否则频繁的磁盘数据交换会降低效率。 游标有两种类型：显式游标和隐式游标。 在前述程序中用到的SELECT…INTO…查询语句，一次只能从数据库中 提取一行数据，系统都会使用一个隐式游标。 显式游标对应一个返回结果为多行多列的SELECT语句。 游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。 隐式游标属性 隐式游标的属性 返回值类型 意 义 SQL%ROWCOUNT 整型 代表DML语句成功执行的数据行数 SQL%FOUND 布尔型 值为TRUE代表插入、删除、更新或单行查询操作成功 SQL%NOTFOUND 布尔型 与SQL%FOUND属性返回值相反 SQL%ISOPEN 布尔型 DML执行过程中为真，结束后为假 如：使用隐式游标的属性，判断对雇员工资的修改是否成功。 步骤1：输入和运行以下程序： undefined 显式游标游标的使用分成以下4个步骤。a．声明游标 在DECLEAR部分按以下格式声明游标： undefined 参数是可选部分，所定义的参数可以出现在SELECT语句的WHERE子句中。如果定义了参数，则必须在打开游标时传递相应的实际参数。 b.打开游标 在可执行部分，按以下格式打开游标： undefined 打开游标时，SELECT语句的查询结果就被传送到了游标工作区。 c.提取数据 在可执行部分，按以下格式将游标工作区中的数据取到变量中。提取操作必须在打开游标之后进行。 undefined 游标打开后有一个指针指向数据区，FETCH语句一次返回指针所指的一行数据，要返回多行需重复执行，可以使用循环语句来实现。控制循环可以通过判断游标的属性来进行。 定义记录变量的方法如下： undefined d.关闭游标 undefined 显式游标打开后，必须显式地关闭。游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。 【例1】 用游标提取emp表中7788雇员的名称和职务。 undefined 【例2】 用游标提取emp表中7788雇员的姓名、职务和工资。 undefined 【例3】 显示工资最高的前3名雇员的名称和工资。 undefined 游标循环（重点）方法一：使用特殊的FOR循环形式显示全部雇员的编号和名称(省略掉定义记录变量、打开游标、提取数据、关闭游标)。 undefined 方法二：最简单方式 undefined 利用游标属性做循环条件【训练1】 使用游标的属性练习。 undefined PL/SQL的基本构成 PL/SQL语言是SQL语言的扩展，具有为程序开发而设计的特性，如数据封装、异常处理、面向对象等特性。PL/SQL是嵌入到Oracle服务器和开发工具中的，所以具有很高的执行效率和同Oracle数据库的完美结合。在PL/SQL模块中可以使用查询语句和数据操纵语句(即进行DML操作)，这样就可以编写具有数据库事务处理功能的模块。 至于数据定义(DDL)和数据控制(DCL)命令的处理，需要通过Oracle提供的特殊的DBMS_SQL包来进行。PL/SQL还可以用来编写过程、函数、包及数据库触发器。过程和函数也称为子程序，在定义时要给出相应的过程名和函数名。它们可以存储在数据库中成为存储过程和存储函数，并可以由程序来调用，它们在结构上同程序模块类似。 PL/SQL过程化结构的特点是：可将逻辑上相关的语句组织在一个程序块内；通过嵌入或调用子块，构造功能强大的程序；可将一个复杂的问题分解成为一组便于管理、定义和实现的小块。 PL/SQL块结构和基本语法要求PL/SQL程序的基本单元是块(BLOCK)，块就是实现一定功能的逻辑模块。一个PL/SQL程序由一个或多个块组成。块有固定的结构，也可以嵌套。一个块可以包括三个部分，每个部分由一个关键字标识。 块中各部分的作用解释如下： (1) DECLARE：声明部分标志。 (2) BEGIN：可执行部分标志。 (3) EXCEPTION：异常处理部分标志。 (4) END；：程序结束标志。 输出 使用函数DBMS_OUTPUT.PUT_LINE显示输出结果。 DBMS_OUTPUT是Oracle提供的包，该包有如下三个用于输出的函数，用于显示PL/SQL程序模块的输出信息。 第一种形式： undefined 用于输出字符串，但不换行，括号中的参数是要输出的字符串表达式。 第二种形式： undefined 用于输出一行字符串信息，并换行，括号中的参数是要输出的字符串表达式。 第三种形式： undefined 用来输出一个换行，没有参数。调用函数时，在包名后面用一个点“.”和函数名分隔，表示隶属关系。 要使用该方法显示输出数据，在SQL*Plus环境下要先执行一次如下的环境设置命令： undefined 用来打开DBMS_OUTPUT.PUT_LINE函数的屏幕输出功能，系统默认状态是OFF。其中，n表示输出缓冲区的大小。n的范围在2000～1 000 000之间，默认为2000。如果输出内容较多，需要使用SIZE n来设置较大的输出缓冲区。 在PL/SQL模块中可以使用查询语句和数据操纵语句(即进行DML操作)，所以PL/SQL程序是同SQL语言紧密结合在一起的。在PL/SQL程序中，最常见的是使用SELECT语句从数据库中获取信息，同直接执行SELECT语句不同，在程序中的SELECT语句总是和INTO相配合，INTO后跟用于接收查询结果的变量，形式如下： undefined 注意：接收查询结果的变量类型、顺序和个数同SELECT语句的字段的类型、顺序和个数应该完全一致。并且SELECT语句返回的数据必须是一行，否则将引发系统错误。当程序要接收返回的多行结果时，可以采用后面介绍的游标的方法。 使用INSERT、DELETE和UPDATE的语法没有变化，但在程序中要注意判断语句执行的状态，并使用COMMIT或ROLLBACK进行事务处理。 【训练1】 查询雇员编号为7788的雇员姓名和工资。 步骤1：用SCOTT账户登录SQL*Plus。 步骤2：在输入区输入以下程序： undefined 步骤3：按执行按钮或F5快捷键执行程序。 以上程序的作用是，查询雇员编号为7788的雇员姓名和工资，然后显示输出。这种方法同直接在SQL环境下执行SELECT语句显示雇员的姓名和工资比较，程序变得更复杂。那么两者究竟有什么区别呢？SQL查询的方法，只限于SQL环境，并且输出的格式基本上是固定的。而程序通过把数据取到变量中，可以进行复杂的处理，完成SQL语句不能实现的功能，并通过多种方式输出。 “–”是注释符号，后边是程序的注释部分。该部分不编译执行，所以在输入程序时可以省略。/……/中间也是注释部分，同“–”注释方法不同，它可以跨越多行进行注释。 PL/SQL程序的可执行语句、SQL语句和END结束标识都要以分号结束。 数据类型 量的基本数据类型同SQL部分的字段数据类型相一致，但是也有不同 变量的数据类型: LOB数据类型可以存储视频、音频或图片，支持随机访问，存储的数据可以位于数据库内或数据库外，具体有四种类型：BFILE、BLOB、CLOB、NCLOB。但是操纵大对象需要使用Oracle提供的DBMS_LOB包。 变量定义 变量定义: 变量的作用是用来存储数据，可以在过程语句中使用。 变量在声明部分可以进行初始化，即赋予初值。 变量的命名规则: 变量名不要和在程序中引用的字段名相重，如果相重，变量名会被当作列名来使用。 变量的作用范围是在定义此变量的程序范围内，如果程序中包含子块，则变量在子块中也有效。但在子块中定义的变量，仅在定义变量的子块中有效，在主程序中无效。 【训练1】 变量的定义和初始化。 输入和运行以下程序： undefined 根据表的字段定义变量变量的声明还可以根据数据库表的字段进行定义或根据已经定义的变量进行定义。 【训练2】 根据表的字段定义变量。 输入并执行以下程序： undefined 说明：变量v_ename是根据表emp的ename字段定义的，两者的数据类型总是一致的。 如果我们根据数据库的字段定义了某一变量，后来数据库的字段数据类型又进行了修改，那么程序中的该变量的定义也自动使用新的数据类型。使用该种变量定义方法，变量的数据类型和大小是在编译执行时决定的，这为书写和维护程序提供了很大的便利。 结合变量的定义和使用我们还可以定义SQLPlus环境下使用的变量，称为结合变量。结合变量也可以在程序中使用，该变量是在整个SQLPlus环境下有效的变量，在退出SQLPlus之前始终有效，所以可以使用该变量在不同的程序之间传递信息。结合变量不是由程序定义的，而是使用系统命令VARIABLE定义的。在SQLPlus环境下显示该变量要用系统的PRINT命令。 【训练3】 定义并使用结合变量。 步骤1：输入和执行下列命令，定义结合变量g_ename： undefined 步骤2：输入和执行下列程序： undefined 步骤3：重新执行程序。 输出结果： ? 步骤4：程序结束后用命令显示结合变量的内容： undefined 说明：g_ename为结合变量，可以在程序中引用或赋值，引用时在结合变量前面要加上“∶”。在程序结束后该变量的值仍然存在，其他程序可以继续引用。 记录变量的定义还可以根据表或视图的一个记录中的所有字段定义变量，称为记录变量。记录变量包含若干个字段，在结构上同表的一个记录相同，定义方法是在表名后跟%ROWTYPE。记录变量的字段名就是表的字段名，数据类型也一致。 【训练4】 根据表定义记录变量。 输入并执行如下程序： undefined TABLE类型变量在PL/SQL中可以定义TABLE类型的变量。 TABLE数据类型用来存储可变长度的一维数组数据，即数组中的数据动态地增长。要定义TABLE变量，需要先定义TABLE数据类型。通过使用下标来引用TABLE变量的元素。 【训练5】 定义和使用TABLE变量： undefined 说明：本例定义了长度为10的字符型TABLE变量，通过赋值语句为前五个元素赋值，最后输出第三个元素。 运算符和函数PL/SQL常见的运算符和函数包括以下方面(这里只做简单的总结，可参见SQL部分的例子)： 算术运算：加(+)、减(-)、乘(*)、除(/)、指数(**)。 关系运算：小于(&lt;)、小于等于(&lt;=)、大于(&gt;)、大于等于(&gt;=)、等于(=)、不等于(!=或&lt;&gt;)。 字符运算：连接(||)。 逻辑运算：与(AND)、或(OR)、非(NOT)。 特殊运算: IS NULL或IS NOT NULL用来判断运算对象的值是否为空，不能用“=”去判断。另外，对空值的运算也必须注意，对空值的算术和比较运算的结果都是空，但对空值可以进行连接运算，结果是另外一部分的字符串。例如： undefined 结构控制语句分支结构 分支结构是最基本的程序结构，分支结构由IF语句实现。 IF-THEN-END IF形式这是最简单的IF结构，练习如下： 【训练1】 如果温度大于30℃，则显示“温度偏高”。 输入并执行以下程序： undefined IF-THEN-ELSE-END IF形式这种形式的练习如下： 【训练2】 根据性别，显示尊称。 输入并执行以下程序： undefined 说明：该程序根据性别显示尊称和问候，无论性别的值为何，总会有显示结果输出。如果V_sex的值不是‘男’和‘女’，那么输出结果会是什么？ IF-THEN-ELSIF-ELSE-END IF形式这种形式的练习如下： 【训练3】 根据雇员工资分级显示税金。 输入并运行以下程序： undefined 选择结构CASE语句适用于分情况的多分支处理，可有以下三种用法。1．基本CASE结构 2．表达式结构CASE语句在Oracle中，CASE结构还能以赋值表达式的形式出现，它根据选择变量的值求得不同的结果。 3．搜索CASE结构Oracle还提供了一种搜索CASE结构，它没有选择变量，直接判断条件表达式的值，根据条件表达式决定转向。 基本CASE结构训练1】 使用CASE结构实现职务转换。 输入并执行程序： undefined 说明：以上实例检索雇员7788的职务，通过CASE结构转换成中文输出。 表达式结构CASE语句【训练2】 使用CASE的表达式结构。 undefined 说明：该CASE表达式通过判断变量v_grade的值，对变量V_result赋予不同的值。 搜索CASE结构【训练3】 使用CASE的搜索结构。 undefined 循环结构循环结构是最重要的程序控制结构，用来控制反复执行一段程序。比如我们要进行累加，则可以通过适当的循环程序实现。PL/SQL循环结构可划分为以下3种： 1.基本LOOP循环。EXIT用于在循环过程中退出循环，WHEN用于定义EXIT的退出条件。如果没有WHEN条件，遇到EXIT语句则无条件退出循环。 2.FOR LOOP循环。 FOR循环是固定次数循环，格式如下： undefined 循环控制变量是隐含定义的，不需要声明。 下限和上限用于指明循环次数。正常情况下循环控制变量的取值由下限到上限递增，REVERSE关键字表示循环控制变量的取值由上限到下限递减。 3.WHILE LOOP循环。 多重循环 基本LOOP循环【训练1】 求：1２+3２+5２+…+15２ 的值。 输入并执行以下程序： undefined 说明：基本循环一定要使用EXIT退出，否则就会成为死循环。 【训练2】 用FOR循环输出图形。 undefined 说明：该程序在循环中使用了循环控制变量I，该变量隐含定义。在每次循环中根据循环控制变量I的值，使用RPAD函数控制显示相应个数的“*”。 【练习2】为以上程序增加REVERSE关键字，观察执行结果。 【训练3】 输出一个空心三角形。 undefined 说明：该实例采用循环和IF结构相结合，对第1行和第9行(I=1 OR I=9)执行同样的输出语句，其他行执行另外的输出语句。 WHILE LOOP循环【训练3】 使用WHILE 循环向emp表连续插入5个记录。 步骤1：执行下面的程序： undefined 步骤2：显示插入的记录： undefined 步骤3：删除插入的记录： undefined 多重循环(了解)循环可以嵌套，以下是一个二重循环的练习。 【训练4】 使用二重循环求1！+2！+…+10！的值。 步骤1：第1种算法： undefined 步骤2：第2种算法： undefined 阶段训练训练1】 插入雇员，如果雇员已经存在，则输出提示信息。 undefined 说明：在本程序中，使用了一个技巧来判断一个雇员是否存在。如果一个雇员不存在，那么使用SELECT…INTO来获取雇员信息就会失败，因为SELECT…INTO形式要求查询必须返回一行。但如果使用COUNT统计查询，返回满足条件的雇员人数，则该查询总是返回一行，所以任何情况都不会失败。COUNT返回的统计人数为0说明雇员不存在，返回的统计人数为1说明雇员存在，返回的统计人数大于1说明有多个满足条件的雇员存在。本例在雇员不存在时进行插入操作，如果雇员已经存在则不进行插入。 【训练2】 输出由符号“*”构成的正弦曲线的一个周期(0～360°)。 undefined 说明：在本程序中使用到了固定次数的循环以及SIN和LPAD函数，通过正确地设置步长、幅度和位移的参数，在屏幕上可正确地显示图形。 游标的概念游标是SQL的一个内存工作区，由系统或用户以变量的形式定义。游标的作用就是用于临时存储从数据库中提取的数据块。在某些情况下，需要把数据从存放在磁盘的表中调到计算机内存中进行处理，最后将处理结果显示出来或最终写回数据库。这样数据处理的速度才会提高，否则频繁的磁盘数据交换会降低效率。 游标有两种类型：显式游标和隐式游标。 在前述程序中用到的SELECT…INTO…查询语句，一次只能从数据库中 提取一行数据，系统都会使用一个隐式游标。 显式游标对应一个返回结果为多行多列的SELECT语句。 游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。 隐式游标如前所述，DML操作和单行SELECT语句会使用隐式游标，它们是： * 插入操作：INSERT。 * 更新操作：UPDATE。 * 删除操作：DELETE。 * 单行查询操作：SELECT ... INTO ...。 当系统使用一个隐式游标时，可以通过隐式游标的属性来了解操作的状态和结果，进而控制程序的流程。 通过SQL游标名总是只能访问前一个DML操作或单行SELECT操作的游标属性。所以通常在刚刚执行完操作之后，立即使用SQL游标名来访问属性。游标的属性有四种 隐式游标属性： 【训练1】 使用隐式游标的属性，判断对雇员工资的修改是否成功。 步骤1：输入和运行以下程序： undefined 步骤2：将雇员编号1234改为7788，重新执行以上程序： 说明：本例中，通过SQL%FOUND属性判断修改是否成功，并给出相应信息。 显式游标游标的定义和操作游标的使用分成以下4个步骤。 1．声明游标 在DECLEAR部分按以下格式声明游标： undefined 参数是可选部分，所定义的参数可以出现在SELECT语句的WHERE子句中。如果定义了参数，则必须在打开游标时传递相应的实际参数。 语句的查询结果就被传送到了游标工作区。SELECT语句是对表或视图的查询语句，甚至也可以是联合查询。可以带WHERE条件、ORDER BY或GROUP BY等子句，但不能使用INTO子句。在SELECT语句中可以使用在定义游标之前定义的变量。 2．打开游标 在可执行部分，按以下格式打开游标： undefined 3．提取数据 在可执行部分，按以下格式将游标工作区中的数据取到变量中。提取操作必须在打开游标之后进行。 undefined 游标打开后有一个指针指向数据区，FETCH语句一次返回指针所指的一行数据，要返回多行需重复执行，可以使用循环语句来实现。控制循环可以通过判断游标的属性来进行。 下面对这两种格式进行说明： 第一种格式中的变量名是用来从游标中接收数据的变量，需要事先定义。变量的个数和类型应与SELECT语句中的字段变量的个数和类型一致。 第二种格式一次将一行数据取到记录变量中，需要使用%ROWTYPE事先定义记录变量，这种形式使用起来比较方便，不必分别定义和使用多个变量。 定义记录变量的方法如下： undefined 其中的表必须存在，游标名也必须先定义。 4．关闭游标 undefined 显式游标打开后，必须显式地关闭。游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。 以下是使用显式游标的一个简单练习。 【训练1】 用游标提取emp表中7788雇员的名称和职务。 undefined 说明：该程序通过定义游标emp_cursor，提取并显示雇员7788的名称和职务。 作为对以上例子的改进，在以下训练中采用了记录变量。 【训练2】 用游标提取emp表中7788雇员的姓名、职务和工资。 undefined 说明：实例中使用记录变量来接收数据，记录变量由游标变量定义，需要出现在游标定义之后。 注意：可通过以下形式获得记录变量的内容： 记录变量名.字段名。 【训练3】 显示工资最高的前3名雇员的名称和工资。 undefined 说明：该程序在游标定义中使用了ORDER BY子句进行排序，并使用循环语句来提取多行数据。 ##游标循环 【训练1】 使用特殊的FOR循环形式显示全部雇员的编号和名称。 undefined 说明：可以看到该循环形式非常简单，隐含了记录变量的定义、游标的打开、提取和关闭过程。Emp_record为隐含定义的记录变量，循环的执行次数与游标取得的数据的行数相一致。 【训练2】 另一种形式的游标循环。 undefined 说明：该种形式更为简单，省略了游标的定义，游标的SELECT查询语句在循环中直接出现。 显式游标属性虽然可以使用前面的形式获得游标数据，但是在游标定义以后使用它的一些属性来进行结构控制是一种更为灵活的方法 标的属性: 可按照以下形式取得游标的属性： undefined 要判断游标emp_cursor是否处于打开状态，可以使用属性emp_cursor%ISOPEN。如果游标已经打开，则返回值为“真”，否则为“假”。具体可参照以下的训练。 【训练1】 使用游标的属性练习。 undefined 说明：本例使用emp_cursor%ISOPEN判断游标是否打开；使用emp_cursor%ROWCOUNT获得到目前为止FETCH语句返回的数据行数并输出；使用循环来获取数据，在循环体中使用FETCH语句；使用emp_cursor%NOTFOUND判断FETCH语句是否成功执行，当FETCH语句失败时说明数据已经取完，退出循环。 【练习1】去掉OPEN emp_cursor;语句，重新执行以上程序。 游标参数的传递【训练1】 带参数的游标。 undefined 说明：游标emp_cursor定义了两个参数：p_deptno代表部门编号，p_job代表职务。语句OPEN emp_cursor(10, ‘CLERK’)传递了两个参数值给游标，即部门为10、职务为CLERK，所以游标查询的内容是部门10的职务为CLERK的雇员。循环部分用于显示查询的内容。 【练习1】修改Open语句的参数：部门号为20、职务为ANALYST，并重新执行。 也可以通过变量向游标传递参数，但变量需要先于游标定义，并在游标打开之前赋值。对以上例子重新改动如下： 【训练2】 通过变量传递参数给游标。 undefined 说明：该程序与前一程序实现相同的功能。 动态SELECT语句和动态游标的用法Oracle支持动态SELECT语句和动态游标，动态的方法大大扩展了程序设计的能力。 对于查询结果为一行的SELECT语句，可以用动态生成查询语句字符串的方法，在程序执行阶段临时地生成并执行，语法是： undefined 以下是一个动态生成SELECT语句的例子。 【训练1】 动态SELECT查询。 undefined 说明：SELECT…INTO…语句存放在STR字符串中，通过EXECUTE语句执行。 在变量声明部分定义的游标是静态的，不能在程序运行过程中修改。虽然可以通过参数传递来取得不同的数据，但还是有很大的局限性。通过采用动态游标，可以在程序运行阶段随时生成一个查询语句作为游标。要使用动态游标需要先定义一个游标类型，然后声明一个游标变量，游标对应的查询语句可以在程序的执行过程中动态地说明。 定义游标类型的语句如下： undefined 声明游标变量的语句如下： undefined 在可执行部分可以如下形式打开一个动态游标： undefined 【训练2】 按名字中包含的字母顺序分组显示雇员信息。 输入并运行以下程序： undefined 说明：使用了二重循环，在外循环体中，动态生成游标的SELECT语句，然后打开。通过语句letter:=chr(ascii(letter)+1)可获得字母表中的下一个字母。 例题（一）【训练1】 查询雇员编号为7788的雇员姓名和工资。 步骤1：用SCOTT账户登录SQL*Plus。 步骤2：在输入区输入以下程序： undefined 步骤3：按执行按钮或F5快捷键执行程序。 【训练2】 变量的定义和初始化。 输入和运行以下程序： undefined 【训练3】 根据表的字段定义变量。 输入并执行以下程序： undefined 【训练4】 定义并使用结合变量。步骤1：输入和执行下列命令，定义结合变量g_ename： undefined 步骤2：输入和执行下列程序： undefined 步骤3：重新执行程序。 步骤4：程序结束后用命令显示结合变量的内容： undefined 【训练5】 根据表定义记录变量。 输入并执行如下程序： undefined 【训练6】 定义和使用TABLE变量： undefined 【训练7】 如果温度大于30℃，则显示“温度偏高”。输入并执行以下程序： undefined 试修改温度的初值为25℃，重新执行，观察结果。 【训练8】 根据性别，显示尊称。 输入并执行以下程序： undefined 【训练9】 根据雇员工资分级显示税金。 输入并运行以下程序： undefined 例题（二）【训练1】 使用CASE结构实现职务转换。 输入并执行程序： undefined 【训练2】 使用CASE的表达式结构。 undefined 【训练3】 使用CASE的搜索结构。 undefined 【训练4】 求：1２+3２+5２+…+15２ 的值。 输入并执行以下程序： undefined 【训练5】 用FOR循环输出图形。 undefined 【训练6】 输出一个空心三角形。 undefined 【训练7】 使用WHILE 循环向emp表连续插入5个记录。步骤1：执行下面的程序： undefined 步骤2：显示插入的记录： undefined 步骤3：删除插入的记录： undefined 【训练8】 使用二重循环求1！+2！+…+10！的值。 步骤1：第1种算法： undefined 步骤2：第2种算法： undefined 【训练9】 插入雇员，如果雇员已经存在，则输出提示信息。 undefined 【训练10】 输出由符号“*”构成的正弦曲线的一个周期(0～360°)。 undefined ## 例题（三）【训练1】 使用隐式游标的属性，判断对雇员工资的修改是否成功。 步骤1：输入和运行以下程序： undefined 步骤2：将雇员编号1234改为7788，重新执行以上程序： 【训练2】 用游标提取emp表中7788雇员的名称和职务。 undefined 【训练3】 用游标提取emp表中7788雇员的姓名、职务和工资。 undefined 【训练4】 显示工资最高的前3名雇员的名称和工资。 undefined 【训练5】 使用特殊的FOR循环形式显示全部雇员的编号和名称。 undefined 【训练6】 另一种形式的游标循环。 undefined 【训练7】 使用游标的属性练习。 undefined 【训练8】 带参数的游标。 undefined 【训练9】 通过变量传递参数给游标。 undefined 【训练10】 动态SELECT查询。 undefined 【训练11】 按名字中包含的字母顺序分组显示雇员信息。 输入并运行以下程序： declare type cur_type is ref cursor; cur cur_type;--声明为一个未绑定的游标 rec scott.emp%rowtype; str varchar2(50); letter char:= 'A'; begin loop str:= 'select ename from emp where ename like ''%'||letter||'%'''; open cur for str;--打开游标变量方式1 dbms_output.put_line('包含字母'||letter||'的名字：'); loop fetch cur into rec.ename; exit when cur%notfound; dbms_output.put_line(rec.ename); end loop; exit when letter='Z'; letter:=chr(ascii(letter)+1); end loop; end;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DW快捷键]]></title>
    <url>%2F2017%2F12%2F09%2FDW%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[DW快捷键！ 文档操作 功能 快捷键 新建文档 Ctrl+N 打开一个 HTML文件 Ctrl+O或者将文件从[文件管理器]或[站点]窗口拖动到[文档]窗口中 在框架中打开 Ctrl+Shift+O 关闭 Ctrl+W 保存 Ctrl+S 另存为 Ctrl+Shift+S 检查链接 Shift + F8 退出 Ctrl+Q 编辑菜单 功能 快捷键 撤消 Ctrl+Z 重复 Ctrl+Y 或 Ctrl+Shift+Z 剪切 Ctrl+X 或Shift+Del 拷贝 Ctrl+C 或Ctrl+Ins 粘贴 Ctrl+V 或Shift+Ins 清除 Delete 全选 Ctrl+A 选择父标签 Ctrl+Shift+&lt; 选择子标签 Ctrl+Shift+&gt; 查找和替换 Ctrl+F 查找下一个 F3 缩进代码 Ctrl+Shift+] 左缩进代码 Ctrl+Shift+[ 平衡大括弧 Ctrl+’ 启动外部编辑器 Ctrl+E 参数选择 Ctrl+U 页面视图 功能 快捷键 标准视图 Ctrl+Shift+F6 布局视图 Ctrl+F6 工具条 Ctrl+Shift+T 查看页面元素 功能 快捷键 可视化助理 Ctrl+Shift+I 标尺 Ctrl+Alt+R 显示网格 Ctrl+Alt+G 靠齐到网格 Ctrl+Alt+Shift+G 头内容 Ctrl+Shift+W 页面属性 Ctrl+Shift+J 代码编辑 功能 快捷键 切换到设计视图 Ctrl+Tab 打开快速标签编辑器 Ctrl+T 选择父标签 Ctrl+Shift+&lt; 平衡大括弧 Ctrl+’ 全选 Ctrl+A 拷贝 Ctrl+C 查找和替换 Ctrl+F 查找下一个 F3 替换 Ctrl+H 粘贴 Ctrl+V 剪切 Ctrl+X 重复 Ctrl+Y 撤消 Ctrl+Z 切换断点 Ctrl+Alt+B 向上选择一行 Shift+Up 向下选择一行 Shift+Down 选择左边字符 Shift+Left 选择右边字符 Shift+Right 向上翻页 Page Up 向下翻页 Page Down 向上选择一页 Shift+Page Up 向下选择一页 Shift+Page Down 选择左边单词 Ctrl+Shift+Left 选择右边单词 Ctrl+Shift+Right 移到行首 Home 移到行尾 End 移 动到代码顶部 Ctrl+Home 移 动到代码尾部 Ctrl+End 向上选择到代码顶部 Ctrl+Shift+Home 向下选择到代码顶部 Ctrl+Shift+End 编辑文本 功能 快捷键 创建新段落 Enter 插入换行 Shift+Enter 插入不换行空格 Ctrl+Shift+Spacebar 拷贝文本或对象到页面其他位置 Ctrl+拖动选取项目到新位置 选取一个单词 双击 将选定项目添加到库 Ctrl+Shift+B 在设计视图和代码编辑器之间切换 Ctrl+Tab 打开和关闭[属性]检查器 Ctrl+Shift+J 检查拼写 Shift+F7 格式化文本 功能 快捷键 缩进 Ctrl+] 左缩进 Ctrl+[ 格式&gt;无 Ctrl+0 (零) 段落格式 Ctrl+Shift+P 应用标题1到6到段落 Ctrl+1 到 6 对齐&gt;左对齐 Ctrl+Shift+Alt+L 对齐&gt;居中 Ctrl+Shift+Alt+C 对齐&gt;右对齐 Ctrl+Shift+Alt+R 加粗选定文本 Ctrl+B 倾斜选定文本 Ctrl+I 编辑样式表 Ctrl+Shift+E 查找和替换文本 功能 快捷键 查找 Ctrl+F 查找下一个/再查找 F3 替换 Ctrl+H 处理表格 功能 快捷键 选择表格（光标在表格中） Ctrl+A 移 动到下一单元格 Tab 移 动到上一单元格 Shift+Tab 插入行（在当前行之前） Ctrl+M 在表格末插入一行 在最后一个单元格 Tab 删除当前行 Ctrl+Shift+M 插入列 Ctrl+Shift+A 删除列 Ctrl+Shift+ - (连字符) 合并单元格 Ctrl+Alt+M 拆分单元格 Ctrl+Alt+S 更新表格布局（在“快速表格编辑”模式中强制重绘） Ctrl+Spacebar 处理框架 功能 快捷键 选择框架 框架中Alt+点击 选择下一框架或框架页 Alt+右方向键 选择上一框架或框架页 Alt+左方向键 选择父框架 Alt+上方向键 选择子框架或框架页 Alt+下方向键 添加新框架到框架页 Alt+从框架边界拖动 使用推模式添加新框架到框架页 Alt+Ctrl+从框架边界拖动 处理层 功能 快捷键 选择层 Ctrl+Shift+点击 选择并移 动层 Shift+Ctrl+拖动 从选择中添加或删除层 Shift+点击层 以象素为单位移 动所选层 上方向键 按靠齐增量移 动所选层 Shift+方向键 以象素为单位调整层大小 Ctrl+方向键 以靠齐增量为单位调整层大小 Ctrl+Shift+方向键 将所选层与最后所选层的顶部/底部/左边/右边对齐 Ctrl+上/下/左/右方向键 统一所选层宽度 Ctrl+Shift+[ 统一所选层高度 Ctrl+Shift+] 创建层时切换嵌套设置 Ctrl+拖动 切换网格显示 Ctrl+Shift+Alt+G 靠齐到网格 Ctrl+Alt+G 处理时间轴,图象 功能 快捷键 添加对象到时间轴 Ctrl+Alt+Shift+T 添加关键帧 Shift+F9 删除关键帧 Delete 改变图象源文件属性 Double+点击图象 在外部编辑器中编辑图象 Ctrl+双击图象 管理超链接 功能 快捷键 创建超链接（选定文本） Ctrl+L 删除超链接 Ctrl+Shift+L 拖动并投放以从文档创建超链接 选取文本，图象或对象，然后Shift+拖动选择到[站点]窗口中的文件 拖动并投放以使用[属性]检查器创建超链接 选取文本，图象或对象，然后拖动[属性]检查器的指向文件图表到[站点]窗口的文件 在Dreamweaver打开链接文档 Ctrl+双击链接 检查选定链接 Shift+F8 检查整个站点中的链接 Ctrl+F8 在浏览器中定位和预览 功能 快捷键 在主浏览器中预览 F12 在次要浏览器中预览 Ctrl+F12 在浏览器中调试 功能 快捷键 在主浏览器中调试 Alt+F12 在次要浏览器中调试 Ctrl+Alt+F12 站点管理和FTP 功能 快捷键 创建新文件 Ctrl+Shift+N 创建新文件夹 Ctrl+Shift+Alt+N 打开选定 Ctrl+Shift+Alt+O 从远程FTP站点下载选定文件或文件夹 Ctrl+Shift+D或将文件从[站点]窗口的[远程]栏拖动到[本地]栏 将选定文件或文件夹上载到远程FTP站点 Ctrl+Shift+U或将文件从[站点]窗口的[本地]栏拖动到[远程]栏 取出 Ctrl+Shift+Alt+D 存回 Ctrl+Shift+Alt+U 查看站点地图 Alt+F8 刷新远端站点 Alt+F5 站点地图 功能 快捷键 查看站点文件 F8 刷新本地栏 Shift+F5 设为根 Ctrl+Shift+R 链接到现存文件 Ctrl+Shift+K 改变链接 Ctrl+L 删除链接 Delete 功能 快捷键 显示/隐藏链接 Ctrl+Shift+Y 显示页面标题 Ctrl+Shift+T 重命名文件 F2 放大站点地图 Ctrl+ + (plus) 缩小站点地图 Ctrl+ - (hyphen) 播放插件 功能 快捷键 播放插件 Ctrl+Alt+P 停止插件 Ctrl+Alt+X 播放所有插件 Ctrl+Shift+Alt+P 停止所有插件 Ctrl+Shift+Alt+X 处理模板 功能 快捷键 创建新的可编辑区域 Ctrl+Alt+V 插入对象 功能 快捷键 任何对象（图象，Shockwave影片等） 文件从[资源管理器]或[站点]窗口拖动到[文档]窗口 图象 Ctrl+Alt+I 表格 Ctrl+Alt+T Flash影片 Ctrl+Alt+F Shockwave和Director影片 Ctrl+Alt+D 命名锚记 Ctrl+Alt+A 历史纪录面板 功能 快捷键 打开[历史纪录]面板 Shift F10 开始/停止录制命令 Ctrl+Shift+X 播放录制好的命令 Ctrl+P 打开和关闭面板 功能 快捷键 对象 Ctrl+F2 属性 Ctrl+F3 站点文件 F5 站点地图 trl+F5 资源 F11 CSS样式 Shift+F11 HTML样式 Ctrl+F11 行为 Shift+F3 历史纪录 Shift+F10 时间轴 Shift+F9 代码检查器 F10 框架 Shift+F2 层 F2 参考 Ctrl+Shift+F1 显示/隐藏浮动面板 F4 最小化所有窗口 Shift+F4 最大化所有窗口 Alt+Shift+F4 获得帮助 功能 快捷键 使用Dreamweaver[帮助主题] F1 参考 Shift+F1 Dreamweaver支持中心 Ctrl+F1 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>DW cc 快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[易错集（一）]]></title>
    <url>%2F2017%2F12%2F09%2F%E6%98%93%E9%94%99%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[sql server delete truncat drop 三者区别 sql server 插入数据的几种方式 html5背景音乐 背景音乐的控制 sql server delete truncat drop 三者区别 相同点： 1.truncate和不带where子句的delete、以及drop都会删除表内的数据。 2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。 不同点： truncate 和 delete 只删除数据不删除表的结构(定义)drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。 delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。 3.delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动drop 语句将表所占用的空间全部释放。truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。 4.速度，一般来说: drop&gt; truncate &gt; delete 5.安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.想删除表,当然用 drop想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。 6.delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交。 7、TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 8、TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 9、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 10、TRUNCATE TABLE 不能用于参与了索引视图的表。 参考 sql server 插入数据的几种方式 单行插入： insert into [table] values (); 示例： insert into student (No,Name,Sex) values (1,&apos;小丽&apos;，&apos;女&apos;); -- 不整行插入（键对值） insert into student values (1,&apos;小丽&apos;，&apos;女&apos;); -- 整行插入; 多行插入(1)： Insert into [Table2](field1,field2,...) select value1,value2,... from [Table1] Table1和Table2表都存在 示例： --1.创建测试表 create TABLE Table1 ( a varchar(10), b varchar(10), c varchar(10) ) create TABLE Table2 ( a varchar(10), c varchar(10), d int ) --2.创建测试数据 Insert into Table1 values(&apos;张三&apos;,&apos;123456&apos;,&apos;90&apos;) Insert into Table1 values(&apos;李四&apos;,&apos;123456&apos;&apos;,&apos;100&apos;) Insert into Table1 values(&apos;王五&apos;,&apos;123456&apos;&apos;,&apos;80&apos;) Insert into Table1 values(&apos;赵六&apos;,&apos;123456&apos;&apos;,null) --3.INSERT INTO SELECT语句复制表数据部分列和常值 Insert into Table2(a, c, d) select a,c,5 from Table1 或： Insert into Table2 select * from Table1 多行插入(2)： SELECT vale1, value2 into Table2 from Table1 -- Table2表不存在 示例： --1.创建测试表 create TABLE Table1 ( a varchar(10), b varchar(10), c varchar(10) ) --2.创建测试数据 Insert into Table1 values(&apos;张三&apos;,&apos;123456&apos;,&apos;90&apos;) Insert into Table1 values(&apos;李四&apos;,&apos;123456&apos;&apos;,&apos;100&apos;) Insert into Table1 values(&apos;王五&apos;,&apos;123456&apos;&apos;,&apos;80&apos;) Insert into Table1 values(&apos;赵六&apos;,&apos;123456&apos;&apos;,null) --3.SELECT INTO FROM语句创建表Table2并复制数据 select a,c INTO Table2 from Table1 多行插入(3)： --去重复（会把完全重复的数据过滤掉） insert into [table1](例名) select (例名值) union select (例名值) union ... 或： -- 不去重复(会保留完全重复的数据) insert into [table1](例名) select (例名值) union all select (例名值) union all 示例： -- 只会插入两条数据，因为会把完全重复的数据过滤掉 insert into test(No,name) select 1,&apos;a&apos; union select 2,&apos;b&apos; union select 1,&apos;a&apos; -- 如果有完全相同的数据要插入，则用union all insert into test(No,name) select 1,&apos;a&apos; union select 2,&apos;b&apos; union select 1,&apos;a&apos; 参考 html5背景音乐 属性 值 描述 autoplay autoplay 如果出现该属性，则音频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 loop loop 如果出现该属性，则每当音频结束时重新循环开始播放。 preload preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。 如果使用 “autoplay”，则忽略该属性。src|url|要播放的音频的 URL。也可以使用标签来设置音频。 第一种： //会显示播放器 &lt;video controls=&quot;&quot; autoplay=&quot;&quot; name=&quot;media&quot;&gt;&lt;source src=&quot;/&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/video&gt; 第二种： //能支持大部分的浏览器 &lt;embed src=&quot;/&quot; autostart=&quot;true&quot; loop=&quot;true&quot; hidden=&quot;true&quot;&gt;&lt;/embed&gt; 第三种： //不显示播放器 &lt;audio autoplay=&quot;&quot; loop=&quot;&quot;&gt;&lt;source src=&quot;/&quot;&gt;&lt;/audio&gt; 第四种： //最简洁的 &lt;bgsound src=背景音乐链接地址 loop=-1&gt; 第五种： &lt;audio src=&quot;/&quot; id=&quot;aud&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt; 背景音乐的控制代码： undefined]]></content>
      <categories>
        <category>易错集</category>
      </categories>
      <tags>
        <tag>易错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十二]]></title>
    <url>%2F2017%2F12%2F09%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十二章，主要是用来复习和巩固在课堂学习的知识！ 笔记 索引 索引(INDEX)是为了加快数据的查找而创建的数据库对象，特别是对大表，索引可以有效地提高查找速度，也可以保证数据的惟一性创建索引一般要掌握以下原则：只有较大的表才有必要建立索引，表的记录应该大于50条，查询数据小于总行数的2%～4%。虽然可以为表创建多个索引，但是无助于查询的索引不但不会提高效率，还会增加系统开销。因为当执行DML操作时，索引也要跟着更新，这时索引可能会降低系统的性能。创建索引： 1CREATE INDEX 索引名 ON 表名(列名); 删除索引： 1DROP INDEX 索引名； 同义词 同义词(SYNONYM)是为模式对象起的别名，可以为表、视图、序列、过程、函数和包等数据库模式对象创建同义词。创建私有同义词： 1CREATE SYNONYM BOOK FOR 图书； 创建公有同义词(先要获得创建公有同义词的权限)： 1CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书； 删除同义词： 1DROP SYNONYM 同义词名； 数据库链接 数据库链接(DATABASE LINK)是在分布式环境下，为了访问远程数据库而创建的数据通信链路。 格式： 1CREATE DATABASE LINK 链接名 CONNECT TO 账户 IDENTIFIED BY 口令 USING 服务名; 数据库链接一旦建立并测试成功，就可以使用以下形式来访问远程用户的表。 表名@数据库链接名 PL/sql 1.块结构和基本语法要求 块中各部分的作用解释如下： 1234567(1) DECLARE：声明部分标志。(2) BEGIN：可执行部分标志。(3) EXCEPTION：异常处理部分标志。(4) END；：程序结束标志。 2、输出第一种形式： 1DBMS_OUTPUT.PUT(字符串表达式)； 第二种形式： 1DBMS_OUTPUT.PUT_LINE(字符串表达式)； 第三种形式： 1DBMS_OUTPUT.NEW_LINE； 3、变量赋值： 第一种形式：SELECT 列名1，列名2… INTO 变量1，变量2… FROM 表名 WHERE 条件； 第二种形式：变量名:=值 例：查询雇员编号为7788的雇员姓名和工资。SET SERVEROUTPUT ON 123456789101112131415161718192021DECLARE--定义部分标识 v_name VARCHAR2(10); --定义字符串变量v_name v_sal NUMBER(5); --定义数值变量v_sal BEGIN --可执行部分标识SELECT ename,sal INTO v_name,v_sal FROM emp WHERE empno=7788;--在程序中插入的SQL语句 DBMS_OUTPUT.PUT_LINE('7788号雇员是：'||v_name||'，工资为：'||to_char(v_sal));--输出雇员名和工资 END;``` 4、结合变量的定义和使用（即全局变量） - 该变量是在整个SQL*Plus环境下有效的变量，在退出SQL*Plus之前始终有效，所以可以使用该变量在不同的程序之间传递信息。结合变量不是由程序定义的，而是使用系统命令VARIABLE定义的。例：定义并使用结合变量步骤1：输入和执行下列命令，定义结合变量g_ename： ```sql VARIABLE g_ename VARCHAR2(100) 步骤2：输入和执行下列程序： 123456789SET SERVEROUTPUT ON BEGIN :g_ename:=:g_ename|| 'Hello~ '; --在程序中使用结合变量 DBMS_OUTPUT.PUT_LINE(:g_ename); --输出结合变量的值 END; 5．记录变量的定义 还可以根据表或视图的一个记录中的所有字段定义变量，称为记录变量。记录变量包含若干个字段，在结构上同表的一个记录相同，定义方法是在表名后跟%ROWTYPE。记录变量的字段名就是表的字段名，数据类型也一致。 如： 1v_name emp.ename%TYPE; 数据库模式对象 Oracle数据库的模式对象 对 象 名 称 作 用 TABLE 表 用于存储数据的基本结构 VIEW 视图 以不同的侧面反映表的数据，是一种逻辑上的表 INDEX 索引 加快表的查询速度 CLUSTER 聚簇 将不同表的字段并用的一种特殊结构的表集合 SEQUENCE 序列 生成数字序列，用于在插入时自动填充表的字段 SYNONYM 同义词 为简化和便于记忆，给对象起的别名 DATABASE LINK 数据库链接 为访问远程对象创建的通道 STORED PROCEDURE、FUNCTION 存储过程和函数 存储于数据库中的可调用的程序和函数 PACKAGE、PACKAGE BODY 包和包体 将存储过程、函数及变量按功能和类别进行捆绑 索引 索引(INDEX)是为了加快数据的查找而创建的数据库对象，特别是对大表，索引可以有效地提高查找速度，也可以保证数据的惟一性。索引是由Oracle自动使用和维护的，一旦创建成功，用户不必对索引进行直接的操作。索引是独立于表的数据库结构，即表和索引是分开存放的，当删除索引时，对拥有索引的表的数据没有影响。 在创建PRIMARY KEY和UNIQUE约束条件时，系统将自动为相应的列创建惟一(UNIQUE)索引。索引的名字同约束的名字一致。 索引有两种：B*树索引和位图(BITMAP)索引。 【B树索引是通常使用的索引，也是默认的索引类型。在这里主要讨论B树索引。B*树是一种平衡2叉树，左右的查找路径一样。这种方法保证了对表的任何值的查找时间都相同。】 【B*树索引可分为：惟一索引、非惟一索引、一列简单索引和多列复合索引。】 创建索引一般要掌握以下原则：只有较大的表才有必要建立索引，表的记录应该大于50条，查询数据小于总行数的2%～4%。虽然可以为表创建多个索引，但是无助于查询的索引不但不会提高效率，还会增加系统开销。因为当执行DML操作时，索引也要跟着更新，这时索引可能会降低系统的性能。一般在主键列或经常出现在WHERE子句或连接条件中的列建立索引，该列称为索引关键字。 索引的创建 创建索引不需要特定的系统权限。索引会自动被引用。 1DROP INDEX 索引名； 【训练1】 创建和删除索引。 步骤1：创建索引： 1CREATE INDEX EMP_ENAME ON EMP(ENAME); 步骤2：查询中引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE ENAME='SCOTT'; 步骤3：删除索引： 1DROP INDEX EMP_ENAME; 【训练2】 创建复合索引。索引出现在WHERE子句中的时候就会被自动被引用。 步骤1：创建复合索引： 1CREATE INDEX EMP_JOBSAL ON EMP(JOB,SAL); 步骤2：查询中引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE JOB='MANAGER'AND SAL&gt;2500; 如下的查询也会引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE JOB='CLERK'; 但以下查询不会引用索引，因为没有先引用索引关键字的主键： 1SELECT ENAME,JOB,SAL FROM EMP WHERE SAL&gt;2500; 查看索引 通过查询数据字典USER_INDEXES可以检查创建的索引。 通过查询数据字典USER_IND_COLUMNS可以检查索引的列。 【训练1】 显示emp表的索引： 1SELECT INDEX_NAME, INDEX_TYPE, UNIQUENESS FROM USER_INDEXES WHERE TABLE_NAME=&apos;EMP&apos;; 【训练2】 显示索引的列。 12SELECT COLUMN_NAME FROM USER_IND_COLUMNS WHERE INDEX_NAME='EMP_JOBSAL'; 同义词 同义词(SYNONYM)是为模式对象起的别名，可以为表、视图、序列、过程、函数和包等数据库模式对象创建同义词。同义词有两种：公有同义词和私有同义词。公有同义词是对所有用户都可用的。创建公有同义词必须拥有系统权限CREATE PUBLIC SYNONYM；创建私有同义词需要CREATE SYNONYM系统权限。私有同义词只对拥有同义词的账户有效，但私有同义词也可以通过授权，使其对其他用户有效。同义词通过给本地或远程对象分配一个通用或简单的名称，隐藏了对象的拥有者和对象的真实名称，也简化了SQL语句。 如果同义词同对象名称重名，私有同义词又同公有同义词重名，那么，识别的顺序是怎样的呢？如果存在对象名，则优先识别，其次识别私有同义词，最后识别公有同义词。比如,执行以下的SELECT语句： 1SELECT * FROM ABC; 如果存在表ABC，就对表ABC执行查询语句；如果不存在表ABC，就去查看是否有私有同义词ABC，如果有就对ABC执行查询(此时ABC是另外一个表的同义词)；如果没有私有同义词ABC，则去查找公有同义词；如果找不到，则查询失败。 同义词的创建和使用1DROP SYNONYM 同义词名； 【训练1】 创建同义词。 步骤1：创建私有同义词： 1CREATE SYNONYM BOOK FOR 图书； 步骤2：创建公有同义词(先要获得创建公有同义词的权限)： 1CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书； 步骤3：使用同义词： 1SELECT * FROM BOOK; 同义词的查看 通过查询数据字典USER_OBJECTS和USER_SYNONYMS，可以查看同义词信息。 【训练1】 查看用户拥有的同义词： 1SELECT OBJECT_NAME FROM USER_OBJECTS WHERE OBJECT_TYPE='SYNONYM'; 系统定义同义词 系统为常用的对象预定义了一些同义词，利用它们可以方便地访问用户的常用对象 Oracle数据库模式对象 对 象 名 称 作 用 DICT DICTIONARY 数据字典 CAT USER_CATALOG 用户拥有的表、视图、同义词和序列 CLU USER_CLUSTERS 用户拥有的聚簇 IND USER_INDEXES 用户拥有的索引 OBJ USER_OBJECTS 用户拥有的对象 SEQ USER_SEQUENCES 用户拥有的序列 SYN USER_SYNONYMS 用户拥有的私有同义词 COLS USER_TAB_COLUMNS 用户拥有的表、视图和聚簇的列 TABS USER_TABLES 用户拥有的表 【训练1】 查看用户拥有的表： 1SELECT TABLE_NAME FROM TABS; 聚簇【了解】 所谓聚簇(CLUSTER)，形象地说，就是生长在一起的表。聚簇包含一张或多张表，表的公共列被称为聚簇关键字，在公共列上具有同一值的列物理上存储在一起。那么在什么情况下需要创建聚簇呢？通常在多个表有共同的列时，应使用聚簇。比如有一张学生基本情况表，其中包含学生的学号、姓名、性别、住址等信息。另外，还设计了一张学生成绩表，其中除了包含学生成绩，也包含学生的学号、姓名、性别。那么这两张表共同的列就可以创建成聚簇。这样两张表的共同的学号、姓名和性别，就存放在了一起，相同的值只存放一次。如果两个表通过聚簇列进行联合，则会大大提高查询的速度，但对于插入等操作则会降低效率。 创建聚簇后，要创建使用聚簇的表，对聚簇还应该建立索引。如果不对聚簇建立索引，则不能对聚簇表进行插入、修改和删除操作。 创建聚簇需要CREATE CLUSTER系统权限。 【训练1】 创建和使用聚簇。 步骤1：创建聚簇： 123CREATE CLUSTER COMM(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2))SIZE 500TABLESPACE USERS; 步骤2：创建第一张聚簇表： 12345678CREATE TABLE STUDENT(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2),ADDRESS VARCHAR2(20),E_MAIL VARCHAR2(20))CLUSTER COMM(STUNO,STUNAME,SEX); 步骤3：创建第二张聚簇表： 12345678CREATE TABLE SCORE(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2),CHINESE NUMBER(3),MATH NUMBER(3),ENGLISH NUMBER(3) )CLUSTER COMM(STUNO,STUNAME,SEX); 步骤4：为聚簇创建索引： 1CREATE INDEX INX_COMM ON CLUSTER COMM; 步骤5：向表中插入数据： 123456INSERT INTO STUDENT VALUES(10001,'黄凯','男','宝安','HK123@163.COM');INSERT INTO STUDENT VALUES(10002,'苏丽','女','罗湖','SL99@163.COM');INSERT INTO STUDENT VALUES(10003,'刘平平','男','南山','PP2003@SHOU.COM');INSERT INTO SCORE VALUES(10001,'黄凯','男',70,85,93);INSERT INTO SCORE VALUES(10002,'苏丽','女',65,74,83);INSERT INTO SCORE VALUES(10003,'刘平平','男',88,75,69); 步骤6：删除聚簇及聚簇表： 1DROP CLUSTER COMM INCLUDING TABLES CASCADE CONSTRAINTS; 数据库链接 数据库链接(DATABASE LINK)是在分布式环境下，为了访问远程数据库而创建的数据通信链路。数据库链接隐藏了对远程数据库访问的复杂性。通常，我们把正在登录的数据库称为本地数据库，另外的一个数据库称为远程数据库。 有了数据库链接，可以直接通过数据库链接来访问远程数据库的表。常见的形式是访问远程数据库固定用户的链接，即链接到指定的用户，创建这种形式的数据库链接的语句 如下： 12CREATE DATABASE LINK 链接名 CONNECT TO 账户 IDENTIFIED BY 口令USING 服务名; 创建数据库链接，需要CREATE DATABASE LINK系统权限。 数据库链接一旦建立并测试成功，就可以使用以下形式来访问远程用户的表。 表名@数据库链接名 【训练1】 在局域网上创建和使用数据库链接。 步骤1：创建远程数据库的服务名，假定局域网上另一个数据库服务名为MYDB_REMOTE。 步骤2：登录本地数据库SCOTT账户，创建数据库链接： 12CONNECT SCOTT/TIGER@MYDBCREATE DATABASE LINK abc CONNECT TO scott IDENTIFIED BY tiger USING 'MYDB_REMOTE'; 步骤3：查询远程数据库的数据： 1SELECT * FROM emp@abc; 结果略。 步骤4：一个分布查询： 1SELECT ename,dname FROM emp@abc e,dept d WHERE e.deptno=d.deptno; 说明：在本例中，远程数据库服务名是MYDB_REMOTE，创建的数据库链接名称是abc.emp@abc表示远程数据库的emp表。步骤4是一个联合查询，数据来自本地服务器的dept表和远程服务器的emp表。 例题【训练1】 创建和删除索引。 步骤1：创建索引： 1CREATE INDEX EMP_ENAME ON EMP(ENAME); 步骤2：查询中引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE ENAME='SCOTT'; 步骤3：删除索引： 1DROP INDEX EMP_ENAME; 【训练2】 创建复合索引。索引出现在WHERE子句中的时候就会被自动被引用。 步骤1：创建复合索引： 1CREATE INDEX EMP_JOBSAL ON EMP(JOB,SAL); 步骤2：查询中引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE JOB='MANAGER'AND SAL&gt;2500; 如下的查询也会引用索引： 1SELECT ENAME,JOB,SAL FROM EMP WHERE JOB='CLERK'; 但以下查询不会引用索引，因为没有先引用索引关键字的主键： 1SELECT ENAME,JOB,SAL FROM EMP WHERE SAL&gt;2500; 【训练3】 显示emp表的索引： 1SELECT INDEX_NAME, INDEX_TYPE, UNIQUENESS FROM USER_INDEXES WHERE TABLE_NAME='EMP'; 【训练4】 显示索引的列。 12SELECT COLUMN_NAME FROM USER_IND_COLUMNS WHERE INDEX_NAME='EMP_JOBSAL'; 【训练5】 创建同义词。 步骤1：创建私有同义词： 1CREATE SYNONYM BOOK FOR 图书； 步骤2：创建公有同义词(先要获得创建公有同义词的权限)： 1CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书； 步骤3：使用同义词： 1SELECT * FROM BOOK; 【训练6】 查看用户拥有的同义词： 1SELECT OBJECT_NAME FROM USER_OBJECTS WHERE OBJECT_TYPE='SYNONYM'; 【训练7】 查看用户拥有的表： 1SELECT TABLE_NAME FROM TABS; 【训练8】 创建和使用聚簇。 步骤1：创建聚簇： 123CREATE CLUSTER COMM(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2))SIZE 500TABLESPACE USERS; 步骤2：创建第一张聚簇表： 1234567CREATE TABLE STUDENT(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2),ADDRESS VARCHAR2(20),E_MAIL VARCHAR2(20))CLUSTER COMM(STUNO,STUNAME,SEX); 步骤3：创建第二张聚簇表： 12345678CREATE TABLE SCORE(STUNO NUMBER(5),STUNAME VARCHAR2(10),SEX VARCHAR2(2),CHINESE NUMBER(3),MATH NUMBER(3),ENGLISH NUMBER(3) )CLUSTER COMM(STUNO,STUNAME,SEX); 步骤4：为聚簇创建索引： CREATE INDEX INX_COMM ON CLUSTER COMM; 步骤5：向表中插入数据： 123456INSERT INTO STUDENT VALUES(10001,'黄凯','男','宝安','HK123@163.COM');INSERT INTO STUDENT VALUES(10002,'苏丽','女','罗湖','SL99@163.COM');INSERT INTO STUDENT VALUES(10003,'刘平平','男','南山','PP2003@SHOU.COM');INSERT INTO SCORE VALUES(10001,'黄凯','男',70,85,93);INSERT INTO SCORE VALUES(10002,'苏丽','女',65,74,83);INSERT INTO SCORE VALUES(10003,'刘平平','男',88,75,69); 步骤6：删除聚簇及聚簇表： 1DROP CLUSTER COMM INCLUDING TABLES CASCADE CONSTRAINTS; 【训练9】 在局域网上创建和使用数据库链接。 步骤1：创建远程数据库的服务名，假定局域网上另一个数据库服务名为MYDB_REMOTE。 步骤2：登录本地数据库SCOTT账户，创建数据库链接： 12CONNECT SCOTT/TIGER@ORACLECREATE DATABASE LINK abc CONNECT TO scott IDENTIFIED BY tiger USING 'MYDB_REMOTE'; 步骤3：查询远程数据库的数据： 1SELECT * FROM emp@abc; 步骤4：一个分布查询： 1SELECT ename,dname FROM emp@abc e,dept d WHERE e.deptno=d.deptno;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[staruml教程]]></title>
    <url>%2F2017%2F12%2F07%2Fstaruml%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这一个外接教程！ 教程地址]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>staruml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种编程命名法(转)]]></title>
    <url>%2F2017%2F12%2F06%2F%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E5%91%BD%E5%90%8D%E6%B3%95%2F</url>
    <content type="text"><![CDATA[三种编程命名法! 三种编程命名规范（匈牙利命名法、驼峰式命名法、帕斯卡命名法） 匈牙利命名开头字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，要求单词第一个字母大写。 ex:int iMyAge; “i”是int类型的缩写；char cMyName[10]; “c”是char类型的缩写；float fManHeight; “f”是float类型的缩写； 其他：前缀类型 a b by c cb cr cx,cy dw fn h i l lp m_ n np p s sz w （一一对应关系）数组 (Array) 布尔值 (Boolean) 字节 (Byte) 有符号字符 (Char) 无符号字符 (Char Byte，没有多少人用) 颜色参考值 (ColorRef) 坐标差（长度 ShortInt） Double Word 函数 Handle（句柄） 整型 长整型 (Long Int) Long Pointer 类的成员 短整型 (Short Int) Near Pointer Pointer 字符串型 以 null 做结尾的字符串型 (String with Zero End) Word 驼峰式命名法：又叫小驼峰式命名法。第一个单词首字母小写，后面其他单词首字母大写。 ex:int myAge;char myName[10];float manHeight; 帕斯卡命名法：又叫大驼峰式命名法。每个单词的第一个字母都大写。 ex:int MyAge;char MyName[10];float ManHeight; 其他的命名规范如：下划线命名法，但是不是太常用，个人感觉可能是因为下划线位置太偏的事，不方便大量使用。综合各方面考虑，驼峰式命名法比较好，优势明显，事实上，目前使用驼峰式命名法的人也真的越来越多了。 下一章数据库模式对象 转载地址 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>命名法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十一]]></title>
    <url>%2F2017%2F12%2F06%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十一章，主要是用来复习和巩固在课堂学习的知识！ 笔记一、分区表在某些场合会使用非常大的表，比如人口信息统计表。如果一个表很大，就会降低查询的速度，并增加管理的难度。一旦发生磁盘损坏，可能整个表的数据就会丢失，恢复比较困难。根据这一情况，可以创建分区表，把一个大表分成几个区(小段)，对数据的操作和管理都可以针对分区进行，这样就可以提高数据库的运行效率。分区可以存在于不同的表空间上，提高了数据的可用性。例：创建和使用分区表。 创建按成绩分区的考生表，共分为3个区： 12345678910111213141516171819202122CREATE TABLE 考生 ( 考号 VARCHAR2(5),姓名 VARCHAR2(30),成绩 NUMBER(3))PARTITION BY RANGE(成绩) (PARTITION A VALUES LESS THAN (300)TABLESPACE USERS,PARTITION B VALUES LESS THAN (500)TABLESPACE USERS,PARTITION C VALUES LESS THAN (MAXVALUE)TABLESPACE USERS);步骤3：检查A区中的考生：SELECT * FROM 考生 PARTITION(A);步骤4：检查全部的考生：SELECT * FROM 考生; 视图视图的概念视图不同于表，视图本身不包含任何数据。而视图只是一种定义，对应一个查询语句。视图的数据都来自于某些表，这些表被称为基表。 视图可以在表能够使用的任何地方使用，但在对视图的操作上同表相比有些限制，特别是插入和修改操作。对视图的操作将传递到基表，所以在表上定义的约束条件和触发器在视图上将同样起作用。 视图的创建 格式： 123create [or replace] view 视图名 asselect 语句; 例：创建图书作者视图：12CREATE VIEW 图书作者(书名,作者) AS SELECT 图书名称,作者 FROM 图书; 查询视图全部内容1SELECT * FROM 图书作者; 查询部分视图：1SELECT 作者 FROM 图书作者; 删除视图：1DROP VIEW 清华图书; 创建只读视图创建只读视图要用WITH READ ONLY选项。 例：创建emp表的经理视图：123CREATE OR REPLACE VIEW manager AS SELECT * FROM emp WHERE job= 'MANAGER'WITH READ ONLY; 使用WITH CHECK OPTION选项使用WITH CHECK OPTION选项。 使用该选项，可以对视图的插入或更新进行限制，即该数据必须满足视图定义中的子查询中的WHERE条件，否则不允许插入或更新。例：123CREATE OR REPLACE VIEW 清华图书 AS SELECT * FROM 图书 WHERE 出版社编号= '01' WITH CHECK OPTION;注：插入数据时，由于带了with check option的选项，则只能插入出版社编为'01'的数据 来自基表的限制除了以上的限制，基表本身的限制和约束也必须要考虑。如果生成子查询的语句是一个分组查询，或查询中出现计算列，这时显然不能对表进行插入。另外，主键和NOT NULL列如果没有出现在视图的子查询中，也不能对视图进行插入。在视图中插入的数据，也必须满足基表的约束条件。 视图的查看 字典 说明 USER_VIEWS 字典中包含了视图的定义。 USER_UPDATABLE_COLUMNS 字典包含了哪些列可以更新、插入、删除。 USER_OBJECTS 字典中包含了用户的对象。 可以通过DESCRIBE命令查看字典的其他列信息。 例：查看用户拥有的视图：1SELECT object_name FROM user_objects WHERE object_type='VIEW'; 表和视图 图书表 出版社表 【训练1】 创建图书和出版社表。 步骤1：创建出版社表，输入并执行以下命令：123456789101112131415161718192021222324CREATE TABLE 出版社(编号 VARCHAR2(2),出版社名称 VARCHAR2(30),地址 VARCHAR2(30),联系电话 VARCHAR2(20));步骤2：创建图书表，输入并执行以下命令：CREATE TABLE 图书(图书编号 VARCHAR2(5),图书名称 VARCHAR2(30),出版社编号 VARCHAR2(2),作者 VARCHAR2(10),出版日期 DATE,数量 NUMBER(3),单价 NUMBER(7,2));步骤3：使用DESCRIBE显示图书表的结构，输入并执行以下命令：DESCRIBE 图书 通过子查询创建表【训练2】 通过子查询创建新的图书表。 步骤1：完全复制图书表到“图书1”，输入并执行以下命令：123456789CREATE TABLE 图书1 AS SELECT * FROM 图书;步骤2：创建新的图书表“图书2”，只包含书名和单价，输入并执行以下命令：CREATE TABLE 图书2(书名,单价) AS SELECT 图书名称,单价 FROM 图书;步骤3：创建新的图书表“图书3”，只包含书名和单价，不复制内容，输入并执行以下命令：CREATE TABLE 图书3(书名,单价) AS SELECT 图书名称,单价 FROM 图书 WHERE 1=2; 设置列的默认值可以在创建表的同时指定列的默认值，默认值由DEFAULT部分说明。 【训练3】 创建表时设置默认值。 步骤1：创建表时，设置表的默认值。12345678910111213141516171819CREATE TABLE 图书4(图书编号 VARCHAR2(5) DEFAULT NULL,图书名称 VARCHAR2(30) DEFAULT '未知',出版社编号 VARCHAR2(2) DEFAULT NULL,出版日期 DATE DEFAULT '01-1月-1900',作者 VARCHAR2(10) DEFAULT NULL,数量 NUMBER(3) DEFAULT 0,单价 NUMBER(7,2) DEFAULT NULL,借出数量 NUMBER(3) DEFAULT 0);步骤2：插入数据。INSERT INTO 图书4(图书编号) VALUES('A0001');步骤2：查询插入结果。SELECT * FROM 图书4; 【练习1】创建图书出借信息表，设置适当的默认值，并插入数据。 结构如下： 名称 是否为空? 类型 图书编号 not null VARCHAR2(10) 借书人 not null VARCHAR2(10) 借书日期 not null DATE 归还日期 not null DATE 删除已创建的表表的删除者必须是表的创建者或具有DROP ANY TABLE权限。 【训练4】 删除“图书1”表。 DROP TABLE 图书1;执行结果：表已丢弃。 表的操作 表的重命名 只有表的拥有者，才能修改表名。 清空表 清空表的语法为：1TRUNCATE TABLE 表名； 清空表可删除表的全部数据并释放占用的存储空间。 查看表 可以通过对数据字典USER_OBJECTS的查询，显示当前模式用户的所有表。 【训练1】 显示当前用户的所有表。1SELECT object_name FROM user_objects WHERE object_type='TABLE'; 数据完整性约束 在创建表和修改表时，可通过定义约束条件来保证数据的完整性和一致性。约束条件是一些规则，在对数据进行插入、删除和修改时要对这些规则进行验证，从而起到约束作用。 完整性包括数据完整性和参照完整性，数据完整性定义表数据的约束条件，参照完整性定义数据之间的约束条件。数据完整性由主键(PRIMARY KEY)、非空(NOT NULL)、惟一(UNIQUE)和检查(CHECK)约束条件定义参照完整性由外键(FOREIGN KEY)约束条件定义。在表的创建过程中，应该先创建主表，后创建子表。 约束条件的创建 【训练1】 创建带有约束条件的出版社表(如果已经存在，先删除)：123456CREATE TABLE 出版社(编号 VARCHAR2(2) CONSTRAINT PK_1 PRIMARY KEY,出版社名称 VARCHAR2(30) NOT NULL ,地址 VARCHAR2(30) DEFAULT '未知',联系电话 VARCHAR2(20)); 【训练2】 创建带有约束条件(包括外键)的图书表(如果已经存在，先删除)：12345678910CREATE TABLE 图书(图书编号 VARCHAR2(5) CONSTRAINT PK_2 PRIMARY KEY,图书名称 VARCHAR2(30) NOT NULL,出版社编号 VARCHAR2(2) CHECK(LENGTH(出版社编号)=2) NOT NULL,作者 VARCHAR2(10) DEFAULT '未知',出版日期 DATE DEFAULT '01-1月-1900',数量 NUMBER(3) DEFAULT 1 CHECK(数量&gt;0),单价 NUMBER(7,2),CONSTRAINT YS_1 UNIQUE(图书名称,作者),CONSTRAINT FK_1 FOREIGN KEY(出版社编号) REFERENCES 出版社(编号) ON DELETE CASCADE); 说明：因为两个表同属于一个用户，故约束名不能相重，图书表的主键为“图书编号”列，主键名为PK_2。其中，约束条件CHECK(LENGTH(出版社编号)=2)表示出版社编号的长度必须是2，约束条件UNIQUE(图书名称,作者)表示“图书名称”和“作者”两列的内容组合必须惟一。FOREIGN KEY(出版社编号) REFERENCES 出版社(编号) 表示图书表的“出版社编号”列参照出版社的“编号”主键列。出版社表为主表，图书表为子表，出版社表必须先创建。ON DELETE CASCADE表示当删除出版社表的记录时，图书表中的相关记录同时删除，比如删除清华大学出版社，则图书表中清华大学出版社的图书也会被删除。 如果同时出现DEFAULT和CHECK，则DEFAULT需要出现在CHECK约束条件之前。 【训练3】插入数据，验证约束条件。12345678910111213141516171819202122232425262728293031323334353637383940步骤1：插入出版社信息：INSERT INTO 出版社 VALUES('01','清华大学出版社','北京','010-83456272');继续插入INSERT INTO 出版社 VALUES('01','电子科技大学出版社','西安','029-88201467');重新执行：INSERT INTO 出版社 VALUES('02','电子科技大学出版社','西安','029-88201467');步骤2：插入图书信息：INSERT INTO 图书(图书编号,图书名称,出版社编号,作者,单价) VALUES('A0001','计算机原理','01','刘勇',25.30);继续插入：INSERT INTO 图书(图书编号，图书名称，出版社编号，作者，单价) VALUES('A0002',' C语言程序设计','03','马丽', 18.75);INSERT INTO 图书(图书编号，图书名称，出版社编号，作者，单价) VALUES(‘A0002’,‘ C语言程序设计’,‘02’,‘马丽’, 18.75);继续插入：INSERT INTO 图书(图书编号,图书名称,出版社编号,作者,数量,单价) VALUES('A0003','汇编语言程序设计','02','黄海明',0,20.18);重新执行：INSERT INTO 图书(图书编号,图书名称,出版社编号,作者,数量,单价) VALUES('A0003','汇编语言程序设计','02','黄海明',15,20.18); 步骤3：显示插入结果：SELECT * FROM 出版社;继续查询：SELECT * FROM 图书;步骤4：提交插入的数据：COMMIT; 说明：在图书表中，没有插入的数量取默认值1，没有插入的出版日期取默认值01-1月-00(即1900年1月1日)。 【训练4】 通过删除数据验证ON DELETE CASCADE的作用。1234567891011121314151617步骤1：删除出版社01(清华大学)：DELETE FROM 出版社 WHERE 编号='01';步骤2：显示删除结果：显示出版社表结果：SELECT * FROM 出版社;显示图书表结果：SELECT * FROM 图书;步骤3：恢复删除:ROLLBACK； 查看约束条件 数据字典USER_CONSTRAINTS中包含了当前模式用户的约束条件信息。其中，CONSTRAINTS_TYPE 显示的约束类型为： C：CHECK约束。P：PRIMARY KEY约束。U：UNIQUE约束。R：FOREIGN KEY约束。 其他信息可根据需要进行查询显示，可用DESCRIBE命令查看USER_CONSTRAINTS的结构。 【训练1】 检查表的约束信息：12SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCH_CONDITION FROM USER_CONSTRAINTSWHERE TABLE_NAME='图书'; 修改表结构 增加新列 【训练1】 为“出版社”增加一列“电子邮件”：12ALTER TABLE 出版社ADD 电子邮件 VARCHAR2(30) CHECK(电子邮件 LIKE '%@%'); 修改列 修改列定义有以下一些特点： (1) 列的宽度可以增加或减小，在表的列没有数据或数据为NULL时才能减小宽度。(2) 在表的列没有数据或数据为NULL时才能改变数据类型，CHAR和VARCHAR2之间可以随意转换。(3) 只有当列的值非空时，才能增加约束条件NOT NULL。(4) 修改列的默认值，只影响以后插入的数据。 【训练1】 修改“出版社”表“电子邮件”列的宽度为40。12ALTER TABLE 出版社MODIFY 电子邮件 VARCHAR2(40); 删除列 【训练1】删除“出版社”表的“电子邮件”列。12ALTER TABLE 出版社DROP COLUMN 电子邮件; 【训练2】 将“图书”表的“出版日期”列置成UNUSED，并查看。1234567891011步骤1：设置“出版日期”列为UNUSED：ALTER TABLE 图书 SET UNUSED COLUMN 出版日期;步骤2：显示结构：DESC 图书;步骤3：删除UNUSED列：ALTER TABLE 图书 DROP UNUSED COLUMNS; 约束条件的修改 可以为表增加或删除表级约束条件。 增加约束条件 【训练1】 为emp表的mgr列增加外键约束： 1ALTER TABLE emp ADD CONSTRAINT FK_3 FOREIGN KEY(mgr) REFERENCES emp(empno); 删除约束条件 【训练2】 删除为emp表的mgr列增加的外键约束： 1ALTER TABLE emp DROP CONSTRAINT FK_3; 视图创建和操作 视图的概念 视图不同于表，视图本身不包含任何数据。而视图只是一种定义，对应一个查询语句。视图的数据都来自于某些表，这些表被称为基表。 视图可以在表能够使用的任何地方使用，但在对视图的操作上同表相比有些限制，特别是插入和修改操作。对视图的操作将传递到基表，所以在表上定义的约束条件和触发器在视图上将同样起作用。 视图的创建 创建简单视图 【训练1】 创建图书作者视图。12345678910111213141516步骤1：创建图书作者视图：CREATE VIEW 图书作者(书名,作者) AS SELECT 图书名称,作者 FROM 图书;步骤2：查询视图全部内容SELECT * FROM 图书作者;步骤3：查询部分视图：SELECT 作者 FROM 图书作者;步骤4：删除视图：DROP VIEW 清华图书; 创建复杂视图 【训练3】 修改作者视图，加入出版社名称。123456789步骤1：重建图书作者视图：CREATE OR REPLACE VIEW 图书作者(书名,作者,出版社) AS SELECT 图书名称,作者,出版社名称 FROM 图书,出版社 WHERE 图书.出版社编号=出版社.编号;步骤2：查询新视图内容：SELECT * FROM 图书作者; 【训练4】 创建一个统计视图。123456789步骤1：创建emp表的一个统计视图：CREATE VIEW 统计表(部门名,最大工资,最小工资,平均工资)AS SELECT DNAME,MAX(SAL),MIN(SAL),AVG(SAL) FROM EMP E,DEPT DWHERE E.DEPTNO=D.DEPTNO GROUP BY DNAME; 步骤2：查询统计表：SELECT * FROM 统计表; 创建只读视图 创建只读视图要用WITH READ ONLY选项。 【训练5】 创建只读视图。123456789步骤1：创建emp表的经理视图：CREATE OR REPLACE VIEW manager AS SELECT * FROM emp WHERE job= 'MANAGER'WITH READ ONLY;步骤2：进行删除：DELETE FROM manager; 视图的操作 对视图经常进行的操作是查询操作，但也可以在一定条件下对视图进行插入、删除和修改操作。对视图的这些操作最终传递到基表。但是对视图的操作有很多限定。如果视图设置了只读，则对视图只能进行查询，不能进行修改操作。 视图的插入 【训练1】 视图插入练习。 步骤1：创建清华大学出版社的图书视图：1234567891011121314CREATE OR REPLACE VIEW 清华图书 AS SELECT * FROM 图书 WHERE 出版社编号= '01';步骤2：插入新图书：INSERT INTO 清华图书 VALUES('A0005','软件工程','01','冯娟',5,27.3);步骤3：显示视图：SELECT * FROM 清华图书;步骤4：显示基表SELECT * FROM 图书; 问题:如果在“清华图书”的视图中插入其他出版社的图书，结果会怎么样呢？ 结果是允许插入，但是在视图中看不见，在基表中可以看见，这显然是不合理的。 使用WITH CHECK OPTION选项 为了避免上述情况的发生，可以使用WITH CHECK OPTION选项。使用该选项，可以对视图的插入或更新进行限制，即该数据必须满足视图定义中的子查询中的WHERE条件，否则不允许插入或更新。 【训练2】 使用WITH CHECK OPTION选项限制视图的插入。 步骤1：重建清华大学出版社的图书视图，带WITH CHECK OPTION选项：1234567CREATE OR REPLACE VIEW 清华图书 AS SELECT * FROM 图书 WHERE 出版社编号= '01'WITH CHECK OPTION;步骤2：插入新图书：INSERT INTO 清华图书 VALUES('A0006','Oracle数据库','02','黄河',3,39.8); 来自基表的限制 除了以上的限制，基表本身的限制和约束也必须要考虑。如果生成子查询的语句是一个分组查询，或查询中出现计算列，这时显然不能对表进行插入。另外，主键和NOT NULL列如果没有出现在视图的子查询中，也不能对视图进行插入。在视图中插入的数据，也必须满足基表的约束条件。 【训练3】基表本身限制视图的插入。12345678步骤1：重建图书价格视图：CREATE OR REPLACE VIEW 图书价格 AS SELECT 图书名称,单价 FROM 图书;步骤2：插入新图书：INSERT INTO 图书价格 VALUES('Oracle数据库',39.8); 视图的查看 USER_VIEWS字典中包含了视图的定义。USER_UPDATABLE_COLUMNS字典包含了哪些列可以更新、插入、删除。USER_OBJECTS字典中包含了用户的对象。 可以通过DESCRIBE命令查看字典的其他列信息。在这里给出一个训练例子。 【训练1】 查看清华图书视图的定义：1SELECT TEXT FROM USER_VIEWS WHERE VIEW_NAME='清华图书'; 【训练2】 查看用户拥有的视图：1SELECT object_name FROM user_objects WHERE object_type='VIEW'; 阶段训练【训练1】 创建学生、系部、课程和成绩表，根据需要设置默认值、约束条件、主键和外键。`sql步骤1：创建系部表，编号为主键，系部名称非空，电话号码惟一： CREATE TABLE 系部(编号 NUMBER(5) PRIMARY KEY,系部名 VARCHAR2(20) NOT NULL,地址 VARCHAR2(30),电话 VARCHAR2(15) UNIQUE,系主任 VARCHAR2(10)); 步骤2：创建学生表，学号为主键，姓名非空，性别只能是男或女，电子邮件包含@并且惟一，系部编号参照系部表的编号： CREATE TABLE 学生 (学号 VARCHAR2(10) PRIMARY KEY,姓名 VARCHAR2(10) NOT NULL,性别 VARCHAR2(2) CHECK(性别=’男’ OR 性别=’女’),生日 DATE,住址 VARCHAR2(30),电子邮件 VARCHAR2(20) CHECK(电子邮件 LIKE ‘%@%’) UNIQUE,系部编号 NUMBER(5),CONSTRAINT FK_XBBH FOREIGN KEY(系部编号) REFERENCES 系部(编号)); 步骤3：创建课程表，编号为主键，课程名非空，学分为1到5： CREATE TABLE 课程(编号 NUMBER(5) PRIMARY KEY,课程名 VARCHAR2(30) NOT NULL,学分 NUMBER(1) CHECK(学分&gt;0 AND 学分&lt;=5)); 步骤4：创建成绩表，学号和课程编号为主键，学号参照学生表的学号，课程编号参照课程表的编号： CREATE TABLE 成绩(学号 VARCHAR2(10),课程编号 NUMBER(5),成绩 NUMBER (3),CONSTRAINT PK PRIMARY KEY(学号,课程编号),CONSTRAINT FK_XH FOREIGN KEY(学号) REFERENCES 学生(学号),CONSTRAINT FK_KCBH FOREIGN KEY(课程编号) REFERENCES 课程(编号));`sql 说明：注意表之间的主从关系，对于系部和学生表，系部表为主表，学生表为子表。学生表的外键表示插入学生的系部编号必须是系部表的编号。对于成绩表，主键是学号和课程编号，表示如果学号相同课程编号必须不同，这样就可以惟一地标识记录。课程表有两个外键，分别参照学生表和课程表，表示成绩表的学号必须是学生表的学号，成绩表的课程编号必须是课程表的编号。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习十]]></title>
    <url>%2F2017%2F12%2F05%2Foracle%E5%AD%A6%E4%B9%A0%E5%8D%81%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第十章，主要是用来复习和巩固在课堂学习的知识！ 笔记 建表 123456格式：create table 表名(列名1 类型 约束,列名2 类型 约束,...... ); 如：步骤1：创建出版社表，输入并执行以下命令： 123456CREATE TABLE 出版社(编号 VARCHAR2(2),出版社名称 VARCHAR2(30),地址 VARCHAR2(30),联系电话 VARCHAR2(20)); 123456789CREATE TABLE 图书(图书编号 VARCHAR2(5),图书名称 VARCHAR2(30),出版社编号 VARCHAR2(2),作者 VARCHAR2(10), 出版日期 DATE, 数量 NUMBER(3), 单价 NUMBER(7,2) ); 通过子查询建表 步骤1：完全复制图书表到“图书1”，输入并执行以下命令：1CREATE TABLE 图书1 AS SELECT * FROM 图书; 步骤2：创建新的图书表“图书2”，只包含书名和单价，输入并执行以下命令： 1CREATE TABLE 图书2(书名,单价) AS SELECT 图书名称,单价 FROM 图书; 步骤3：创建新的图书表“图书3”，只包含书名和单价，不复制内容，输入并执行以下命令：1CREATE TABLE 图书3(书名,单价) AS SELECT 图书名称,单价 FROM 图书 WHERE 1=2; 添加表的约束 约束 关键字 简写 主键 primary key PK 唯一 unique UQ 默认值 default DF 检查约束 check CK 外键约束 foreign key FK 方法一：建表的同时添加约束 123456789create table stuinfo(sno int primary key not null, --主键sname varchar2(10) unique not null, --唯一sex char(2) default '男' check(sex='男' or sex = '女') not null, --默认及检查saddress varchar2(50) not null,phone char(11),email varchar2(50)); 1234567create table stumarks(marksId int,sno int references stuinfo(sno) not null, --外键score number(5,1),examDate date default sysdate); 方法二:建表完成后，再添加约束 （之前已建好了出版社表及图书表） 123456789101112131415161718--主键约束alter table 出版社 add constraint PK_编号primary key (编号);--唯一约束alter table 出版社 add constraint UQ_地址unique (地址);--检查约束alter table 出版社 add constraint CK_联系电话check (联系电话 like '1%');--默认值alter table 出版社 modify 地址 default '湘潭';--外键约束alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号)--外键约束alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号) 查看约束条件 数据字典USER_CONSTRAINTS中包含了当前模式用户的约束条件信息。其中，CONSTRAINTS_TYPE 显示的约束类型为： C：CHECK约束。 P：PRIMARY KEY约束。 U：UNIQUE约束。 R：FOREIGN KEY约束。 其他信息可根据需要进行查询显示，可用DESCRIBE命令查看USER_CONSTRAINTS的结构。 如:检查表的约束信息：12SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCH_CONDITION FROM USER_CONSTRAINTSWHERE TABLE_NAME='图书'; 删除约束条件 1ALTER TABLE 表名 DROP CONSTRAINT 约束名; 表的操作 1、删除表 drop table 表名2、重命名表 RENAME 表名 TO 新表名;3、查看表 可以通过对数据字典USER_OBJECTS的查询，显示当前模式用户的所有表。 如： 显示当前用户的所有表。1SELECT object_name FROM user_objects WHERE object_type='TABLE'; 修改表1、增加新列:如： 为“出版社”增加一列“电子邮件”： 12ALTER TABLE 出版社ADD 电子邮件 VARCHAR2(30) CHECK(电子邮件 LIKE '%@%'); 2、修改列 修改列定义有以下一些特点：(1) 列的宽度可以增加或减小，在表的列没有数据或数据为NULL时才能减小宽度。(2) 在表的列没有数据或数据为NULL时才能改变数据类型，CHAR和VARCHAR2之间可以随意转换。(3) 只有当列的值非空时，才能增加约束条件NOT NULL。(4) 修改列的默认值，只影响以后插入的数据。如：修改“出版社”表“电子邮件”列的宽度为40。1ALTER TABLE 出版社 MODIFY 电子邮件 VARCHAR2(40); 3、删除列如：删除“出版社”表的“电子邮件”列。12ALTER TABLE 出版社DROP COLUMN 电子邮件; 数据操作插入数据【训练1】 表的部分字段插入练习。步骤1：将新雇员插入到emp表：12INSERT INTO emp(empno,ename,job)VALUES (1000, '小李', 'CLERK'); 步骤2：显示插入结果1SELECT * FROM emp WHERE empno=1000; 日期类型的字段值也要用单引号括起来，如’10-1月-03’。日期型的数据默认格式为DD-MON-YY，默认的世纪为当前的世纪，默认的时间为午夜12点。如果指定的世纪不是本世纪或时间不是午夜12点，则必须使用TO_DATE系统函数对字符串进行转换。 【训练2】 时间字段的插入练习。 步骤1：将新雇员插入到emp表：12INSERT INTO emp(empno,ename,job,hiredate)VALUES (1001, '小马', 'CLERK', '10-1月-03'); 【训练3】 表的全部字段的插入练习。 执行以下的查询：1INSERT INTO dept VALUES (50, '培训部','深圳'); 【训练4】 插入空值练习。 执行以下的查询：1INSERT INTO emp(empno,ename,job,sal) VALUES(1005,'杨华', 'CLERK',null); 复制数据:该形式一次可以插入多行数据。【训练5】 通过其他表插入数据的练习。 步骤1：创建一个新表manager：1CREATE TABLE manager AS SELECT empno,ename,sal FROM emp WHERE job='MANAGER'; 步骤2：从emp表拷贝数据到manager： 1234INSERT INTO managerSELECT empno, ename, salFROM empWHERE job = 'CLERK'; ## 修改数据 【训练1】 修改小李(编号为1000)的工资为3000。执行以下的查询：123UPDATE empSET sal = 3000WHERE empno = 1000; 【训练2】 将小李(编号为1000)的雇佣日期改成当前系统日期，部门编号改为50。 执行以下的查询：123UPDATE empSET hiredate=sysdate, deptno=50WHERE empno = 1000; 【训练3】 为所有雇员增加100元工资。执行以下的查询：12UPDATE empSET sal =sal+100; 【训练4】 根据其他表修改数据。 执行以下的查询：123UPDATE managerSET (ename, sal) =(SELECT ename,sal FROM emp WHERE empno = 7788)WHERE empno = 1000; ## 删除数据【训练1】 删除雇员编号为1000的新插入的雇员。 步骤1：删除编号为1000的雇员：1DELETE FROM emp WHERE empno=1000; 步骤2：显示删除结果：1SELECT * FROM emp WHERE empno=1000; 【训练2】 彻底删除manager表的内容。 执行以下的命令：1TRUNCATE TABLE manager; DELETE命令进行的删除可以撤销，但TRUNCATE命令进行的删除不可撤销。 注意：TRUNCATE TABLE命令用来删除表的全部数据而不是删除表，表依旧存在。 数据库事务数据库事务的概念两次连续成功的COMMIT或ROLLBACK之间的操作，称为一个事务。在一个事务内，数据的修改一起提交或撤销，如果发生故障或系统错误，整个事务也会自动撤销。 比如，我们去银行转账，操作可以分为下面两个环节：(1) 从第一个账户划出款项。(2) 将款项存入第二个账户。 在这个过程中，两个环节是关联的。第一个账户划出款项必须保证正确的存入第二个账户，如果第二个环节没有完成，整个的过程都应该取消，否则就会发生丢失款项的问题。 整个交易过程，可以看作是一个事物，成功则全部成功，失败则需要全部撤消，这样可以避免当操作的中间环节出现问题时，产生数据不一致的问题。 数据库事务的应用数据库事务处理可分为隐式和显式两种。显式事务操作通过命令实现，隐式事务由系统自动完成提交或撤销(回退)工作，无需用户的干预。 隐式提交的情况包括：当用户正常退出SQL*Plus或执行CREATE、DROP、GRANT、REVOKE等命令时会发生事务的自动提交。 系统的环境变量AUTOCOMMIT设置为ON(默认状态为OFF) SET AUTOCOMMIT ON/OFF 隐式回退的情况包括：当异常结束SQL*Plus或系统故障发生时，会发生事务的自动回退。 【训练1】 学习使用COMMIT和ROLLBACK。123456789101112131415--步骤1：执行以下命令，提交尚未提交的操作：COMMIT;--步骤2：修改雇员SCOTT的工资：UPDATE emp SET sal=sal+100 WHERE empno=7788;SELECT ename,sal FROM emp WHERE empno=7788;--步骤3：假定修改操作后发现增加的工资应该为1000而不是100，为了取消刚做的操作，可以执行以下命令：ROLLBACK;--显示回退后SCOTT的工资恢复为3000：SELECT ename,sal FROM emp WHERE empno=7788;--步骤4：重新修改雇员SCOTT的工资，工资在原有基础上增加1000：UPDATE emp SET sal=sal+1000 WHERE empno=7788;--显示修改后SCOTT的工资：SELECT ename,sal FROM emp WHERE empno=7788;--步骤5：经查看修改结果正确，提交所做的修改：COMMIT; 注意：在事务执行过程中，随时可以预览数据的变化。对于比较大的事务，可以使用SAVEPOINT命令在事务中间划分一些断点，用来作为回退点。 【训练2】 学习使用SAVEPOINT命令。123456789101112131415161718192021222324252627--步骤1：插入一个雇员：INSERT INTO emp(empno, ename, job)VALUES (3000, '小马','STUDENT');--步骤2：插入保存点，检查点的名称为PA：SAVEPOINT pa;--步骤3：插入另一个雇员：INSERT INTO emp(empno, ename, job)VALUES (3001, '小黄','STUDENT');--步骤4：回退到保存点PA，则后插入的小黄被取消，而小马仍然保留。ROLLBACK TO pa;--步骤5: 提交所做的修改：COMMIT;```sql【训练3】 观察数据的读一致性。--步骤1：显示刚插入的雇员小马:SELECT empno,ename FROM emp WHERE empno=3000;--步骤2：删除雇员小马:DELETE FROM emp WHERE empno=3000;--步骤3：再次显示该雇员，显示结果为该雇员不存在：SELECT empno,ename FROM emp WHERE empno=3000;--步骤4：另外启动第2个SQL*Plus，并以SCOTT身份连接。执行以下命令，结果为该记录依旧存在。SELECT empno,ename FROM emp WHERE empno=3000;--步骤5：在第1个SQL*Plus中提交删除：COMMIT;--步骤6：在第2个SQL*Plus中再次显示该雇员，显示结果与步骤3的结果一致:SELECT empno,ename FROM emp WHERE empno=3000; 说明：在以上训练中，当第1个SQLPlus会话删除小马后，第2个SQLPlus会话仍然可以看到该雇员，直到第1个SQL*Plus会话提交该删除操作后，两个会话看到的才是一致的数据。 表的锁定【了解】锁的概念锁出现在数据共享的场合，用来保证数据的一致性。当多个会话同时修改一个表时，需要对数据进行相应的锁定。锁有“只读锁”、“排它锁”，“共享排它锁”等多种类型，而且每种类型又有“行级锁”(一次锁住一条记录)，“页级锁”(一次锁住一页，即数据库中存储记录的最小可分配单元)，“表级锁”(锁住整个表)。 若为“行级排它锁”，则除被锁住的行外，该表中其他行均可被其他的用户进行修改(Update)或删除(delete)。若为“表级排它锁”，则所有其他用户只能对该表进行查询(select)操作，而无法对其中的任何记录进行修改或删除。当程序对所做的修改进行提交(commit)或回滚(rollback)后，锁住的资源便会得到释放，从而允许其他用户进行操作。 如果两个事务，分别锁定一部分数据，而都在等待对方释放锁才能完成事务操作，这种情况下就会发生死锁。 隐式锁和显式锁在Oracle数据库中，修改数据操作时需要一个隐式的独占锁，以锁定修改的行，直到修改被提交或撤销为止。如果一个会话锁定了数据，那么第二个会话要想对数据进行修改，只能等到第一个会话对修改使用COMMIT命令进行提交或使用ROLLBACK命令进行回滚撤销后，才开始执行。因此应养成一个良好的习惯：执行修改操作后，要尽早地提交或撤销，以免影响其他会话对数据的修改。 【训练1】 对emp表的SCOTT雇员记录进行修改，测试隐式锁。123456789101112131415步骤1：启动第一个SQL*Plus，以SCOTT账户登录数据库(第一个会话)，修改SCOTT记录，隐式加锁。UPDATE emp SET sal=3500 where empno=7788;步骤2：启动第二个SQL*Plus，以SCOTT账户登录数据库(第二个会话)，进行记录修改操作。UPDATE emp SET sal=4000 where empno=7788;步骤3：对第一个会话进行解锁操作：COMMIT;步骤4：查看第二个会话，此时有输出结果：步骤5：提交第二个会话，防止长时间锁定。 表的显式锁定 锁定行【训练1】 对emp表的部门10的雇员记录加显式锁，并测试。12345678910111213步骤1：对部门10加显式锁：SELECT empno,ename,job,sal FROM emp WHERE deptno=10 FOR UPDATE;步骤2：启动第二个SQL*Plus(第二个会话)，以SCOTT账户登录数据库，对部门10的雇员CLARK进行修改操作。UPDATE emp SET sal=sal+100 where empno=7782;步骤3：在第一个会话进行解锁操作：COMMIT;步骤4：查看第二个会话，有输出结果： 锁定表LOCK语句用于对整张表进行锁定。对表的锁定可以是共享(SHARE)或独占(EXCLUSIVE)模式。共享模式下，其他会话可以加共享锁，但不能加独占锁。在独占模式下，其他会话不能加共享或独占锁。 【训练1】 对emp表添加独占锁。1234567步骤1：对emp表加独占锁：LOCK TABLE emp IN EXCLUSIVE MODE;步骤2：对表进行解锁操作：COMMIT;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse主题设置]]></title>
    <url>%2F2017%2F12%2F05%2Feclipse%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一个主题，一个心情！ 准备 我们先从主题官网下载一个主题！ 主题官网 点击图中【Eclipse Preferences(EPF)-for Eclipse import】的下载！ 下载下来的文件格式为 【 .epf 】 导入主题 打开eclipse,点击【 File 】中的【 import 】 进入【 import 】中的 【 General 】中的 【 Preferences 】 点击打开【 Preferences 】点击 【 Browse.. 】选择 格式为[ .epf ] 主题的路径 完成 点击 【 Finish 】完成设置 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天正cad安装教程]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%A4%A9%E6%AD%A3cad%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[此章是关于天正建筑2014和autoCAD 2014的安装教程！ 准备 使用以下的链接下载所需的文件 链接：https://pan.baidu.com/s/1skIYTJJ 密码：fahq 如下图目录： 我们要先清楚正建筑2014和autoCAD 2014的关系，正建筑2014只一个辅助autoCAD 2014 的工具，所以安装顺序是先 autoCAD 2014 后 正建筑2014。 如果你先安装了正建筑2014，运行正建筑2014就会出现以下情况： ##安装autoCAD 2014 现在让我们直接进入正题，安装autoCAD 2014 让我们找到autoCAD 2014文件，在以下目录中点击auto cad 2017 32_64目录中。 选中AutoCAD_2014_Simplified_Chinese_Wi…(注意这里有两个文件其中第一个是32位，第二是64位的)，安自己的机型选择，双击。 出现以下界面：选择解压的路径 解压成功之后，出现以下界面：选择安装 之后选择：我接受 ，点击 下一步 之后按照图中的 序列号 666-69696969 001f1 输入，点击 下一步 之后，选择自己想安装的路径，点击安装 接下来就是耐心等待就好，有点小久哦！ 出现以下界面就说明 autoCAD 2014 安装完成了！ 激活autoCAD 2014 autoCAD 2014 虽然已成为安装了，但并没有激活！ 成功安装的 autoCAD 2014 后，会在桌面上出以下三个东东！ 让我们点击第一个图标 AutoCAD 2014 进入以下界面： 之后出现 ，点击试用 你会看到 接下我们如图操作点击： 出现如下界面：点击右上角的 产品信息 之后出现：点击激活 你会看到：如下提示”很抱歉，您输入的序列号是无效的。该序列号或不是欧特克产品的序列号，又或许它已经被他人使用“ 这时我们再点右下角的 关闭 我们又回到了以下界面：我们点击激活 出现以下界面：选择 ”立即连接并激活“ 点击 下一步 出现以下界面： 我们选择 ”我具有 Autodesk 提供的激活码“ 并复制申请号 如图， 之后我们用acuto cad 2014 注册机得到激活码,首先进入以下目录 进入auto cad 2014 注册机目录 如图 点击符合自己机型的注册机进入，把复制的申请号粘贴在Requset后的文本框中，再点击Genderate 得到激活码并复制下粘贴到激活界面再点击Patch就行了 ：如图 之后点击激活界面的下一步，之后就会出现：如图 设置autoCAD 2014 的信任如果不进行此步骤的话，你使用天正建筑2014就出现以下情况： 第一步：如图找到 选项 第二步：进入选项找到系统再找到可执行文件设置 第三步：如图选择就行了，点击确定 安装天正建筑2014找到点击图标：如图 出现如下界面：点击 ”我接受许可证协议中的条款“，下一步 出现以下界面：点击下一步 出现以下界面：选择自己要的安装路径，点击下一步 出现以下界面：点击下一步 等待安装：如图 完成安装：点击完成 打补丁完成天正建筑2014后，点击进入后会出现以下情况 现在我们开始打补丁 第一步：选择Tarch2014过期补丁 第二步：出现以下界面，点击 补丁 第三步：点击Tarch2014x64/x32(选择一个符合自己机型的) 第四步：如图，点击是 第五步：右击天正建筑2014快捷方式，以管理员的身份运行就行了 成功 出现以下界面说明你安装成功了！ CAD Error问题一: cad安全系统 软件锁许可管理器 不起作用 解决方法： 打开c:\programData\FLEXnet【这个文件夹是隐藏的,要把隐藏属性去了】 删除文件 “FLEXnet” 中的所有文件 使用 win + r 打开快速启动窗口 –&gt; services.msc 找到服务 “FlexNet licensing service” 启动,并设置属性为自动 重启CAD 重新激活（上文有激活方法）]]></content>
      <categories>
        <category>cad</category>
      </categories>
      <tags>
        <tag>天正cad安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps快捷键集锦]]></title>
    <url>%2F2017%2F12%2F01%2Fps%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[本章主要是介绍ps中的快捷方式 工具箱 文件操作 选择功能 视图操作 编辑操作 图像调整 图层操作 工具箱(多种工具共用一个快捷键的可同时按【Shift】加此快捷键选取) 快捷键 说明 【M】 矩形、椭圆选框工具 【V】 移动工具 【L】 套索、多边形套索、磁性套索 【W】 魔棒工具 【C】 裁剪工具 【K】 切片工具、切片选择工具 【J】 喷枪工具 【B】 画笔工具、铅笔工具 【S】 像皮图章、图案图章 【Y】 历史画笔工具、艺术历史画笔 【E】 像皮擦、背景擦除、魔术像皮擦 【G】 渐变工具、油漆桶工具 【R】 模糊、锐化、涂抹工具 【O】 减淡、加深、海棉工具 【A】 路径选择工具、直接选取工具 【T】 文字工具 【P】 钢笔、自由钢笔 【U】 矩形、圆边矩形、椭圆、多边形、直线 【N】 写字板、声音注释 【I】 吸管、颜色取样器、度量工具 【H】 抓手工具 【Z】 缩放工具 【D】 默认前景色和背景色 【X】 切换前景色和背景色 【Q】 切换标准模式和快速蒙板模式 【F】 标准屏幕模式、带有菜单栏的全屏模式、全屏模式 【Ctrl】+【Shift】+【M】 跳到ImageReady3.0中 【Ctrl】 临时使用移动工具 【Alt】 临时使用吸色工具 【空格】 临时使用抓手工具 【0】至【9】 快速输入工具选项(当前工具选项面板中至少有一个可调节数字) 【[】或【]】 循环选择画笔 【Ctrl】+【N】 建立新渐变(在”渐变编辑器”中) 文件操作 快捷键 说明 【Ctrl】+【N】 新建图形文件 【Ctrl】+【Alt】+【N】 用默认设置创建新文件 【Ctrl】+【O】 打开已有的图像 【Ctrl】+【Alt】+【O】 打开为… 【Ctrl】+【W】 关闭当前图像 【Ctrl】+【S】 保存当前图像 【Ctrl】+【Shift】+【S】 另存为… 【Ctrl】+【Alt】+ 【Shift】+【S】 存储为Web所用格式 【Ctrl】+【Shift】+【P】 页面设置 【Ctrl】+【P】打印 【Ctrl】+【K】 打开“预置”对话框 选择功能 快捷键 说明 【Ctrl】+【A】 全部选取 【Ctrl】+【D】 取消选择 【Ctrl】+【Shift】+【D】 重新选择 【Shift】+【F6】 羽化选择 【Ctrl】+【Shift】+【I】 反向选择 【Enter】 路径变选区 数字键盘的 【Ctrl】+点按图层、路径、通道面板中的缩约图滤镜 载入选区 【Ctrl】+【F】 按上次的参数再做一次上次的滤镜 【Ctrl】+【Shift】+【F】 退去上次所做滤镜的效果 【Ctrl】+【Alt】+【F】 重复上次所做的滤镜(可调参数) 视图操作 快捷键 说明 【Ctrl】+【2】 显示彩色通道 【Ctrl】+【数字】 显示单色通道 【Ctrl】+【Y】 以CMYK方式预览(开关) 【Ctrl】+【+】 放大视图 【Ctrl】+【-】 缩小视图 【Ctrl】+【0】 满画布显示 【Ctrl】+【Alt】+【0】 实际象素显示 【Ctrl】+【Shift】+【L】 左对齐或顶对齐 【Ctrl】+【Shift】+【C】 中对齐 【Ctrl】+【Shift】+【R】右对齐或底对齐【Shift】+【←】/【→】|左／右选择 1 个字符【Shift】+【↑】/【↓】|下／上选择 1 行 编辑操作 快捷键 说明 【Ctrl】+【Z】 还原/重做前一步操作 【Ctrl】+【Alt】+【Z】 还原两步以上操作 【Ctrl】+【Shift】+【Z】 重做两步以上操作 【Ctrl】+【X】或【F2】 剪切选取的图像或路径 【Ctrl】+【C】 拷贝选取的图像或路径 【Ctrl】+【Shift】+【C】 合并拷贝 【Ctrl】+【V】或【F4】 将剪贴板的内容粘到当前图形中 【Ctrl】+【Shift】+【V】 将剪贴板的内容粘到选框中 【Ctrl】+【T】 自由变换 【Enter】 应用自由变换(在自由变换模式下) 【Alt】 从中心或对称点开始变换 (在自由变换模式下) 【Shift】 限制(在自由变换模式下) 【Ctrl】 扭曲(在自由变换模式下) 【Esc】 取消变形(在自由变换模式下) 【Ctrl】+【Shift】+【T】 自由变换复制的象素数据 【Ctrl】+【Shift】+【Alt】+【T】 再次变换复制的象素数据并建立一个副本 【DEL】 删除选框中的图案或选取的路径 【Ctrl】+【BackSpace】或【Ctrl】+【Del】 用背景色填充所选区域或整个图层 【Alt】+【BackSpace】或【Alt】+【Del】 用前景色填充所选区域或整个图层 【Shift】+【BackSpace】 弹出“填充”对话框 【Alt】+【Ctrl】+【Backspace】 从历史记录中填充 图像调整 快捷键 说明 【Ctrl】+【L】 调整色阶 【Ctrl】+【Shift】+【L】 自动调整色阶 【Ctrl】+【M】 打开曲线调整对话框 【Ctrl】+【B】 打开“色彩平衡”对话框 【Ctrl】+【U】 打开“色相/饱和度”对话框 【Ctrl】+【Shift】+【U】 去色 【Ctrl】+【I】 反相 图层操作 快捷键 说明 【Ctrl】+【Shift】+【N】 从对话框新建一个图层 【Ctrl】+【Alt】+【Shift】+【N】 以默认选项建立一个新的图层 【Ctrl】+【J】 通过拷贝建立一个图层 【Ctrl】+【Shift】+【J】 通过剪切建立一个图层 【Ctrl】+【G】 与前一图层编组 【Ctrl】+【Shift】+【G】 取消编组 【Ctrl】+【E】 向下合并或合并联接图层 【Ctrl】+【Shift】+【E】 合并可见图层 【Ctrl】+【Alt】+【E】 盖印或盖印联接图层 【Ctrl】+【Alt】+【Shift】+【E】 盖印可见图层 【Ctrl】+【[】 将当前层下移一层 【Ctrl】+【]】 将当前层上移一层 【Ctrl】+【Shift】+【[】 将当前层移到最下面 【Ctrl】+【Shift】+【]】 将当前层移到最上面 【Alt】+【[】 激活下一个图层 【Alt】+【]】 激活上一个图层 【Shift】+【Alt】+【[】 激活底部图层 【Shift】+【Alt】+【]】 激活顶部图层 参考 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处]]></content>
      <categories>
        <category>ps</category>
      </categories>
      <tags>
        <tag>ps快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习九]]></title>
    <url>%2F2017%2F11%2F30%2Foracle%E5%AD%A6%E4%B9%A0%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第九章，主要是用来复习和巩固在课堂学习的知识！ 笔记 增删改 123增: insert into 表名 (列名) values (值)删: delete from 表名 where 条件 (truncate table 表名:清空表)改：update 表名 set 列名1=值1,列名2=值2 。。。 where 条件 复制数据 1、通过一条查询语句创建一个新表(要求目标表不存在)1CREATE TABLE manager AS SELECT empno,ename,sal FROM emp WHERE job='MANAGER'; 2、通过一条查询语句复制数据(要求目标表必须已建好)12INSERT INTO managerSELECT empno, ename, sal FROM emp WHERE job = 'CLERK'; 序列1、创建序列 创建从2000起始，增量为1 的序列abc：12CREATE SEQUENCE abc INCREMENT BY 1 START WITH 2000 MAXVALUE 99999 CYCLE NOCACHE; 使用序列 序列名.nextval: 代表下一个值序列名.currval: 代表当前值 12INSERT INTO manager VALUES(abc.nextval,'小王',2500); 12INSERT INTO manager VALUES(abc.nextval,'小赵',2800); 事务 A.两次连续成功的COMMIT或ROLLBACK之间的操作，称为一个事务。在一个事务内，数据的修改一起提交或撤销，如果发生故障或系统错误，整个事务也会自动撤销 B.数据库事务处理可分为隐式和显式两种。显式事务操作通过命令实现，隐式事务由系统自动完成提交或撤销(回退)工作，无需用户的干预。 C.隐式提交的情况包括：当用户正常退出SQL*Plus或执行CREATE、DROP、GRANT、REVOKE等命令时会发生事务的自动提交。 显示事务: -|-COMMIT|数据库事务提交，将变化写入数据库ROLLBACK|数据库事务回退，撤销对数据的修改SAVEPOINT|创建保存点，用于事务的阶段回退]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习八]]></title>
    <url>%2F2017%2F11%2F29%2Foracle%E5%AD%A6%E4%B9%A0%E5%85%AB%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第八章，主要是用来复习和巩固在课堂学习的知识！ 笔记 子查询 A.通过把一个查询的结果作为另一个查询的一部分,子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。 B.子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。1．单行子查询 如：查询比SCOTT工资高的雇员名字和工资。执行以下查询：123SELECT ename,sal FROM empWHERE sal&gt;(SELECT sal FROM emp WHERE empno=7788); 多行子查询例如如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。 如：查询工资低于任意一个“CLERK”的工资的雇员信息。执行以下查询： 12345SELECT empno, ename, job,sal FROM empWHERE sal &lt; ANY (SELECT sal FROM emp WHERE job = &apos;CLERK&apos;)AND job &lt;&gt; &apos;CLERK&apos;; 如：查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。执行以下查询：1234SELECT empno, ename,sal FROM empWHERE sal &gt; ALL(SELECT sal FROM emp WHERE job= 'SALESMAN'); 如：查询部门20中职务同部门10的雇员一样的雇员信息。执行以下查询： 123SELECT empno, ename, job FROM emp WHERE job IN (SELECT job FROM emp WHERE deptno=10) AND deptno =20; 多列子查询 如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。 查询职务和部门与SCOTT相同的雇员的信息。 1SELECT empno, ename, sal FROM emp WHERE (job,deptno) =(SELECT job,deptno FROM emp WHERE empno=7788); 在FROM从句中使用子查询 在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法。 如：查询雇员表中排在第6～9位置上的雇员。12SELECT ename,sal FROM (SELECT rownum as num,ename,sal FROM emp WHERE rownum&lt;=9 )WHERE num&gt;=6; 集合运算 操 作 描 述 UNION 并集，合并两个操作的结果，去掉重复的部分 UNION ALL 并集，合并两个操作的结果，保留重复的部分 MINUS 差集，从前面的操作结果中去掉与后面操作结果相同的部分 INTERSECT 交集，取两个操作结果中相同的部分 如：查询部门10和部门20的所有职务。 123SELECT job FROM emp WHERE deptno=10UNIONSELECT job FROM emp WHERE deptno=20; 如：查询部门10和20中是否有相同的职务和工资。 123SELECT job,sal FROM emp WHERE deptno=10INTERSECTSELECT job,sal FROM emp WHERE deptno=20; 如：查询只在部门表中出现，但没有在雇员表中出现的部门编号。123SELECT deptno FROM dept MINUS SELECT deptno FROM emp ; 子查询例如我们可能会提出这样的问题，在雇员中谁的工资最高，或者谁的工资比SCOTT高。通过把一个查询的结果作为另一个查询的一部分，可以实现这样的查询功能。出现在其他查询中的查询称为子查询，包含其他查询的查询称为主查询。 A.子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。 B.子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。 C.子查询可以嵌套使用，最里层的查询最先执行。子查询可以在SELECT、INSERT、UPDATE、DELETE等语句中使用。 单行子查询 【训练1】 查询比SCOTT工资高的雇员名字和工资。执行以下查询：12SELECT ename,sal FROM empWHERE sal&gt;(SELECT sal FROM emp WHERE empno=7788); 【训练2】 查询和SCOTT同一部门且比他工资低的雇员名字和工资。执行以下查询： 123SELECT ename,sal FROM empWHERE sal&lt;(SELECT sal FROM emp WHERE empno=7788)AND deptno=(SELECT deptno FROM emp WHERE empno=7788); 【训练3】 查询工资高于平均工资的雇员名字和工资。执行以下查询：12SELECT ename,sal FROM empWHERE sal&gt;(SELECT AVG(sal) FROM emp); 多行子查询 如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。例如【训练4】 查询工资低于任何一个“CLERK”的工资的雇员信息。执行以下查询：123SELECT empno, ename, job,sal FROM empWHERE sal &lt; ANY (SELECT sal FROM emp WHERE job = 'CLERK')AND job &lt;&gt; 'CLERK'; 【训练5】 查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。执行以下查询： 12SELECT empno, ename,sal FROM empWHERE sal &gt; ALL(SELECT sal FROM emp WHERE job= 'SALESMAN'); 【训练6】 查询部门20中职务同部门10的雇员一样的雇员信息。执行以下查询：123SELECT empno, ename, job FROM empWHERE job IN (SELECT job FROM emp WHERE deptno=10)AND deptno =20; 【训练7】 查询职务和SCOTT相同，比SCOTT雇佣时间早的雇员信息。执行以下查询： 123SELECT empno, ename, job FROM empWHERE job =(SELECT job FROM emp WHERE empno=7788)AND hiredate &lt; (SELECT hiredate FROM emp WHERE empno=7788); 多列子查询例如如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。 【训练8】 查询职务和部门与SCOTT相同的雇员的信息。执行以下查询： 12SELECT empno, ename, sal FROM empWHERE (job,deptno) =(SELECT job,deptno FROM emp WHERE empno=7788); 在FROM从句中使用子查询 在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法。 【训练9】 查询雇员表中排在第6～9位置上的雇员。 12SELECT ename,sal FROM (SELECT rownum as num,ename,sal FROM emp WHERE rownum&lt;=9 )WHERE num&gt;=6; 说明：子查询出现在FROM从句中，检索出行号小于等于9的雇员，并生成num编号列。在主查询中检索行号大于等于6的雇员。例如注意：以下用法不会有查询结果，请自行分析原因。12SELECT ename,sal FROM empWHERE rownum&gt;=6 AND rownum&lt;=9; 集合运算 多个查询语句的结果可以做集合运算，结果集的字段类型、数量和顺序应该一样。 【训练1】 查询部门10和部门20的所有职务。 123SELECT job FROM emp WHERE deptno=10&lt;span id="inline-blue"&gt;UNION&lt;/span&gt;SELECT job FROM emp WHERE deptno=20; 【训练2】 查询部门10和20中是否有相同的职务和工资。执行以下查询：123SELECT job,sal FROM emp WHERE deptno=10&lt;span id="inline-blue"&gt;INTERSECT&lt;/span&gt;SELECT job,sal FROM emp WHERE deptno=20; 【训练3】 查询只在部门表中出现，但没有在雇员表中出现的部门编号。执行以下查询： 123SELECT deptno FROM dept&lt;span id="inline-blue"&gt;MINUS&lt;/span&gt;SELECT deptno FROM emp ;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习七]]></title>
    <url>%2F2017%2F11%2F28%2Foracle%E5%AD%A6%E4%B9%A0%E4%B8%83%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第七章，主要是用来复习和巩固在课堂学习的知识！ 笔记 不等连接 拿一个表作为另一表的查询条件或范围如：显示雇员名称，工资和所属工资等级。执行以下查询：123SELECT e.ename, e.sal, s.grade FROM emp e,salgrade sWHERE e.sal BETWEEN s.losal AND s.hisal 自连接 自连接就是一个表，同本身进行连接。对于自连接可以想像存在两个相同的表(表和表的副本)，可以通过不同的别名区别两个相同的表（其它就是内连接）。 显示雇员名称和雇员的经理名称。执行以下查询：123SELECT worker.ename||' 的经理是 '||manager.ename AS 雇员经理 FROM emp worker, emp managerWHERE worker.mgr = manager.empno; 组函数 组函数只能应用于SELECT子句、HAVING子句或ORDER BY子句中。 A.组函数也可以称为统计函数。 B.组函数忽略列的空值。 C.对组可以应用组函数。 D.在组函数中可使用DISTINCT或ALL关键字。 E.ALL表示对所有非NULL值(可重复)进行运算。 F.DISTINCT 表示对每一个非NULL值，如果存在重复值，则组函数只运算一次。如果不指明上述关键字，默认为ALL。 函 数 说 明 AVG 求平均值 COUNT 求计数值，返回非空行数，*表示返回所有行 MAX 求最大值 MIN 求最小值 SUM 求和 STDDEV 求标准偏差，是根据差的平方根得到的 VARIANCE 求统计方差 分组查询 如：按职务统计工资总和。执行以下查询：12SELECT job,SUM(sal) FROM emp GROUP BY job; 多列分组按部门和职务分组统计工资总和。 123SELECT deptno, job, sum(sal) FROM emp GROUP BY deptno, job; HAVING HAVING从句过滤分组后的结果，它只能出现在GROUP BY从句之后，而WHERE从句要出现在GROUP BY从句之前。 统计各部门的最高工资，排除最高工资小于3000的部门。 执行以下查询：123SELECT deptno, max(sal) FROM emp GROUP BY deptnoHAVING max(sal)&gt;=3000; 分组统计结果排序 可以使用ORDER BY从句对统计的结果进行排序，ORDER BY从句要出现在语句的最后。 如：按职务统计工资总和并排序。执行以下查询：123SELECT job 职务, SUM(sal) 工资总和 FROM emp GROUP BY jobORDER BY SUM(sal); 组函数的嵌套使用 如：求各部门平均工资的最高值。执行以下查询：1SELECT max(avg(sal)) FROM emp GROUP BY deptno; 统计查询 统计查询【训练1】 求雇员总人数。执行以下查询： 1SELECT COUNT(*) FROM emp; 【训练2】 求有佣金的雇员人数。执行以下查询：1SELECT COUNT(comm) FROM emp; 【训练3】 求部门10的雇员的平均工资。执行以下查询：1SELECT AVG(sal) FROM emp WHERE deptno=10; 【训练4】 求最晚和最早雇佣的雇员的雇佣日期。执行以下查询：1SELECT MAX(hiredate),MIN(hiredate) FROM emp; 【训练5】 求雇员表中不同职务的个数。执行以下查询： 1SELECT COUNT( DISTINCT job) FROM emp; 分组统计通过下面的训练，我们来了解分组的用法。【训练6】 按职务统计工资总和。 步骤1：执行以下查询： 1SELECT SUM(sal) FROM emp GROUP BY job; 步骤2：执行以下查询： 1SELECT job,SUM(sal) FROM emp GROUP BY job; 【练习2】查看以下查询的显示结果，并解释原因。 1SELECT ename,job,SUM(sal) FROM emp GROUP BY sal; 多列分组统计 【训练7】 按部门和职务分组统计工资总和。 123SELECT deptno, job, sum(sal) FROM emp GROUP BY deptno, job; 分组统计结果限定 对分组查询的结果进行过滤，要使用HAVING从句。HAVING从句过滤分组后的结果，它只能出现在GROUP BY从句之后，而WHERE从句要出现在GROUP BY从句之前。 【训练8】 统计各部门的最高工资，排除最高工资小于3000的部门。执行以下查询：123SELECT deptno, max(sal) FROM empGROUP BY deptnoHAVING max(sal)&gt;=3000; 【训练8】 统计各部门的最高工资，排除最高工资小于3000的部门。执行以下查询：123SELECT deptno, max(sal) FROM empGROUP BY deptnoHAVING max(sal)&gt;=3000; 分组统计结果排序 可以使用ORDER BY从句对统计的结果进行排序，ORDER BY从句要出现在语句的最后。例如【训练9】 按职务统计工资总和并排序。执行以下查询：123SELECT job 职务, SUM(sal) 工资总和 FROM emp GROUP BY jobORDER BY SUM(sal); 组函数的嵌套使用 在如下训练中，使用了组函数的嵌套。【训练10】 求各部门平均工资的最高值。执行以下查询： 1SELECT max(avg(sal)) FROM emp GROUP BY deptno; 注意：虽然在查询中有分组列，但在查询字段中不能出现分组列。如下的查询是错误的： 1SELECT deptno,max(avg(sal)) FROM emp GROUP BY deptno; 因为各部门平均工资的最高值不应该属于某个部门。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jar的加入(转)]]></title>
    <url>%2F2017%2F11%2F27%2Fjar%E7%9A%84%E5%8A%A0%E5%85%A5%2F</url>
    <content type="text"><![CDATA[现在的项目基本上都是java web项目,所以导入jar包会出现问题,主要介绍一下java项目与javaweb项目的区别: java项目: 在classLoader加载jar和class的时候,是分开加载的,一般jar导入分两种: 1.在web-inf下的lib中直接引入 2.在user library上引入 无论以上哪种引入,jar包都能加载并且运行,classLoader会智能加载(本地JRE运行) javaweb项目; 不是通过本地的JRE运行的，而是部署到web服务器(比如tomcat,jetty)，这些服务器都实现了自身的类加载器. 以tomcat为例: 1.common CommonClassLoader 2.server CatalinaClassLoader 3.shared SharedClassLoader 4.webapps webappClassLoader(加载WEB-INF下的jar) 简单来说,如果做javaweb项目引入jar包的时候,需要将jar包导入到WEB-INF下,这样服务器就能够加载并且项目跑起来的时候,项目的方法也可以调用,如果放入到user library中是不可以的,因为这样只能本地运行,服务器是加载不到的.所以项目本地调用方法的时候没有问题,但是服务器跑起来就会报出找不到相应的jar. 转链地址 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习六]]></title>
    <url>%2F2017%2F11%2F27%2Foracle%E5%AD%A6%E4%B9%A0%E5%85%AD%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第六章，主要是用来复习和巩固在课堂学习的知识！ 笔记 相等连接（内连接） 123select ename,job,sal,comm,emp.deptno,dnamefrom emp,deptwhere emp.deptno = dept.deptno 注意：如果两个表有同名列，那么前面必须接表名 如： emp.deptno ,如果不是同名字段则表名可以省略 inner join 的写法: 例如123select ename,job,sal,comm,emp.deptno,dname from emp inner join dept on emp.deptno = dept.deptno 三表或三表以上的写法 123select 字段1，字段2 , 字段3 。。。。from 表1，表2，表3.。。where 表1.外键 = 表2.主键 and 表1.外键 = 表3.主键 and 。。。 注意：两个表有一个条件 ，三个表有两个条件 ，四个表有三个条件 以此类推 外连接(不等连接) 左外连接即在内连接的基础上，左边表中有但右边表中没有的记录也以null的形式显示出来，右外连接则反之 1.写法1 例如(右外连接) 123select ename,d.deptno,dnamefrom emp e,dept dwhere e.deptno(+) = d.deptno (左外连接)123select ename,d.deptno,dnamefrom emp e,dept dwhere d.deptno = e.deptno(+) 2.写法2123select ename,d.deptno,dname from emp e right join dept d on e.deptno = d.deptno 高级查询 多表联合查询 A.通过连接可以建立多表查询，多表查询的数据可以来自多个表，但是表之间必须有适当的连接条件。 B.一般N个表进行连接，需要至少N-1个连接条件，才能够正确连接。两个表连接是最常见的情况，只需要说明一个连接条件。 C.两个表的连接有四种连接方式： 相等连接。 不等连接。 外连接。 自连接。 相等连接通过两个表具有相同意义的列，可以建立相等连接条件。 【训练1】 显示雇员的名称和所在的部门的编号和名称。执行以下查询： 123456789101112SELECT emp.ename,emp.deptno,dept.dname FROM emp,dept WHERE emp.deptno=dept.deptno;```sql【训练2】 使用表别名。执行以下查询：```sqlSELECT ename,e.deptno,dname FROM emp e,dept d WHERE e.deptno=d.deptno; 外连接 A.在以上的例子中，相等连接有一个问题：如果某个雇员的部门还没有填写，即保留为空，那么该雇员在查询中就不会出现；或者某个部门还没有雇员，该部门在查询中也不会出现。 B.为了解决这个问题可以用外连，即除了显示满足相等连接条件的记录外，还显示那些不满足连接条件的行。外连操作符为(+)，它可以出现在相等连接条件的左侧或右侧。 【训练4】 使用外连显示不满足相等条件的记录。步骤1：显示雇员的名称、工资和所在的部门名称及没有任何雇员的部门。执行以下查询： 123SELECT ename,sal,dname FROM emp,dept WHERE emp.deptno(+)=dept.deptno; 外连接123SELECT ename,sal,dname FROM emp right outer join dept on emp.deptno = dept.deptno; 步骤2：显示雇员的名称、工资和所在的部门名称及没有属于任何部门的雇员。执行以下查询： 123SELECT ename,sal,dname FROM emp,dept WHERE emp.deptno=dept.deptno(+); 123SELECT ename,sal,dname FROM emp left outer join dept on emp.deptno = dept.deptno; 不等连接还可以进行不等的连接。 【训练5】 显示雇员名称，工资和所属工资等级执行以下查询： 123SELECT e.ename, e.sal, s.grade FROM emp e,salgrade s WHERE e.sal BETWEEN s.losal AND s.hisal 自连接最后是一个自连接的训练实例，自连接就是一个表，同本身进行连接。对于自连接可以想像存在两个相同的表(表和表的副本)，可以通过不同的别名区别两个相同的表。 【训练6】 显示雇员名称和雇员的经理名称执行以下查询： 123SELECT worker.ename||' 的经理是 '||manager.ename AS 雇员经理 FROM emp worker, emp manager WHERE worker.mgr = manager.empno; 统计查询Oracle提供了一些函数来完成统计工作，这些函数称为组函数，组函数不同于前面介绍和使用的函数(单行函数)。组函数可以对分组的数据进行求和、求平均值等运算。 组函数只能应用于SELECT子句、HAVING子句或ORDER BY子句中。组函数也可以称为统计函数。 组函数忽略列的空值。对组可以应用组函数。在组函数中可使用DISTINCT或ALL关键字。ALL表示对所有非NULL值(可重复)进行运算。DISTINCT 表示对每一个非NULL值，如果存在重复值，则组函数只运算一次。如果不指明上述关键字，默认为ALL。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习五]]></title>
    <url>%2F2017%2F11%2F26%2Foracle%E5%AD%A6%E4%B9%A0%E4%BA%94%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第五章，主要是用来复习和巩固在课堂学习的知识！ 函数专项 数值型函数 字符型函数 字符型函数包括大小写转换和字符串操作函数。大小写转换函数有3个. 日期型函数 A.Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。 B.SYSDATE是返回系统日期和时间的虚列函数 【训练1】 返回系统的当前日期。输入并执行查询：1SELECT sysdate FROM dual; 【训练2】 返回2003年2月的最后一天。输入并执行查询：1SELECT last_day('08-2月-03') FROM dual; 【训练3】 假定当前的系统日期是2003年2月6日，求再过1000天的日期。输入并执行查询：1SELECT sysdate+1000 AS "NEW DATE" FROM dual; 【训练4】 假定当前的系统日期是2003年2月6日，显示部门10雇员的雇佣天数。输入并执行查询：123SELECT ename, round(sysdate-hiredate) DAYSFROM empWHERE deptno = 10; 转换函数 Oracle的类型转换分为自动类型转换和强制类型转换。常用的类型转换函数有TO_CHAR、TO_DATE或TO_NUMBER 自动类型转换Oracle可以自动根据具体情况进行如下的转换： 字符串到数值。 字符串到日期。 数值到字符串。 日期到字符串。 【训练1】 自动转换字符型数据到数值型。输入并执行查询：1SELECT '12.5'+11 FROM dual; 【训练2】 自动转换数值型数据到字符型。执行以下查询：1SELECT '12.5'||11 FROM dual; 日期类型转换将日期型转换成字符串时，可以按新的格式显示。如格式YYYY-MM-DD HH24:MI:SS表示“年-月-日 小时:分钟:秒”。Oracle的日期类型是包含时间在内的。 【训练3】 将日期转换成带时间和星期的字符串并显示。执行以下查询：1SELECT TO_CHAR(sysdate,'YYYY-MM-DD HH24:MI:SS AM DY') FROM dual; 【训练4】 将日期显示转换成中文的年月日。输入并执行查询：1SELECT TO_CHAR(sysdate,'YYYY"年"MM"月"DD"日"') FROM dual; 【训练5】 将雇佣日期转换成字符串并按新格式显示。输入并执行查询：12SELECT ename, to_char(hiredate, 'DD Month YYYY') HIREDATEFROM emp; 【训练6】 以全拼和序列显示时间。执行以下查询：12SELECT SYSDATE,to_char(SYSDATE,'yyyysp'),to_char(SYSDATE,'mmspth'),to_char(SYSDATE,'ddth') FROM dual; 【训练7】 时间显示的大小写。步骤1：执行以下查询：1SELECT SYSDATE,to_char(SYSDATE,'yyyysp') FROM dual; 步骤2：执行以下查询：1SELECT to_char(SYSDATE,'Yyyysp') FROM dual; 步骤3：执行以下查询：1SELECT SYSDATE,to_char(SYSDATE,'YYyysp') FROM dual; 数字类型转换 将数字型转换成字符串时，也可以按新的格式显示 【训练8】 将数值转换成字符串并按新格式显示。执行以下查询：1SELECT TO_CHAR(123.45,’9999.99'), TO_CHAR(12345,'L9.9EEEE') FROM dual; 【训练9】 将数值转换成字符串并按新格式显示。执行以下查询：12SELECT TO_CHAR(sal,'$99,999') SALARY FROM empWHERE ename = 'SCOTT'; 其他函数 Oracle还有一些函数，如decode和nvl，这些函数也很有用 空值的转换: 如果对空值NULL不能很好的处理，就会在查询中出现一些问题。在一个空值上进行算术运算的结果都是NULL。最典型的例子是，在查询雇员表时，将工资sal字段和津贴字段comm进行相加，如果津贴为空，则相加结果也为空，这样容易引起误解。 使用nvl函数，可以转换NULL为实际值。该函数判断字段的内容，如果不为空，返回原值；为空，则返回给定的值。 如下3个函数，分别用新内容代替字段的空值： nvl(comm, 0)：用0代替空的Comm值。nvl(hiredate, ‘01-1月-97’)：用1997年1月1日代替空的雇佣日期。nvl(job, ‘无’)：用“无”代替空的职务 decode函数: decode函数可以通过比较进行内容的转换，完成的功能相当于分支语句。在参数的最后位置上可以存在单独的参数，如果以上比较过程没有找到匹配值，则返回该参数的值，如果不存在该参数，则返回NULL。 【训练1】 使用nvl函数转换空值。执行以下查询：1SELECT ename,nvl(job,'无'),nvl(hiredate,'01-1月-97'),nvl(comm,0) FROM emp; 【训练2】 将职务转换成中文显示。执行以下查询：1SELECT ename,decode(job, 'MANAGER', '经理', 'CLERK','职员', 'SALESMAN','推销员', 'ANALYST','系统分析员','未知') FROM emp; 最大、最小值函数1greatest返回参数列表中的最大值，least返回参数列表中的最小值。 如果表达式中有NULL，则返回NULL。 练习【练习1】显示雇员名称和雇佣的星期数。1Select ename,round((sysdate-hiredate)/7) from emp; 【练习2】显示从本年1月1日开始到现在经过的天数(当前时间取SYSDATE的值)。1Select sysdate - to_date(‘2017-1-1’,’YYYY-MM-DD’ )from dual; 【练习3】显示2008年的8月8日为星期几。1Select to_char(‘8-8月-2008’,’DY’) from dual; 【练习4】对部门表的部门名称和城市名进行转换。1234select * from dept;select decode(dname,'ACCOUNTING','统计部','RESEARCH','研发部','SALES','销售部','OPERATIONS','其它部门') 部门,decode(loc,'NEW YORK','纽约','DALLAS','达拉斯','CHICAGO','芝加哥','BOSTON','波士顿') 城市 from dept; 【练习5】判断用户的角色是否为SYSDBA。1Select userenv(‘ISDBA’) from dual;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习四]]></title>
    <url>%2F2017%2F11%2F25%2Foracle%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第四章，主要是用来复习和巩固在课堂学习的知识！ 条件查询 模糊查询(between、in、like)1.between:在某某之间显示工资在1000～2000之间的雇员信息。输入并执行查询： 1SELECT * FROM emp WHERE sal BETWEEN 1000 AND 2000; 2.in: 在某某之内显示职务为“SALESMAN’，“CLERK”和“MANAGER”的雇员信息。输入并执行查询： 1SELECT * FROM emp WHERE job IN ('SALESMAN','CLERK','MANAGER'); 3.like:与通配符合用通配符： %：代表0个或任意个字符 _:代表1个字符 显示姓名以“S”开头的雇员信息。输入并执行查询：1SELECT * FROM emp WHERE ename LIKE 'S%'; 显示姓名第二个字符为“A”的雇员信息。执行查询： 1SELECT * FROM emp WHERE ename LIKE '_A%'; 4.空值查询 123空：is null&lt;br/&gt; 非空：is not null&lt;br/&gt;如：查询奖金为空的雇员信息&lt;br/&gt; 1select * from emp where comm is null 函数 数学函数 函 数 功 能 实 例 结 果 abs 求绝对值函数 abs(-5) 5 sqrt 求平方根函数 sqrt(2) 1.41421356 power 求幂函数 power(2,3) 8 【训练1】 使用数值型函数练习。 步骤1：使用求绝对值函数abs。 1SELECT abs(-5) FROM dual; 步骤2：使用求平方根函数sqrt。 1SELECT sqrt(2) FROM dual; 步骤3：使用ceil函数。 1SELECT ceil(2.35) FROM dual; 步骤4：使用floor函数。 1SELECT floor(2.35) FROM dual; 使用四舍五入函数round 格式: round(数字，保留的位数) 1SELECT round(45.923,2), round(45.923,0), round(45.923,-1) FROM dual; 字符型函数 函数名称 功 能 实 例 结 果 ascii 获得字符的ASCII码 Ascii(‘A’) 65 chr 返回与ASCII码相应的字符 Chr(65) A lower 将字符串转换成小写 lower (‘SQL Course’) sql course upper 将字符串转换成大写 upper(‘SQL Course’) SQL COURSE initcap 将字符串转换成每个单词以大写开头 initcap(‘SQL course’) Sql Course concat 连接两个字符串 concat(‘SQL’, ‘ Course’) SQL Course substr 给出起始位置和长度，返回子字符串 substr(‘String’,1,3) Str length 求字符串的长度 length(‘Wellcom’) 7 trim 在一个字符串中去除另一个字符串 trim(‘S’ FROM ‘SSMITH’) MITH replace 用一个字符串替换另一个字符串中的子字符串 replace(‘ABC’, ‘B’, ‘D’) ADC 【训练1】 如果不知道表的字段内容是大写还是小写，可以转换后比较。输入并执行查询： 123456789SELECT empno, ename, deptno FROM empWHERE lower(ename) ='blake';```sql【训练2】 显示名称以“W”开头的雇员，并将名称转换成以大写开头。输入并执行查询： ```sqlSELECT empno,initcap(ename),job FROM emp WHERE substr(ename,1,1)='W'; 【训练3】 显示雇员名称中包含“S”的雇员名称及名称长度。输入并执行查询： 12SELECT empno,ename,length(ename) FROM empWHERE instr(ename, 'S', 1, 1)&gt;0; 日期型函数 A.Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。 B.SYSDATE是返回系统日期和时间的虚列函数。 显示1982年以后雇佣的雇员姓名和雇佣时间。 输入并执行查询：1SELECT ename,hiredate FROM emp WHERE hiredate&gt;='1-1月-82'; 显示部门10以外的其他部门的雇员。输入并执行查询： 1SELECT * FROM emp WHERE NOT deptno=10; 显示姓名第二个字符为“A”的雇员信息。执行查询： 1SELECT * FROM emp WHERE ename LIKE '_A%'; 显示经理编号没有填写的雇员。输入并执行查询： 1SELECT ename, mgr FROM emp WHERE mgr IS NULL; 如果不知道表的字段内容是大写还是小写，可以转换后比较。输入并执行查询： 12SELECT empno, ename, deptno FROM empWHERE lower(ename) ='blake'; 显示名称以“W”开头的雇员，并将名称转换成以大写开头。输入并执行查询： 1SELECT empno,initcap(ename),job FROM emp WHERE substr(ename,1,1)='W'; 【训练15】 显示雇员名称中包含“S”的雇员名称及名称长度。输入并执行查询：12SELECT empno,ename,length(ename) FROM empWHERE instr(ename, 'S', 1, 1)&gt;0; 在Oracle/PLSQL中，instr函数返回要截取的字符串在源字符串中的位置。只检索一次，就是说从字符的开始到字符的结尾就结束。语法如下：sql instr( string1, string2 [, start_position [, nth_appearance ] ] )sql参数分析： string1:源字符串，要在此字符串中查找。 string2:要在string1中查找的字符串. start_position:代表string1 的哪个位置开始查找。此参数可选，如果省略默认为1. 字符串索引从1开始。如果此参数为正，从左到右开始检索，如果此参数为负，从右到左检索，返回要查找的字符串在源字符串中的开始索引。 nth_appearance:代表要查找第几次出现的string2. 此参数可选，如果省略，默认为 1.如果为负数系统会报错。 注意： 如果String2在String1中没有找到，instr函数返回0.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习三]]></title>
    <url>%2F2017%2F11%2F24%2Foracle%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第三章，主要是用来复习和巩固在课堂学习的知识！ 创建表空间 完整版 1234567create tablespace epet_tablespacedatafile 'c:epet.dbf'size 100Mautoextend on next 32M maxsize unlimitedloggingextent management localsegment space mamgement auto; 简化版 123create tablespace epet_tablespacedatafile 'c:epet.dbf'size 100M 数据查询 查询格式： 12345select 列名 from 表名 where 查询条件 group by 分组列 having 分组后条件 order by 排序列 简单查询（查询加条件） 如：查询部门10的雇员。 输入并执行查询：1SELECT * FROM emp WHERE deptno=10; 行号 每个表都有一个虚列ROWNUM，它用来显示结果中记录的行号。我们在查询中也可以显示这个列。【任务1】 显示EMP表的行号。 输入并执行查询： 1SELECT rownum,ename FROM emp; 查询时进行计算 1、显示雇员工资上浮20%的结果。输入并执行查询: 1SELECT ename,sal,sal*(1+20/100) FROM emp; 2、显示每一个雇员的总收入(工资+奖金) 12update emp set comm = 0 where comm is null; --将工资为null的改为0select ename,sal+comm as 总收入 from emp; 使用别名 在查询中使用列别名。输入并执行： 1SELECT ename AS 名称, sal 工资 FROM emp; 注意：建议大家省略AS 在列别名上使用双引号。（当你的别名为关键字或别名中有特殊符号时需要加双引号）输入并执行查询： 1SELECT ename AS "select", sal*12+5000 AS "年度工资(加年终奖)" FROM emp; 连接运算符 连接运算符是双竖线“||”。通过连接运算可以将两个字符串连接在一起。如： 123456789101112131415SELECT ename||job AS "雇员和职务表" FROM emp;‘5’+ 5 结果为 10 ‘5’|| 5 结果为 '55' ```sql- 查询结果的排序ASC 表示升序 (可省略) Desc 表示降序(不可省略)1.升序排序【训练1】 查询雇员姓名和工资，并按工资从小到大排序。输入并执行查询：```sqlSELECT ename, sal FROM emp ORDER BY sal; 2．降序排序【训练2】 查询雇员姓名和雇佣日期，并按雇佣日期排序，后雇佣的先显示。输入并执行查询： 1SELECT ename,hiredate FROM emp ORDER BY hiredate DESC; 3.多列排序【训练3】 查询雇员信息，先按部门从小到大排序，再按雇佣时间的先后排序。输入并执行查询： 1SELECT ename,deptno,hiredate FROM emp ORDER BY deptno,hiredate; 消除重复行 如果在显示结果中存在重复行，可以使用的关键字DISTINCT消除重复显示。如：使用DISTINCT消除重复行显示。输入并执行查询： 1SELECT DISTINCT job FROM emp; 练习【练习1】显示当前的账户名，显示当前账户的EMP表的结构，显示EMP表中的数据。 123Show user;Desc emp;Select * from emp; 【练习2】根据EMP表和DEPT表的显示结果，说出雇员ADAMS的雇员编号、职务、经理名字、雇佣日期、工资、津贴和部门编号以及该雇员所在的部门名称和所在城市。 12Select * from emp where ename = ‘ADAMS’Select dname,loc from dept where deptno = (select deptno from emp where ename =’ADAMS’) 【练习3】说出职务为CLERK的工资最高的雇员是哪一位？职务为CLERK、部门在NEW YORK的雇员是哪一位? 12select * from emp where sal = (Select max(sal) from emp where job = ‘CLERK’)Select * from emp where job = ‘CLERK’ and deptno in (select deptno from dept where loc = ‘NEW YORK’) 【练习4】显示DEPT表的内容，按以下的形式: 部门ACCOUNTING所在的城市为NEW YORK 1Select ‘部门’||dname||’所在的城市为’||loc from dept]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习二]]></title>
    <url>%2F2017%2F11%2F23%2Foracle%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第二章，主要是用来复习和巩固在课堂学习的知识！ 创建用户说明：创建新用户user1，口令为123，口令需要以字母开头。 登录SCOTT账户 1create user user1 identified by 123 -- 创建新用户user1 授权 1234grant connect to user1; -- 授予user1连接数据库权限grant create table to user1; -- 授予user1创建表的权限grant create proedure to user1; -- 授予user1创建存储过程的权限grant unlimited tablespace to user1; -- 授予user1表空间使用权限 创建表说明：以创建表的方式复制数据到新账户。 123create table emp as select * from scott.emp;create table dept as select * from scott.dept;create table salgrades as select * from scott.salgrade; 在USER1账户下复制了SCOTT账户的三个表：EMP、DEPT和SALGRADES。 给用户授权 方式一：授予角色 123connect : 登录resource: 普通权限，用于操作DBA: 管理员权限 （慎用） 例如： 12grant connect to user1 grant connect,resource to user1 方式二：授予单个权限 例如： 12grant create table to user1 授予user1建表的权限grant drop table to user1 授予user1删表的权限 方式三：将某个对象的权限授予用户 例如： 12grant select on scott.emp to user1 -- 将scott用户的emp表的查询权限授予user1grant all on scott.emp to user1 将scott用户的emp表的所有权限授予user1 收回权限 revoke 权限 from 用户 例如： 12revoke connect from user1 收回user1的connect权限revoke select on scott.emp from user1 收回user1对emp表的查询权限]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库命令名规范]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[良好的命名习惯是一种美德 数据库命令名规范是十分必要的，一个好的命名可以让人清楚的知道这是什么，一目了然！ 总体命名规范 名称的长度不超过32个字符 名称采用英文单词、英文单词缩写和数字，单词之间用“_”分隔 数据库对象名称首字母必须小写。 不得采用“_”作为名称的起始字母和终止字母。 名称必须望文知意。 名称不得与数据库管理系统保留字冲突。 不要在对象名的字符之间留空格。 数据库名 数据库名定义为系统名+模块名，或直接采用系统名 数据库名全部采用小写。 数据库文件 数据文件命名采用数据库名+_+文件类型+［文件序号］.文件后缀，文件序号为1、2、3…9等数值，当数据库中某一文件类型的文件有多个时加上文件序号以区别。只有一个时可不加。 文件后缀：主数据文件为.mdf，其它数据文件为.ndf,日志文件为.ldf。 文件名全部采用小写。 表 表命名要遵循以下原则：采用“系统名+_+t_+模块名+_+表义名”格式构成。 若数据库中只含有单个模块，命名可采用“系统名+t_+表义名”格式构成。 整个表名的长度不要超过30个字符。系统名、模块名均采用小写字符。 模块名或表义名均以其英文单词命名，且字符间不加分割符；表义名中单词的首字符大写，其它字符小写，多个单词间也不加任何分割符，单词全部采用单数形式。 表别名命名规则：取表义名的前3个字符加最后一个字符。如果存在冲突，适当增加字符（如取表义名的前4个字符加最后一个字符等）。 关联表命名为Re_表A_表B,Re是Relative的缩写，表A和表B均采用其表义名或缩写形式。 数据库设计规范 数据库中不论是表名还是字段名，都一律用英文，不准出现其它语言； 为了不增加数据库当中的表名的长度，一般不允许出现如Form或者Table的字样，如：记录表：应为Record,而不是RecordTable 数据库当中的表名的命名，不允许出现空格，假如有几个单词出现的话，每个单词之间用 ”_” 隔开如人事信息表：应为Human_Info，而不是Human Info； 每个单词的第一个字母必须大写；如果太长，为了不增加编程的难度可采用缩写的方式，每个单词可取三到四个字母表示，也可根据实际情况，实际习惯进行缩写 属性（列或字段） 采用有意义的列名，为实际含义的英文单词，且字符间不加任何分割符。 属性名前不要加表名等作为前缀。属性后不加任何类型标识作为后缀。不要使用“ID”等与系统保留关键字冲突的单词作为列名。 主键 任何表都必须定义主键。 表主键命名为：“pk++表名(或缩写)++主键标识”。 外键 表外键命名为：“fk++表名(或缩写)+主表名(或缩写)+_+主键标识”。 索引 索引的命名为：“表名（或缩写）+_+列名+_idx”。 其中多单词组成的属性列列名取前几个单词首字符，加末单词组成。 Default标识 由“df+_+&lt;default标识名&gt;”组成。 Rule标识 由“ru+_+&lt;Rule标识名&gt;”组成。 自定义数据类型 自定义数据类型由“ud++&lt;自定义数据类型标识&gt;++&lt;数据类型&gt;”组成 触发器 AFTER型触发器：系统名+tr_+&lt;表名&gt;_+&lt;i,u,d的任意组合&gt;，其中i，u，d分别表示insert、update和delete。 INSTEADOF型触发器： 系统名+ti_+&lt;表名&gt;+_+&lt;i,u,d的任意组合&gt;，其中i，u，d分别表示insert、update和delete。 视图 视图命名以系统名+v_+模块名作为前缀，其他命名规则和表的命名类似。 存储过程命名 “系统名+sp+_+存储过程标识(缩写)”组成。 存储过程标识要以实际含义的英文单词构成，并用下划线分割各个组成部分. 函数 函数命名由“系统名+f+_+函数标识”组成。 变量名 参数变量命名采用“i(o或io)+_+名称”形式，前缀i或o表示输入还是输出参数。 过程变量命名采用“l+_+名称”形式。 变量名采用小写，若属于词组形式，用下划线分隔每个单词。 ##角色 全部使用小写字符命名。 由“系统名称++role++名词(或缩写)或名词短语(或缩写)”组成。 ##用户 全部使用小写字符命名。 由“系统名称++user++名词(或缩写)或名词短语(或缩写)”组成。 Transact-SQL编程基本规范 一般性注释: 注释可以包含在批处理中。在触发器、存储过程中包含描述性注释将会大大增加文本的可读性和可维护性。 注释尽可能详细、全面。 创建每一个数据对象前，应具体描述该对象的功能和用途。 传入参数的含义应该有所说明。如果取值范围确定，也应该一并说明。取值有特定含义的变量（如boolean类型变量），应给出每个值的含义。 注释语法包含两种情况：单行注释、多行注释。 单行注释：注释前有两个连字符（–），最后以换行符结束。一般对变量、条件子句可以采用该类注释。 多行注释：符号/和/之间的内容为注释内容。对某项完整的操作建议使用该类注释。 注释应当简洁，同时应描述清晰。 函数文本注释 编写函数文本–如视图、函数、触发器、存储过程以及其他数据对象时，必须为每个函数增加适当注释。该注释以多行注释为主，主要结构如下： / 参考资源 参考1]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql五种约束]]></title>
    <url>%2F2017%2F11%2F23%2Fsql%E4%BA%94%E7%A7%8D%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[SQL server的五种约束： 主键约束（Primay Key Coustraint） 外键约束（Foreign Key Counstraint） 唯一约束（Unique Counstraint） 检查约束（Check Counstraint） 默认约束（Default Counstraint） 主键约束（Primay Key Coustraint） 直接添加： create table 表名 ( 字段名 数据类型 primary key ); 联合主键： create table 表名 ( 字段名1 数据类型1 字段名2 数据类型2 constraint PK_字段名1_字段名2 可以省略此行（约束名称） primary key(字段名1,字段名2) ); alter添加: 1.alter table 表名1 modify 字段名1 类型名1 primary key; 2.alter table 表名2 add primary key(字段名2); 3.alter table 表名3 add constrain 约束名 primary key(字段名3); 删除主键约束 alter table 表名 drop primary key; 默认约束（Default Counstraint） 直接添加： create table 表名 ( 字段名 类型名 default(条件) ) alter添加: alter table 表名1 modify 字段名1 类型名1 default 条件1; alter table 表名2 add constarint 字段名2 类型名 default 条件2 ; 改变默认约束： alter table 表名1 change 字段名1 字段名1 类型名1 default 条件1; 删除默认约束： alter table 表名1 modify 字段名1 类型名1; alter table 表名2 change 字段名2 字段名2 类型名2 唯一约束（Unique Counstraint） 直接添加： create table 表名1 （字段名1 类型名1 unique）; create table 表名2 （字段名2 类型名2，unique key(字段2)）; alter添加: alter table 表名1 modify 字段名1 类型名1 unique; alter table 表名2 add unique(字段名2); alter table 表名3 add unique key (字段名3); alter table 表名4 add constarint 约束名4 unique (字段名4); alter table 表名5 add constarint 约束名5 unique key (字段名5); 改变唯一约束： alter table 表名1 change 字段名1 字段名1 类型名1 unique; 删除唯一约束： alter table 表名1 drop index 字段名1; 检查约束（Check Counstraint） 直接添加： create table 表名1 ( 字段名1 类型名1 check (条件） ); alter添加: alter table 表名1 add constarint 约束名1 default （字段名1条件）; 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL serve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习一]]></title>
    <url>%2F2017%2F11%2F22%2Foracle%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[此文章是oracle学习系例第一章，主要是用来复习和巩固在课堂学习的知识！ 首先在学习之前，我们应该得安装一个oracle数据库，本人推荐oracle 11g（注意：oracle安装最好一次到位，请细心处理！） 准备 打开oracle主服务 找到pc上的计算机右击，找到管理打开，找到并打开服务和应用程序，打开服务并找到OracleServiceORCL【ORCL为你数据库服务的名字，一般默认为ORCL】 打开监听器 OracleOraDb11g_home1TNSListener 监听器一般就在oracle主服务上面，如果没有监听器就需要重新配置一个 配置监听器 开始菜单中找到net configration assistant添加一个监听器（不详细解释） 第三方工具（plsqldev）【需要注册】PL/SQL Developer是一个集成开发环境，由Allround Automations公司开发，专门面向Oracle数据库存储的程序单元的开发。如今，有越来越多的商业逻辑和应用逻辑转向了Oracle Server，因此，PL/SQL编程也成了整个开发过程的一个重要组成部分。PL/SQL Developer侧重于易用性、代码品质和生产力，充分发挥Oracle应用程序开发过程中的主要优势的。 解锁SCOTT用户 登录system用户 新建一个sql命令栏 输入下例命令： 12alter user scott account unlock; -- 解锁scott用户alter user scott identified by tiger; -- 修改scott密码 数据库知识扩展【了解】 数据库应用系统 典型的数据库应用有C/S(客户/服务器)和B/S(浏览器/服务器)两种模式 三个规范化设计规则 第一范式(1NF)：实体的所有属性必须是单值的并且不允许重复。第二范式(2NF)：实体的所有属性必须依赖于实体的惟一标识。第三范式(3NF)：一个非惟一标识属性不允许依赖于另一个非惟一标识属性。 CONNECT命令 1CONNECT SCOTT/TIGER@MYDB -- 重新连接数据库 环境设置命令 在SQLPlus环境下，可以通过SHOW ALL命令可以查看SQLPlus的环境参数。 显示当前用户【注意：使用SELECT USER FROM dual命令也可以取得用户名】 1show user]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达语法]]></title>
    <url>%2F2017%2F11%2F22%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。 在线正则匹配工具 http://www.regexpal.com/ http://rubular.com/ 正则字符 元字符 /.../ -- 代表一个模式的开始和结束 ^ -- 匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置 $ -- 匹配行或字符串的结尾、 \b -- 不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中&quot;This is Regex&quot;匹配单独的单词 &quot;is&quot; 正则就要写成 &quot;\bis\b（\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界） \d -- 匹配数字,等价[0-9] \w -- 匹配字母，数字，下划线 ,等价[a-zA-Z0-9] \s -- 匹配空格(例如字符 &quot;a b c&quot; 正则：&quot;\w\s\w\s\w&quot; 一个字符后跟一个空格，如有字符间有多个空格直接把&quot;\s&quot; 写成 &quot;\s+&quot; 让空格重复) . -- 匹配除了换行符以外的任何字符 [abc] -- 字符组 匹配包含括号内元素的字符 反义元字符： \W -- 匹配任意不是字母，数字，下划线 的字符 \S -- 匹配任意不是空白符的字符 \D -- 匹配任意非数字的字符 \B -- 匹配不是单词开头或结束的位置 [^abc] -- 匹配除了abc以外的任意字符 量词： * -- 重复零次或更多（例如&quot;aaaaaaaa&quot; 匹配字符串中所有的a 正则： &quot;a*&quot; 会出到所有的字符&quot;a&quot;） + -- 重复一次或更多次（例如&quot;aaaaaaaa&quot; 匹配字符串中所有的a 正则： &quot;a+&quot; 会取到字符中所有的a字符， &quot;a+&quot;与&quot;a*&quot;不同在于&quot;+&quot;至少是一次而&quot;*&quot; 可以是0次，） ? -- 重复零次或一次（例如&quot;aaaaaaaa&quot; 匹配字符串中的a 正则 ： &quot;a?&quot; 只会匹配一次，也就是结果只是单个字符a） {n} -- 重复n次（例如从&quot;aaaaaaaa&quot; 匹配字符串的a 并重复3次 正则： &quot;a{3}&quot; 结果就是取到3个a字符 &quot;aaa&quot;;） {n,m} -- 重复n到m次例如正则 &quot;a{3,4}&quot; 将a重复匹配3次或者4次 所以供匹配的字符可以是三个&quot;aaa&quot;也可以是四个&quot;aaaa&quot; 正则都可以匹配到 {n,} -- 重复n次或更多次（与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则&quot;a{3,}&quot; a至少要重复3次） 限定符： +? -- 重复1次或更多次，但尽可能少重复 ?? -- 重复0次或1次，但尽可能少重复（如 &quot;aaacb&quot; 正则 &quot;a.??b&quot; 只会取到最后的三个字符&quot;acb&quot;） {n,m}? -- 重复n到m次，但尽可能少重复（ 如 &quot;aaaaaaaa&quot; 正则 &quot;a{0,m}&quot; 因为最少是0次所以取到结果为空） {n,}? -- 重复n次以上，但尽可能少重复（如 &quot;aaaaaaa&quot; 正则 &quot;a{1,}&quot; 最少是1次所以取到结果为 &quot;a&quot;） 捕获分组：（暂时看不懂） (exp) -- 匹配exp,并捕获文本到自动命名的组里 (?&lt;name&gt;exp) -- 匹配exp,并捕获文本到名称为name的组里 (?:exp) -- 匹配exp,不捕获匹配的文本，也不给此分组分配组号以下为零宽断言 (?=exp) -- 匹配exp前面的位置（如 &quot;How are you doing&quot; 正则&quot;(?&lt;txt&gt;.+(?=ing))&quot; 这里取ing前所有的字符，并定义了一个捕获分组名字为 &quot;txt&quot; 而&quot;txt&quot;这个组里的值为&quot;How are you do&quot;;） (?&lt;=exp) -- 匹配exp后面的位置（如 &quot;How are you doing&quot; 正则&quot;(?&lt;txt&gt;(?&lt;=How).+)&quot; 这里取&quot;How&quot;之后所有的字符，并定义了一个捕获分组名字为 &quot;txt&quot; 而&quot;txt&quot;这个组里的值为&quot; are you doing&quot;;） (?!exp) -- 匹配后面跟的不是exp的位置（如 &quot;123abc&quot; 正则 &quot;\d{3}(?!\d)&quot;匹配3位数字后非数字的结果） (?&lt;!exp) -- 匹配前面不是exp的位置（如 &quot;abc123 &quot; 正则 &quot;(?&lt;![0-9])123&quot; 匹配&quot;123&quot;前面是非数字的结果也可写成&quot;(?!&lt;\d)123&quot;） 说明：本章未完全将正则字符列出! 正则表达式全集 参考资源 参考1 参考2 参考3 参考4]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>regexpal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uml用例图]]></title>
    <url>%2F2017%2F11%2F22%2Fuml%E7%94%A8%E4%BE%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[希望通过此加深对uml用例图的理解！ 用例图(Use Case Diagram) 定义： 用例图是指由参与者、用例以及它们之间的关系构成的用于描述系统功能的静态视图。用例图是被称为参与者的外部用户所能观察到的系统功能的模型图，呈现了一些参与者和一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行建模。 深入理解： 用例图是从用户角度描述系统功能，根据用户提出的需求描述系统的行为及各种功能之间的关系，通过用例图可以知道一个系统能够做什么，它要实现什么功能。用例图用于开发人员与用户之间的交流，以便开发人员很好的理解用户需求。 用例图的基本组成元素 参与者：参与者是与系统进行交互的用户或外部系统，是用例的启动者，在用例图中用小人表示。 用例：一系列可完成系统功能的动作，如机房收费系统中的“注册”、“充值”、“退卡”等，也可以理解为外部可见的系统功能，对系统提供的服务进行描述，用椭圆表示。 关系：描述参与者与用例之间的联系，用不同的连线表示。 UML用例图关系 关联(Association) 表示参与者与用例之间的通信，任何一方都可发送或接受消息。 包含(include) 使用包含（Inclusion）用例来封装一组跨越多个用例的相似动作（行为片断），以便多个基（Base）用例复用。基用例控制与包含用例的 关系，以及被包含用例的事件流是否会插入到基用例的事件流中。基用例可以依赖包含用例执行的结果，但是双方都不能访问对方的属性 扩展(extend) 将基用例中一段相对独立并且可选的动作，用扩展（Extension）用例加以封装，再让它从基用例中声明的扩展点（Extension Point）上进行扩展，从而使基用例行为更简练和目标更集中。扩展用例为基用例添加新的行为。扩展用例可以访问基用例的属性，因此它能根据基用例中扩展点的当前状态来判断是否执行自己。但是扩展用例对基用例不可见。 泛化(generalization) 子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。在实际应用中很少使用泛化关系，子用例中的特殊行为都可以作为父用例中的备选流存在。 关系图 注释(Comment)【不多说有图有真相！】 uml用例图新加关系 关联、泛化、包含、扩展4种关系，是UML定义的标准关系。 VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示 表示源用例依赖于目标用例 说明：此外vs2010中还引入了“项目(Artifact)”的元素 参考1 参考2 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>uml</tag>
        <tag>uml用例图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uml类图关系]]></title>
    <url>%2F2017%2F11%2F22%2Fuml%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[今天在上机课上，在制作uml类图中总感觉对uml类图中的关系不是太清楚，希望通过这一篇文章可以有一个深入的了解和学习！ 1.基本概念 类图（Class Diagram）: 类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。 类图的3个基本组件：类名、属性、方法。 2.UML类图关系 泛化（Generalization）： 表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 （Realization）: 在类图中就是接口和实现的关系,在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口 依赖(Dependency): 代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系,在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。 关联(Association): 在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 聚合(Aggregation): 表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。 组合(Composition): 表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。 多重性(Multiplicity) : 通常在关联、聚合、组合中使用。就是代表有多少个关联对象存在。使用数字..星号（数字）表示。 实现（Realization）: 是一种类与接口的关系, 表示类是接口所有特征和行为的实现,带三角箭头的虚线，箭头指向接口 UML类间关系的种类图 参考1 参考2]]></content>
      <categories>
        <category>uml</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>uml</tag>
        <tag>uml类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F11%2F20%2Fgit%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次 !@#!@#%!@# 什么的，你懂的哈 就是贼厉害！ Git的诞生同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许上千个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统。 安装Git(只介绍winn7系统) git下载官网 一路next安装即可 安装完成，在开始菜单里找到“Git”-&gt;“Git Bash”，出现类似命令行窗口的东西，即Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： git config –global user.name “Your Name”（Your Name是你github上的用户名，如：aqqje） git config –global user.email “email@example.com“ 创建版本库说明： 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： mkdir learngit -- 新建一个名叫learngit的文件夹 cd learngit -- 进入learngit文件夹 pwd -- 显示当前目录 初始化仓库 git init -- 初始化learngi文件夹为仓库 初始化仓库后会出现一个 .git 目录(默认隐藏)，使用ls -ah命令就可以看见。 git指令说明: 在讲解git指令之前，我们必须先了解git的分区： 工作区（working directory） 暂缓区（stage index） 历史记录区（history） 三个区域关系：工作区是我们能看到的区域，我们在工作区修改增加代码；完成编辑后，我们用git add 将工作区文件添加到暂存区；然后利用git commit 提交文件到我们自己的分支。 增删改查:git add &lt;文件名&gt; -- 工作区文件添加到暂存区 git add . -- 工作区所有修改动态添加到暂存区 git commit -m &quot;提交说明&quot; -- 提交git add后的文件到我们自己的分支 git status -- 掌握仓库当前的状态(*红色*代表未add未commit,*绿色*代表未commit) git diff &lt;文件名&gt; -- 能查看该文件具体修改了什么内容 git checkout --&lt;文件名&gt; -- 使该文件在工作区的修改全部撤销(这有两种情况:1.该文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 2.该文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态) git reset HEAD &lt;文件名&gt; -- 可以把暂存区的修改撤销掉（unstage） git rm &lt;文件名&gt; 版本:git log -- 显示从最近到最远的提交日志 git log --pretty=oneline -- 显示从最近到最远*简化*的提交日志 git reset --hard HEAD^ -- 显示当前版本 cat &lt;文件名&gt; -- 显示当前文件的内容 git reset --hard &lt;commit id&gt; -- 退回commit id 时的版本 git reflog -- 记录你的每一次reset和commit的命令 git diff HEAD -- &lt;文件名&gt; -- 查看该文件工作区和版本库里面最新版本的区别 -- 从版本库中删除该文件 远程仓库:git remote add origin &lt;远程仓库地址&gt; -- 添加一个仓库地址的别名,即origin git remote -v -- 可以查看对应的*别名*和*远程仓库地址* git push -u origin master -- 把本地仓库push到远程仓库上 git pull origin master -- 把远程仓库pull到本地仓库 git clone &lt;远程仓库地址&gt; -- 把对应的远程仓库地址的内容clone到本地 分支:git checkout dev -- 创建dev分支 git checkout -b dev -- 创建dev分支并切换到dev分支上 git branch -- 查看所有分支(绿色代表当前分支) git checkout &lt;分支名&gt; -- 切换到对应的分支上 git merge &lt;分支名&gt; -- 把对应分支合并到当前分支上 git brand -d &lt;分支名&gt; -- 删除对应的分支 分支图:git log --graph -- 查看分支合并图 分支管理：说明： Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 git merge --no-ff -m &quot;说明修改&quot; &lt;分支名&gt; -- --no-ff参数，表示禁用Fast forward -m &quot;说明修改&quot; 代表一个commit bug分支：情境：当你接到在master主分支上有修复bug的任务代号:bug_001,想创建一个分支bug_001来修复它，但当前正在dev上进行的工作还没有提交： git stash -- 把当前工作现场“储藏”起来，等以后bug_001修复好后继续工作 git checkout master -- 回到master主分支 git ckeckout -b bug_001 -- 创建bug_001分支并切换到bug_001分支上 git add . -- 添加修复 git commit -m &quot;修复bug_001&quot; -- 提交bug_001修复 git checkout master -- 回到master主分支 git merge --no-ff -m &quot;merged bug_001&quot; bug_001 -- 合并bug_001分支到master主分支上并commit&quot;merged bug_001&quot;日志 git checkout dev -- 切换到dev分支上 git stash list -- 查看“储藏”起来工作现场 【*git stash apply -- 修复储藏”起来工作现场（但是恢复后，stash内容并不删除，你需要用git stash drop来删除） git stash pop -- 修复储藏”起来工作现场（恢复的同时把stash内容也删了）*】 git stash apply stash@{0} -- 恢复指定的stash feature分支：情境：软件开发过程中，添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。现在，有一个新的功能需要实现，代号为newfunction。 git checkout -b feature_newfc -- 创建feature_newfc分支并切换到feature_newfc准备开发 git add newfunction.py -- 开发完成并添加到暂存区 git commit -m &quot;add newfunction&quot; -- 提交到feature_newfc上 git chekout master -- 切换到master主分支上，准备合并分支 git merge feature_newfc -- 合并feature_newfc分支到master主分支 新情境： 刚刚开发的新功能，因经费不足，新功能必须取消！（没有开发完成！还没有合并到master主分支）如何就地销毁呢？ git bracnch -d feature_newfc -- 准备销毁feature_newfc分支，但因为还没有合并报错，就地销毁失败！ git bracnch -d feature_newfc -- 强行销毁，销毁成功！ 标签管理说明： Git中打标签非常简单，首先，切换到需要打标签的分支上， 创建的标签都只存储在本地，不会自动推送到远程，所以，打错的标签可以在本地安全删除。 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除。删除命令也是push git branch -- 查看所有分支（带绿色*的是当前分支） git checkout master -- 切换到master主分支上 git tag &lt;新建标签名&gt; -- 新建一个标签 git tag -- 查看所有标签 git log --pretty=oneline --abbrev-commit -- 查询历史提交的commit id git tag &lt;tag commit id&gt; -- 回到指定的tag git show &lt;tagname&gt; -- 查看标签信息 git tag -a v0.1 -m &quot;version 0.1 released&quot; -- 创建带有说明的标签，用-a指定标签名，-m指定说明文字 git tag -s v0.2 -m &quot;signed version 0.2 released&quot; -- 通过-s用私钥签名一个标签（签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错！如果报错，请参考GnuPG帮助文档配置Key！） git tag -d &lt;tagname&gt; -- 删除标签 git push origin &lt;tagname&gt; -- 推送某个标签到远程 git push origin --tags -- 一次性推送全部尚未推送到远程的本地标签 【*git tag -d &lt;tagname&gt; -- 标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除 git push origin :refs/tags/&lt;tagname&gt; --然后，从远程删除。也是push*】 自定义Gitgit config --global color.ui true -- 让Git显示颜色，会让命令输出看起来更醒目(一般默认不用自己再配置！) 其它配置指令请百度，这里不一一指出！ 别名git config --global alias.co checkout -- 等同 git co dev git config --global alias.ci commit -- 等同 git ci -m &quot;提交说明&quot; git config --global alias.br branch -- 等同 git br ... 注意：所有的尖括号皆可以省略！ 参考1 参考2 参考3 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github博客绑定域名]]></title>
    <url>%2F2017%2F11%2F20%2Fgithub%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在github上成功搭建了一个属于自己的小空间后，是不是感到十分的开心，就差没跳舞了！- -，可是感觉还是不够完美！还得有一个自己的域名才好！SEE! 绑定域名… 1.添加CNAME文件向 yourname.github.io/source 目录添加一个CNAME(一定要大写且文件名没有后缀名)文件文件中增加一个域名 如: aqqje.com 2.向你的 DNS 配置中添加 3 条记录 @ A 192.30.252.153 @ A 192.30.252.154 www CNAME username.github.io用你自己的 Github 用户名替换 username我是在万网注册的域名，解析是阿里云解析配置 DNS 推荐使用 DNSPOD 的服务，使用国外的 DNS 解析服务可能有被墙的风险至于如何使用 DNSPOD 解析域名参考 等待你的 DNS 配置生效对DNS的配置不是立即生效的，过10分钟再去访问你的域名看看有没有配置成功 说明：此篇文章解析工具是阿里云，其实工具是否适用概不负责。 参考作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建博客]]></title>
    <url>%2F2017%2F11%2F19%2Fgithub-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[通过几天的努力终于把hexo+github形式的博客搭建好了！正文：hexo搭建博客还是很容易的！更换主题也很简单！ 配置环境 安装Node(必须)一路安装即可作用：用于生成静态页面。Node.js官网https://nodejs.org/en/ 安装Git(必须)大部分按默认安装，一路安装即可作用：把本地的hexo内容提交到github上去(博客备份地址不是你的网站地址) 验证软件正确安装 git –version node -v npm -v 申请GitHub 点击-&gt;GitHub进入官网注册帐号 分别输入用户名、邮箱、密码，然后点击注册 “New repository”新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 安装Hexo 因为有“墙”，安装hexo为了避免出现类似情况，使用淘宝NPM镜像,输入以下命令等待安装完成 $ npm install -g cnpm –registry=https://registry.npm.taobao.org 使用淘宝NPM安装Hexo cnpm install -g hexo-cli 与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成 继续输入以下命令安装 cnpm install hexo –save 验证hexo是否安装成功 hexo -v 本地运行hexo 新建一个文件夹做为你的博客的文件 进入你的博客文件，使用 Git Bash 进行初始化hexo hexo init 安装生成器 cnpm install 运行hexo,以后要在本地运行博客只要输入该命令即可 打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了 停止运行(按住Ctrl+C键即可停止) 管理博客 配置信息打开您博客根目录下的_config.yml文件，进行配置 {％blockquote％}博客名称title: 我的博客副标题subtitle: 一天进步一点简介description: 记录生活点滴博客作者author: John Doe博客语言language: zh-CN时区timezone:博客地址,与申请的GitHub一致url: http://elfwalk.github.ioroot: /博客链接格式permalink: :year/:month/:day/:title/permalink_defaults:source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:default_category: uncategorizedcategory_map:tag_map:日期格式date_format: YYYY-MM-DDtime_format: HH:mm:ss分页，每页文章数量per_page: 10pagination_dir: page博客主题theme: landscape发布设置deploy: type: git elfwalk改为你的github用户名 repository: https://github.com/elfwalk/elfwalk.github.io.git branch: master{％endblockquote％} 写一篇文章输入创建文章命令，生成一个md文件(/blog/source/_posts/) hexo new “hello” 用编辑器打开hello.md文件,编写完后保存{％blockquote％}title: hellodate: 2015-07-01 22:37:23categories: 日志 二级目录tags: hello 摘要:正文:{％endblockquote％} 发布博客 设置git身份信息 git config –global user.name “你的用户名” git config –global user.email “你的邮箱” 安装hexo git插件 cnpm install hexo-deployer-git –save 发布更新博客 hexo d -g 发布成功后，访问yourname.github.io看下成果 参考：http://hifor.net/2015/07/01/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-hexo-github作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再别康桥]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%86%8D%E5%88%AB%E5%BA%B7%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[正文： 再别康桥作者: 徐志摩 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 1928.11.6 中国上海 参考资源 徐志摩_百度百科徐志摩诗集]]></content>
      <categories>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2017%2F11%2F16%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 1.斜体和粗体代码： 1.*斜体* 或 _斜体_ 2.**粗体** 3.***加粗斜体*** 4.~~删除线~~ 显示效果: 这是一段体 或 这是一段体 这是一段粗体 这是一段加粗斜体 这是一段删除 2.分组标题第一种写法：1.这是一个一级标题 2.============================ 3. 4.这是一个二级标题 5.-------------------------------------------------- 第二种写法：1.# 一级标题 2.## 二级标题 3.### 三级标题 4.#### 四级标题 5.##### 五级标题 6.###### 六级标题 3.超链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1. 行内式语法说明： []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。链接文字’这样的形式。链接地址与链接标题前有一个空格。 1.梦不若星辰[aqqje](https://github.com/aqqje) 2.梦不若星辰[aqqje](https://github.com/aqqje &quot;aqqje&quot;) 显示效果:梦不若星辰aqqje 梦不若星辰aqqje 3.2. 参考式语法说明：参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行 1.[小米][1] [华为][2] [vivo][3] [oppo][4] 3.[1]:https://www.mi.com 4.[2]:https://www.huawei.com 5.[3]:https://www.vivo.com.cn/ 6.[4]:https://www.oppo.com/ 显示效果:小米 华为 vivo oppo 3.3. 自动链接语法说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 1.&lt;https:www.baibu.com/&gt; 2.&lt;1042136232@qq.com&gt; 显示效果:https://www.baibu.com/ &#49;&#x30;&#52;&#x32;&#x31;&#51;&#54;&#x32;&#x33;&#50;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109; 4. 锚点5. 列表语法说明：使用 *，+，- 表示无序列表。 1. - 无序列表项 一 2. - 无序列表项 二 3. - 无序列表项 三 显示效果: 无序列表项 一 无序列表项 二 无序列表项 三 5.2. 有序列表语法说明：有序列表则使用数字接着一个英文句点。 1. 1. 有序列表项 一 2. 2. 有序列表项 二 3. 3. 有序列表项 三 显示效果: 有序列表项 一 有序列表项 二 有序列表项 三 5.3. 定义型列表语法说明：定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab) 1.梦不若星辰1 2.： 相见亦无事，不遇长相思（左侧有一个可见的冒号和四个不可见的空格） 3.代码2 4.: 梦不若星辰2（左侧有一个可见的冒号和四个不可见的空格） 5 梦不若星辰3（左侧有八个不可见的空格） 显示效果:梦不若星辰1 ： 相见亦无事，不遇长相思（左侧有一个可见的冒号和四个不可见的空格） 代码2 : 梦不若星辰2（左侧有一个可见的冒号和四个不可见的空格） 梦不若星辰3（左侧有八个不可见的空格） 5.3. 列表缩进语法说明：列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符 1.* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 2.* 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 3.* 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 3.* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 显示效果: 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 5.4. 包含段落的列表语法说明：列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符 1.* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 2. 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 3. 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 3. 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 显示效果: 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 5.5. 包含引用的列表语法说明：如果要在列表项目内放进引用，那 &gt; 就需要缩进 1.* 阅读的方法 2. 3. &gt;打开书本 4. &gt;打开电灯 显示效果: 阅读的方法 打开书本 打开电灯 5.6. 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符。 一列表项包含一个列表区块 &lt;1.代码写在这&gt; 5.7. 一个特殊情况在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法： 1.2017.Hello world! 显示效果: Hello world! 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠 1.2017.Hello world! 显示效果:2017.Hello world! 6. 引用语法说明：引用需要在被引用的文本前加上&gt;符号 &gt; 这是一个有两段文字的引用, &gt; 无意义的占行文字1. &gt; 无意义的占行文字2. &gt; &gt; 无意义的占行文字3. &gt; 无意义的占行文字4. 显示效果: 这是一个有两段文字的引用.无意义的占行文字1.无意义的占行文字2. 无意义的占行文字3.无意义的占行文字4 Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; 这是一个有两段文字的引用. 无意义的占行文字1. 无意义的占行文字2. 无意义的占行文字3. 无意义的占行文字4 6.1. 引用的多层嵌套语法说明：区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; 1.&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白 2.&gt; 3.&gt;&gt; 自己看教程！ - 愤青 4.&gt; 5.&gt; 教程在哪？ - 小白 显示效果: 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 6.2. 引用其它要素语法说明：引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。 1.&gt; 1. 这是第一行列表项。 2.&gt; 2. 这是第二行列表项。 3.&gt; 4.&gt; 给出一些例子代码： 5.&gt; 6.&gt; return shell_exec(&quot;echo $input | 7.7.$markdown_script&quot;); 显示效果: 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 7. 插入图像图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 7.1. 行内式语法说明： 1.![神界传说](https://github.com/aqqje/images/raw/master/markdown_test/0.jpeg &quot;神界传说&quot;) 显示效果: 7.2. 参考式语法说明： 1.![神界传说][神界传说] 2. 3.[神界传说]:https://github.com/aqqje/images/raw/master/markdown_test/0.jpeg &quot;神界传说&quot; 显示效果: 8. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 9. 注脚语法说明：在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。 使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 显示效果:使用 Markdown^1 可以效率的书写文档, 直接转换成 HTML[^2],你可以使用 Leanote^3 编辑器进行书写。 [^2]:HyperText Markup Language 超文本标记语言 10. LaTeX 公式10.1. $ 表示行内公式1.质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 显示效果:质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 10.2 $$ 表示整行公式1.$$\sum_{i=1}^n a_i=0$$ 2.$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ 3.$$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$ 显示效果:$$\sum_{i=1}^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法 11. 流程图1.flow 2.st=&gt;start: Start:&gt;https://www.zybuluo.com 3.io=&gt;inputoutput: verification 4.op=&gt;operation: Your Operation 5.cond=&gt;condition: Yes or No? 6.sub=&gt;subroutine: Your Subroutine 7.e=&gt;end 8. 9.st-&gt;io-&gt;op-&gt;cond 10.cond(yes)-&gt;e 11.cond(no)-&gt;sub-&gt;io 显示效果：flowst=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考 12 .表格语法说明：1.不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。2.列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。3.第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。 简单方式写表格： 1学号|姓名|分数 2.-|-|- 3.小明|男|75 4.小红|女|79 5.小陆|男|92 显示效果： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 原生方式写表格： 1.|学号|姓名|分数| 2.|-|-|-| 3.|小明|男|75| 4.|小红|女|79| 5.|小陆|男|92| 显示效果： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 为表格第二列指定方向： 1.产品|价格 2.-|-: 3.Leanote 高级账号|60元/年 4.Leanote 超级账号|120元/年 显示效果： 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 13. 分隔线语法说明：在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线。 1.* * * 2. 3.*** 4. 5.***** 6. 7.- - - 8. 9.--------------------------------------- 显示效果： 14. 代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用””符号（一般在ESC键下方）包裹代码 语法说明：&lt;br/&gt; 1.插入行内代码，即插入一个单词或者一句代码的情况，使用code这样的形式插入。 2.插入多行代码，可以使用缩进或者“ code “` 1.C语言里的函数 `scanf()` 怎么使用？ 显示效果：C语言里的函数scanf()怎么使用？ 8.2. 缩进式多行代码缩进 4 个空格或是 1 个制表符 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world\n&quot;); } 显示效果： #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello world\n&quot;); } 8.3. 用六个`包裹多行代码12345678 #include &lt;stdio.h&gt; int main(void) &#123; printf(&quot;Hello world\n&quot;); &#125; 、、、###### 显示效果： #include &lt;stdio.h&gt;int main(void){ printf(“Hello world\n”);}` 8.4. HTML 原始码在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理 &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 显示效果： 值班人员 星期一 星期二 星期三 李强 张明 王平 参考1 参考2 作者：梦不若星辰链接：https://aqqje.github.io著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2017%2F11%2F16%2Fhello%2F</url>
    <content type="text"><![CDATA[摘要:正文:欢迎来到我的个人博客！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
